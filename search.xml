<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[针对as?的使用优化]]></title>
    <url>%2F2020%2F04%2F13%2FKotlin_asType%2F</url>
    <content type="text"><![CDATA[前言写代码的时候往往会用到类型检测is和类型转换as或者空安全的类型转换as?，在这里记录一下使用as?的一点优化。 正常使用举个例子123456789101112fun getCurrentProcessName(context: Context?): String &#123; return try &#123; (context?.getSystemService(Context.ACTIVITY_SERVICE) as? ActivityManager) ?.runningAppProcesses ?.first &#123; it.pid == android.os.Process.myPid() &#125; ?.processName ?: "" &#125; catch (e: Exception) &#123; "" &#125;&#125; 在正常使用的时候，往往是要在外面加一层括号()，这样写代码就很麻烦，不能一步到位，那要怎么样才能把这括号删掉呢？ 加工之后首先我们要想到扩展和reified，然后写一个方法来实现类型转换：12345678910111213141516inline fun &lt;reified T&gt; Any?.asType(): T? &#123; // 如果类型转换成功，那么返回对应的`T`类型，如果转换失败，那么就会返回`null` return this as? T&#125;// 或者// 这个方法是https://droidyue.com/blog/2020/03/29/kotlintips-as-type/，里面的实现inline fun &lt;reified T&gt; Any.asType1(): T? &#123; // 先检查this的类型，如果是T则返回T，否则返回null return if (this is T) &#123; this &#125; else &#123; null &#125;&#125; 说一下is、as、as?的区别 is是表示类型检查，与Java的instanceof一样 as是表示不安全的类型转换，但是左边的类型如果是空的那么就会抛出一个异常，这就是所谓的不安全的，对应Java的强转 as?则表示安全的类型转换，如果转换失败则不会抛出异常，而是直接返回null，对应Java的话则是if (test instanceof String) String str = (String) test，先instanceof，然后再强转。 所以上面两种写法都可以用，最终实现的目的都是一样的，最后看调用的代码：12345678910111213fun getCurrentProcessName(context: Context?): String &#123; return try &#123; context?.getSystemService(Context.ACTIVITY_SERVICE) ?.asType&lt;ActivityManager&gt;() ?.runningAppProcesses ?.first &#123; it.pid == android.os.Process.myPid() &#125; ?.processName ?: "" &#125; catch (e: Exception) &#123; "" &#125;&#125; 这样写起来的会就很顺畅了，直接一步到位，不用再写完as之后在写一个括号，然后再回来接着写下面的代码。 感谢 KotlinTips asType 快捷转换]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>As</tag>
        <tag>Is</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Kotlin委托来简化获取Intent参数的方式]]></title>
    <url>%2F2019%2F08%2F27%2FKotlin_intent_get_extra%2F</url>
    <content type="text"><![CDATA[前言在Activity/Fragment获取传递过来的参数的时候，需要使用intent/arguments来获取对应的值，每次都要写一堆的intent.getStringExtra等等的代码，为什么不使用kotlin的委托属性来减少重复代码呢？ 默认获取参数方式下面有几种常用的获取参数的方法 使用默认值12345678// 声明private var test: String? = ""// Activity获取test = intent.getStringExtra("test")// Fragment获取test = arguments?.getString("test") 注意不能直接在声明属性的时候获取值，如private val test: String = intent.getStringExtra(&quot;test&quot;)这样写会直接报错的，因为在init的时候getIntent返回的是空。 说下缺点，很明显，每次都要写get的代码，很烦，而且每次使用还要加?。 使用lateinit12345678// 由于lateinit声明，所以类型不能为空private lateinit var test: String// Activity获取test = intent.getStringExtra("test")// Fragment获取，因为getArguments返回的值是可空的，所以还要加个判断test = arguments?.getString("test") ?: "" 说下缺点，同第一种，也是每次都要写，但是比第一种要少加个?。 使用lazy（属于kotlin的标准委托）123private val test by lazy &#123; intent.getStringExtra("test")&#125; 比上面两种好多了，但是lazy一般会带有额外的开销，除非使用LazyThreadSafetyMode.NONE模式，而且lazy是用val声明，如果要修改，那就得重新声明一个属性… 改变方式那么有没有好的方法来减少重复代码呢，并且即可声明为val，也可声明为var呢？我们要达到的效果应该是下面这样123private val test by extraAct("test", "")private var test1 by extraAct("test1", "") 这里就要用到kotlin的委托属性了，有一种属性，在使用的时候每次都要手动实现它，但是可以做到只实现一次，并且放到库中，一直使用，这种属性称为委托属性。具体介绍可见https://www.kotlincn.net/docs/reference/delegated-properties.html。 委托属性的级别语法是 val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt; 实现接口，重写方法ReadWriteProperty实际上我们要写的就是实现ReadWriteProperty接口，然后在getValue和setValue，进行获取和设置对应的值。1234567interface ReadWriteProperty&lt;in R, T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)&#125; 首先声明一个类，然后实现ReadWriteProperty接口 创建两个参数，一个是参数名extraName，类型为String；一个是默认值default，泛型 然后声明一个属性，用于保存获取对应字段的值，可空类型。 12345678910111213141516class ActivityExtras&lt;T&gt;(private val extraName: String, private val defaultValue: T) : ReadWriteProperty&lt;Activity, T&gt; &#123; /** * getExtras字段对应的值 */ private var extra: T? = null override fun getValue(thisRef: Activity, property: KProperty&lt;*&gt;): T &#123; // 返回值 &#125; override fun setValue(thisRef: Activity, property: KProperty&lt;*&gt;, value: T) &#123; // 设置值 &#125;&#125; 因为我们是在Activity里面获取对应的Intent参数的值，所以thisRef的类型就必须写成Activity。 getValue然后来获取对应的字段的值：1234override fun getValue(thisRef: Activity, property: KProperty&lt;*&gt;): T &#123; return extra ?: thisRef.intent?.get&lt;T&gt;(extraName)?.also &#123; extra = it &#125; ?: defaultValue.also &#123; extra = it &#125;&#125; 来说明下这段代码： 首先是如果extra不为空，则返回extra 如果extra是空的，则判断intent的参数的值，如果值不为空，则返回，并且将值赋予extra 如果intent参数的值也为空，则返回defaultValue，并且将值赋予extra Intent的get扩展见 https://github.com/Ifxcyr/ActivityMessenger setValue设置值的话就很简单了，直接将value赋值给extra就行了123override fun setValue(thisRef: Fragment, property: KProperty&lt;*&gt;, value: T) &#123; extra = value&#125; 结束粗劣调用调用的时候呢，就这样写1private val test by ActivityExtras&lt;String?&gt;("test", null) 改进emmmm，还是有一点区别，如果我不想用默认值的时候，直接替我声明为null。那么就要定义函数，返回的类型是ActivityExtras就可以。1234fun &lt;T&gt; extraAct(extraName: String): ActivityExtras&lt;T?&gt; = ActivityExtras(extraName, null)fun &lt;T&gt; extraAct(extraName: String, defaultValue: T): ActivityExtras&lt;T&gt; = ActivityExtras(extraName, defaultValue) 最终调用效果12345678private val test: String? by extraAct("test") // 类型为String?private val test1 by extraAct&lt;String&gt;("test1") // 类型为String?private var test2 by extraAct("test2", "1") // 类型为String// 修改的时候，直接赋值就行test2 = "123" 结论委托属性其实很简单，实现了ReadWriteProperty接口之后，在调用属性的get和set的时候自动帮你调用对应的getValue和setValue函数，省去了重复的代码操作。如果是ReadOnlyProperty的话，那么就只提供getValue函数，只能获取，不能修改属性。 对应Fragment代码对应的Fragment代码，使用的时候，同ActivityExtras1234567891011121314151617181920212223242526272829/** * 获取Intent参数，Fragment * 示例同[ActivityExtras] */class FragmentExtras&lt;T&gt;(private val extraName: String, private val defaultValue: T) : ReadWriteProperty&lt;Fragment, T&gt; &#123; /** * getExtras字段对应的值 */ private var extra: T? = null override fun getValue(thisRef: Fragment, property: KProperty&lt;*&gt;): T &#123; // 如果extra不为空则返回extra // 如果extra是空的，则判断arguments的参数的值，如果值不为空，则将值赋予extra，并且返回 // 如果arguments参数的值也为空，则返回defaultValue，并且将值赋予extra return extra ?: thisRef.arguments?.get&lt;T&gt;(extraName)?.also &#123; extra = it &#125; ?: defaultValue.also &#123; extra = it &#125; &#125; override fun setValue(thisRef: Fragment, property: KProperty&lt;*&gt;, value: T) &#123; extra = value &#125;&#125;fun &lt;T&gt; extraFrag(extraName: String): FragmentExtras&lt;T?&gt; = FragmentExtras(extraName, null)fun &lt;T&gt; extraFrag(extraName: String, defaultValue: T): FragmentExtras&lt;T&gt; = FragmentExtras(extraName, defaultValue) 源码地址 https://github.com/Ifxcyr/ActivityMessenger]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Delegate</tag>
        <tag>ReadWriteProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次写Intent的扩展]]></title>
    <url>%2F2019%2F02%2F11%2FAndroid-Intent-Extension%2F</url>
    <content type="text"><![CDATA[前言写项目的时候经常会写到跳转Activiey，写到跳转Activit就一定会写到putExtra，就像下面那样123intent.putExtra("a", item.a)intent.putExtra("b", item.b)intent.putExtra("c", item.c) 挺多哈，每次都要重复前面相同的内容，所以就想着能不能写个扩展来简写。 开始我们最终实现是这样的：123456Intent(context, TestActivity::class.java) .putExtraVararg( "a" to item.a, "b" to item.b, "c" to item.c ) 仿mapOf经常用到mapOf()或者mutableMapOf()就会知道，里面是用了Pair类来生成Map的，所以受此启发，打算用Pair来作为参数实现，那么写的时候就应该是这样写，参数为可变参数类型：123456// 作为Intent的扩展fun Intent.putExtraVararg( vararg extras: Pair&lt;String, Any?&gt;): Intent &#123; // 先省略&#125; putExtra的第一个参数类型肯定是String类型，第二个参数的类型包括Bundle, Boolean, BooleanArray, Byte, ByteArray, Char, CharArray, String等等，所以就用Any类型，因为是可空的，所以加上?。 那么调用的时候，就是这样子的123456Intent(context, TestActivity::class.java) .putExtraVararg( "a" to item.a, "b" to item.b, "c" to item.c ) 是不是就是一开始说的那样，对比平常写的是不是简单了很多。 参数类型匹配写好了参数，那么就要进行对参数类型的匹配进行对应的putExtra。 vararg参数可以用forEach来循环对每个参数类型进行匹配：1234567891011121314151617181920212223242526272829303132333435363738fun Intent.putExtraVararg( vararg extras: Pair&lt;String, Any?&gt;): Intent &#123; if (extras.isEmpty()) return this extras.forEach &#123; (key, value) -&gt; value ?: let &#123; it.putExtra(key, it.toString()) return@forEach &#125; when (value) &#123; is Bundle -&gt; this.putExtra(key, value) is Boolean -&gt; this.putExtra(key, value) is BooleanArray -&gt; this.putExtra(key, value) is Byte -&gt; this.putExtra(key, value) is ByteArray -&gt; this.putExtra(key, value) is Char -&gt; this.putExtra(key, value) is CharArray -&gt; this.putExtra(key, value) is String -&gt; this.putExtra(key, value) is CharSequence -&gt; this.putExtra(key, value) is Double -&gt; this.putExtra(key, value) is DoubleArray -&gt; this.putExtra(key, value) is Float -&gt; this.putExtra(key, value) is FloatArray -&gt; this.putExtra(key, value) is Int -&gt; this.putExtra(key, value) is IntArray -&gt; this.putExtra(key, value) is Long -&gt; this.putExtra(key, value) is LongArray -&gt; this.putExtra(key, value) is Short -&gt; this.putExtra(key, value) is ShortArray -&gt; this.putExtra(key, value) is Parcelable -&gt; this.putExtra(key, value) is Serializable -&gt; this.putExtra(key, value) else -&gt; &#123; throw IllegalArgumentException("Not support $value type $&#123;value.javaClass&#125;..") &#125; &#125; &#125; return this&#125; 发现没有，还少了ArrayList&lt;String&gt;、ArrayList&lt;CharSequence&gt;、ArrayList&lt;? extends Parcelable&gt;这三个List的参数类型匹配，因为不能直接is来匹配对应的Array类型，在群里问过之后，才得出最终的方法，Array里面有一个匹配对应类型的扩展函数isArrayOf()：123456/** * Checks if array can contain element of type [T]. */@Suppress("REIFIED_TYPE_PARAMETER_NO_INLINE")public fun &lt;reified T : Any&gt; Array&lt;*&gt;.isArrayOf(): Boolean = T::class.java.isAssignableFrom(this::class.java.componentType) so，这样就简单了，我们先匹配Array，然后在匹配对应的ArrayList&lt;String&gt;、ArrayList&lt;CharSequence&gt;、ArrayList&lt;? extends Parcelable&gt;，最后在对应put方法那里用as：1234567891011121314is Array&lt;*&gt; -&gt; &#123; @Suppress("UNCHECKED_CAST") when &#123; value.isArrayOf&lt;String&gt;() -&gt; &#123; this.putStringArrayListExtra(key, value as ArrayList&lt;String?&gt;) &#125; value.isArrayOf&lt;CharSequence&gt;() -&gt; &#123; this.putCharSequenceArrayListExtra(key, value as ArrayList&lt;CharSequence?&gt;) &#125; value.isArrayOf&lt;Parcelable&gt;() -&gt; &#123; this.putParcelableArrayListExtra(key, value as ArrayList&lt;out Parcelable?&gt;) &#125; &#125;&#125; 这样就实现了不同Array类型的putExtra。 最终最后完整的代码为12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758fun Intent.putExtraVararg( vararg extras: Pair&lt;String, Any?&gt;): Intent &#123; if (extras.isEmpty()) return this extras.forEach &#123; val key = it.first val value = it.second ?: let &#123; it.putExtra(key, it.toString()) &#125; &#125; extras.forEach &#123; (key, value) -&gt; value ?: let &#123; it.putExtra(key, it.toString()) return@forEach &#125; when (value) &#123; is Bundle -&gt; this.putExtra(key, value) is Boolean -&gt; this.putExtra(key, value) is BooleanArray -&gt; this.putExtra(key, value) is Byte -&gt; this.putExtra(key, value) is ByteArray -&gt; this.putExtra(key, value) is Char -&gt; this.putExtra(key, value) is CharArray -&gt; this.putExtra(key, value) is String -&gt; this.putExtra(key, value) is CharSequence -&gt; this.putExtra(key, value) is Double -&gt; this.putExtra(key, value) is DoubleArray -&gt; this.putExtra(key, value) is Float -&gt; this.putExtra(key, value) is FloatArray -&gt; this.putExtra(key, value) is Int -&gt; this.putExtra(key, value) is IntArray -&gt; this.putExtra(key, value) is Long -&gt; this.putExtra(key, value) is LongArray -&gt; this.putExtra(key, value) is Short -&gt; this.putExtra(key, value) is ShortArray -&gt; this.putExtra(key, value) is Array&lt;*&gt; -&gt; &#123; @Suppress("UNCHECKED_CAST") when &#123; value.isArrayOf&lt;String&gt;() -&gt; &#123; this.putStringArrayListExtra(key, value as ArrayList&lt;String?&gt;) &#125; value.isArrayOf&lt;CharSequence&gt;() -&gt; &#123; this.putCharSequenceArrayListExtra(key, value as ArrayList&lt;CharSequence?&gt;) &#125; value.isArrayOf&lt;Parcelable&gt;() -&gt; &#123; this.putParcelableArrayListExtra(key, value as ArrayList&lt;out Parcelable?&gt;) &#125; &#125; &#125; is Parcelable -&gt; this.putExtra(key, value) is Serializable -&gt; this.putExtra(key, value) else -&gt; &#123; throw IllegalArgumentException("Not support $value type $&#123;value.javaClass&#125;..") &#125; &#125; &#125; return this&#125; 转成Java是这样的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public final class IntentExtKt &#123; @NotNull public static final Intent putExtraVararg(@NotNull Intent $receiver, @NotNull Pair... extras) &#123; Intrinsics.checkParameterIsNotNull($receiver, "receiver$0"); Intrinsics.checkParameterIsNotNull(extras, "extras"); if (extras.length == 0) &#123; return $receiver; &#125; else &#123; Pair[] var3 = extras; int var4 = extras.length; int var5; Pair element$iv; boolean var8; String key; for(var5 = 0; var5 &lt; var4; ++var5) &#123; element$iv = var3[var5]; var8 = false; key = (String)element$iv.getFirst(); if (element$iv.getSecond() == null) &#123; int var12 = false; $receiver.putExtra(key, $receiver.toString()); &#125; &#125; var3 = extras; var4 = extras.length; for(var5 = 0; var5 &lt; var4; ++var5) &#123; element$iv = var3[var5]; var8 = false; key = (String)element$iv.component1(); Object value = element$iv.component2(); if (value != null) &#123; if (value instanceof Bundle) &#123; $receiver.putExtra(key, (Bundle)value); &#125; else if (value instanceof Boolean) &#123; $receiver.putExtra(key, (Boolean)value); &#125; else if (value instanceof boolean[]) &#123; $receiver.putExtra(key, (boolean[])value); &#125; else if (value instanceof Byte) &#123; $receiver.putExtra(key, ((Number)value).byteValue()); &#125; else if (value instanceof byte[]) &#123; $receiver.putExtra(key, (byte[])value); &#125; else if (value instanceof Character) &#123; $receiver.putExtra(key, (Character)value); &#125; else if (value instanceof char[]) &#123; $receiver.putExtra(key, (char[])value); &#125; else if (value instanceof String) &#123; $receiver.putExtra(key, (String)value); &#125; else if (value instanceof CharSequence) &#123; $receiver.putExtra(key, (CharSequence)value); &#125; else if (value instanceof Double) &#123; $receiver.putExtra(key, ((Number)value).doubleValue()); &#125; else if (value instanceof double[]) &#123; $receiver.putExtra(key, (double[])value); &#125; else if (value instanceof Float) &#123; $receiver.putExtra(key, ((Number)value).floatValue()); &#125; else if (value instanceof float[]) &#123; $receiver.putExtra(key, (float[])value); &#125; else if (value instanceof Integer) &#123; $receiver.putExtra(key, ((Number)value).intValue()); &#125; else if (value instanceof int[]) &#123; $receiver.putExtra(key, (int[])value); &#125; else if (value instanceof Long) &#123; $receiver.putExtra(key, ((Number)value).longValue()); &#125; else if (value instanceof long[]) &#123; $receiver.putExtra(key, (long[])value); &#125; else if (value instanceof Short) &#123; $receiver.putExtra(key, ((Number)value).shortValue()); &#125; else if (value instanceof short[]) &#123; $receiver.putExtra(key, (short[])value); &#125; else if (value instanceof Object[]) &#123; if ((Object[])value instanceof String[]) &#123; $receiver.putStringArrayListExtra(key, (ArrayList)value); &#125; else if ((Object[])value instanceof CharSequence[]) &#123; $receiver.putCharSequenceArrayListExtra(key, (ArrayList)value); &#125; else if ((Object[])value instanceof Parcelable[]) &#123; $receiver.putParcelableArrayListExtra(key, (ArrayList)value); &#125; &#125; else if (value instanceof Parcelable) &#123; $receiver.putExtra(key, (Parcelable)value); &#125; else &#123; if (!(value instanceof Serializable)) &#123; throw (Throwable)(new IllegalArgumentException("Not support " + value + " type " + value.getClass() + "..")); &#125; $receiver.putExtra(key, (Serializable)value); &#125; &#125; else &#123; int var13 = false; $receiver.putExtra(key, $receiver.toString()); &#125; &#125; return $receiver; &#125; &#125;&#125; 顺手写别的扩展既然用到Intent的扩展，那么就顺手写下Activity的startActivity的扩展12345678910111213/** * 同Context的startActivity */fun Context.toActivity(packageContext: Context?, cls: Class&lt;*&gt;, vararg extras: Pair&lt;String, Any?&gt;) &#123; startActivity(Intent(packageContext, cls).putExtraVararg(*extras))&#125;/** * 同Context的startActivity */fun Context.toActivity(intent: Intent) &#123; startActivity(intent)&#125; 调用的时候就是这样子的123456789context.toActivity( context, SearchActivity::class.java, SearchActivity.SEARCH_TYPE to item.type, SearchActivity.SEARCH_UID to item.uid, SearchActivity.SEARCH_NAME to item.name, SearchActivity.SEARCH_KEY to item.key, SearchActivity.SEARCH_GROUP to item.group) 总结通过这次的扩展，也学到了关于Array的一些扩展函数，可以说是很美好了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Activity</tag>
        <tag>Intent</tag>
        <tag>Extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout 1.1版本的新特性]]></title>
    <url>%2F2018%2F06%2F10%2FAndroid-Constraint-1-1-Feture%2F</url>
    <content type="text"><![CDATA[很久没写博客了，因为一些事情耽搁了，现在我们来学习下ConstraintLayout1.1版本的新特性。 准备首先先将约束布局更新至最新123dependencies &#123; implementation 'com.android.support.constraint:constraint-layout:1.1.1'&#125; 开始Circular Positioning 简单来说就是圆的弧度约束，通过设置角度和半径来对一个控件进行类似于把一个控件放在圆上面。具有三个属性： layout_constraintCircle 约束的控件的id layout_constraintCircleRadius 约束距离圆心的距离，也就是圆的半径 layout_constraintCircleAngle 约束的角度(0-360度) 举个例子：1234567891011121314151617181920212223242526272829&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/btn_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button1" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt; &lt;Button android:id="@+id/btn_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button1" app:layout_constraintCircle="@+id/btn_1" app:layout_constraintCircleAngle="45" app:layout_constraintCircleRadius="150dp"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 平时我们算角度的时候是从右边开始算角度的，而这里是从顶部开始算的，所以上面的代码显示的内容就是下面那样的 有了这种圆形的约束，那么我们在做一些圆形旋转动画的时候就会很好写了，只需要在ConstraintLayout.LayoutParams的属性里面设置circleAngle的值就能轻松的旋转了：123456val angle = 100fbtn_1.setOnClickListener &#123; val layoutParams = btn_2.layoutParams as ConstraintLayout.LayoutParams layoutParams.circleAngle = angle btn_2.layoutParams = layoutParams&#125; 点击之后，就把btn_2给移到角度为100那里了。 Enforcing constraints控件宽高为WRAP_CONTENT的时候，会用到maxWidth和maxHeight这两个属性来实现控件的最大宽高，但是在约束布局中不起作用了： 12345678910111213141516171819202122232425&lt;ImageView android:id="@+id/image1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/dimension_match_constraints" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" android:maxWidth="10dp" android:maxHeight="10dp" tools:ignore="ContentDescription"/&gt;&lt;ImageView android:id="@+id/image2" android:layout_width="50dp" android:layout_height="50dp" android:src="@drawable/dimension_match_constraints" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" tools:ignore="ContentDescription"/&gt; 可以看出maxWidth和maxHeight在约束布局里面是不起作用的，在1.1里面就引入了WRAP_CONTENT : enforcing constraints强制约束的属性： app:layout_constrainedWidth=&quot;true|false&quot; app:layout_constrainedHeight=&quot;true|false&quot; 同时加入新的控制最大值最小值的属性： layout_constraintWidth_min和layout_constraintHeight_min 同minWidth属性 layout_constraintWidth_max和layout_constraintHeight_max 同maxWidth属性 设置新的属性之后：12345678910111213141516171819202122232425&lt;ImageView android:id="@+id/image1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/dimension_match_constraints" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" tools:ignore="ContentDescription"/&gt;&lt;ImageView android:id="@+id/image2" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constrainedWidth="true" app:layout_constrainedHeight="true" app:layout_constraintWidth_max="50dp" app:layout_constraintHeight_max="50dp" android:src="@drawable/dimension_match_constraints" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" tools:ignore="ContentDescription"/&gt; 效果是跟之前是一抹一样的 MATCH_CONSTRAINT dimensions约束布局中的match_parent被MATCH_CONSTRAINT代替了，还记得我们之前是如何实现一个控件实现占屏幕宽度的一半是怎么操作的吗？ 在1.1之后添加了三个属性，来实现对MATCH_CONSTRAINT属性的宽高控制： layout_constraintWidth_min和layout_constraintHeight_min 同minWidth属性 layout_constraintWidth_max和layout_constraintHeight_max 同maxWidth属性 layout_constraintWidth_percent和layout_constraintHeight_percent 根据父布局的百分百设置长款 现在我们实现一个控件实现占屏幕宽度的一半，是什么样子的呢？1234567891011121314151617181920212223242526&lt;Button android:id="@+id/btn1" android:layout_width="0dp" android:layout_height="wrap_content" android:text="Botton11111111111111" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintWidth_percent="0.5"/&gt;&lt;Button android:id="@+id/btn2" android:layout_width="0dp" android:layout_height="wrap_content" android:text="Botton11111111111111" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/btn1" app:layout_constraintWidth_max="100dp"/&gt;&lt;Button android:id="@+id/btn3" android:layout_width="0dp" android:layout_height="wrap_content" android:text="Bo" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/btn2" app:layout_constraintWidth_min="200dp"/&gt; 这样就实现了，是不是感觉比之前用GuideLine实现要简单的多呢。 在MATCH_CONSTRAINT可以实现WRAP_CONTENT的效果，设置layout_constraintWidth_default属性值为wrap，默认值是spread：123456789101112131415161718192021&lt;Button android:id="@+id/btn1" android:layout_width="0dp" android:layout_height="wrap_content" android:text="Botton1111111111111111111111111111111" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintWidth_default="spread" app:layout_constraintWidth_percent="0.5"/&gt;&lt;Button android:id="@+id/btn2" android:layout_width="0dp" android:layout_height="wrap_content" android:text="Botton1111111111111111111111111111111" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/btn1" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintWidth_default="wrap" app:layout_constraintWidth_percent="0.5"/&gt; Margins and chains在1.1之后，Chains里面设置margin属性的时候，值是可以叠加的12345678910111213141516171819202122&lt;Button android:id="@+id/btn1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Botton1" app:layout_constraintHorizontal_chainStyle="packed" android:layout_marginEnd="10dp" app:layout_constraintEnd_toStartOf="@+id/btn2" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt;&lt;Button android:id="@+id/btn2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Botton2" android:layout_marginStart="10dp" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_chainStyle="packed" app:layout_constraintStart_toEndOf="@+id/btn1" app:layout_constraintTop_toTopOf="parent"/&gt; BarrierBarrier(屏障)与GuideLine一样，也是属于Virtual Helper objects。先来看看屏障的属性： barrierDirection 屏障对应的方向，值为top、bottom、start、end、left、right。 constraint_referenced_ids 需要控制的控件id，用,隔开，中间不能使用空格，如text1,text2。 barrierAllowsGoneWidgets 当控制的控件被设置为GONE的时候，则屏障创建会在GONE掉控件已解析的位置上进行创建，默认是true。 我们来开这样的一个场景，我们有三个控件，其中两个控件是需要根据不同条件只显示一个控件的，这个时候第三个控件如果要约束那两个控件，只能将那两个控件放到一个新的布局里面，然后第三个控件来约束这个布局。大概的代码是下面那样12345&lt;LinearLayout&gt; &lt;TextView/&gt; &lt;TextView/&gt;&lt;/LinearLayout&gt;&lt;TextView/&gt; 这样操作就不符合约束布局的理念了，所以在1.1引入了屏障Barrier的控件。 12345678910111213141516171819202122232425262728293031&lt;TextView android:id="@+id/text1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView1" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" tools:visibility="gone"/&gt;&lt;TextView android:id="@+id/text2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView2" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/text1"/&gt;&lt;android.support.constraint.Barrier android:id="@+id/barrier" android:layout_width="wrap_content" android:layout_height="wrap_content" app:barrierDirection="bottom" app:constraint_referenced_ids="text1,text2"/&gt;&lt;TextView android:id="@+id/text3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView3" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_otBottomOf="@+id/barrier"/&gt; 然后我们来看一下barrierAllowsGoneWidgets，默认是true，我们来看看下面的布局123456789101112131415161718192021222324252627282930313233343536373839&lt;TextView android:id="@+id/text1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView1" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt;&lt;TextView android:id="@+id/text2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView2" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent"/&gt;&lt;android.support.constraint.Barrier android:id="@+id/barrier" android:layout_width="wrap_content" android:layout_height="wrap_content" app:barrierDirection="bottom" app:constraint_referenced_ids="text1,text2,button"/&gt;&lt;TextView android:id="@+id/text3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView3" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/barrier"/&gt;&lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" tools:layout_editor_absoluteX="120dp" tools:layout_editor_absoluteY="192dp" tools:ignore="MissingConstraints"/&gt; 当我们对Button隐藏的时候，TextView3的位置是这样的 可以看出，默认的屏障是会在GONE的控件创建的位置显示，如果我们把barrierAllowsGoneWidgets属性设置为false会是怎么样的呢？ 结果就是会忽略掉那个GONE的控件。 GroupGroup与Barrier一样，也是属于Virtual Helper objects。顾名思义，Group一个组的控件，通过设置一组的控件id，来达到分组的目的。想想这样的情况，在我们针对多个控件进行显示隐藏的时候，通常要写很多的setVisibility的代码，但是在1.1之后，直接设置Group的显示和隐藏就可以了。 12345678910111213141516171819&lt;TextView android:id="@+id/text1" android:text="TextView1"/&gt;&lt;TextView android:id="@+id/text2" android:text="TextView2"/&gt;&lt;TextView android:id="@+id/text3" android:text="TextView3"/&gt;&lt;TextView android:id="@+id/text4" android:text="TextView4"/&gt;&lt;android.support.constraint.Group android:layout_width="wrap_content" android:layout_height="wrap_content" app:constraint_referenced_ids="text3,text4" tools:visibility="gone"/&gt; 是不是觉得方便了很多，不需要那么多的代码。。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ConstraintLayout</tag>
        <tag>Barrier</tag>
        <tag>Group</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin之DSL的学习]]></title>
    <url>%2F2018%2F02%2F08%2FKotlin_learn_dsl%2F</url>
    <content type="text"><![CDATA[引入当我们在适用函数参数的时候，并且调用，是这样写的： 123 fun notNullFun(block: () -&gt; Unit) &#123; block()&#125; 其实还有一种写法，那就是调用invoke方法： 123 fun notNullFun(block: () -&gt; Unit) &#123; block.invoke()&#125; 在这里看不出有啥区别，但是如果我们在使用一个可空类型的属性时： 12345val nullVal: (() -&gt; Unit)? = nullfun nullFun() &#123; nullVal?.let &#123; it() &#125;&#125; 用invoke就能很简单： 12345val nullVal: (() -&gt; Unit)? = nullfun nullFun() &#123; nullVal?.invoke()&#125; 好，当我们如果要用一个对象的实例来当成函数一样使用的话那么该怎么做了？这就跟上面说的的invoke有关了，通过使用operator关键字，来修饰invoke方法，那么这个对象的实例就能够被当成函数一样调用了： 1234567891011121314data class Person(val name: String, val age: Int) &#123; // operator operator fun invoke(block: (Person) -&gt; Unit) &#123; block(this) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val person = Person("Jowan", 25) person &#123; println(it.toString()) &#125;&#125;// 打印 Person(name=Jowan, age=25) 这，就是我们最简单的DSL了。 下面进入正题。 正文]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>DSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现简单的NDK操作]]></title>
    <url>%2F2018%2F01%2F23%2FAndroid_NDK_OneStep%2F</url>
    <content type="text"><![CDATA[小技巧在这里有个小技巧，在每次创建Cpp方法的时候，都要这样写：1Java_top_jowanxu_jnidemo_MainActivity_stringFromJNI 当你方法多的时候，要改名的时候，就很麻烦了，所以我们可以将前面共有的提取出来，使用宏定义来实现。 首先，创建一个头文件，并且在里面定义宏：1234567// file name package-func-name#ifndef JNIDEMO_PACKAGE_FUNC_NAME_H#define JNIDEMO_PACKAGE_FUNC_NAME_H#define PKFUNC(name) Java_top_jowanxu_jnidemo_##name#endif //JNIDEMO_PACKAGE_FUNC_NAME_H 然后在我们需要使用的时候，先导入头文件，然后使用方法：1234567extern "C"JNIEXPORT jstring JNICALL PKFUNC(MainActivity_stringFromJNI)( JNIEnv *env, jobject thiz) &#123; return env-&gt;NewStringUTF("Hello from JNI !");&#125; 这样就很方便了，在这里感谢李哥提供的帮助。 开始在这里先介绍Java类型对应Jni层数据描述的关系： 基本类型： Java类型 JNI类型 C/C++类型 大小 boolean jboolean unsigned char 无符号 8位 byte jbyte char 有符号 8位 char jchar unsigned short 无符号 16位 short jshort short 有符号 16位 int jint int 有符号 32位 long jlong long long 有符号 64位 float jfloat float 32位 double jdouble double 64位 引用类型： Java类型 JNI类型 void void java.lang.Class jclass java.lang.Throwable jthrowable java.lang.String jclass Object jobject type[] jtypeArray type表示基本类型和Object。 我们来写一个最大公约数的方法，先定义一个方法：1external fun gcd(m: Int, n: Int): Int 然后在Cpp里面创建对应的方法：123456789101112#include "package-func-name.h"extern "C"JNIEXPORT jint JNICALL PKFUNC(MainActivity_gcd)(JNIEnv *env, jobject, jint m, jint n) &#123; jint c; for (; m &gt; 0;) &#123; c = n % m; n = m; m = c; &#125; return n;&#125; 在Cpp里面定义的函数的第一个参数都是JNIEnv *env，这是什么东西呢？JNIEnv就是JNI Environmont，JNI的环境。 再举个例子，当我们用一个引用类型参数的时候，比如一个int数组：1234extern "C"JNIEXPORT jint JNICALL PKFUNC(MainActivity_gcd)(JNIEnv *env, jobject, jintArray _data) &#123;&#125; _data其实是一个指向JVM里面对应该数组的内存的指针，你可以通过它获取数组的元素等操作，但它本身和数组无关，所以你不能对他进行操作。 只能通过JNIEnv指针来获取数组本身的指针，然后进行各种操作。 12345678910111213141516extern "C"JNIEXPORT void JNICALL PKFUNC(MainActivity_getArray)( JNIEnv *env, jobject, jintArray _data) &#123; jint *data = env-&gt;GetIntArrayElements(_data, NULL); for (int i = 0; i &lt; env-&gt;GetArrayLength(_data); ++i) &#123; LOGE("------:%d", data[i]); &#125; env-&gt;ReleaseIntArrayElements(_data, data, JNI_ABORT); // ReleaseIntArrayElements释放资源： // JNI_ABORT表示不复制，释放资源 // JNI_OK表示复制回到JVM中，释放资源 // JNI_COMMIT表示复制，不释放资源&#125; 打印内容：1234E/CUSTOMER_NDK_JNI: ------:1E/CUSTOMER_NDK_JNI: ------:2E/CUSTOMER_NDK_JNI: ------:3E/CUSTOMER_NDK_JNI: ------:4 感谢冰酱的JNI开发：第三章 基本类型数组操作]]></content>
      <categories>
        <category>Native</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Native</tag>
        <tag>CMake</tag>
        <tag>JNI</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象操作]]></title>
    <url>%2F2018%2F01%2F22%2FPython-learn-instance%2F</url>
    <content type="text"><![CDATA[开始类和实例类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响。 在Python中，定义类是通过class关键字：12class Student(object): pass (object)表示该类是从哪个类继承下来的，如果未指定，就使用object类，这是所有类最终都会继承的类。 创建实例：12345678class Student(object): pass# 等同于main函数if __name__ == "__main__": student = Student() print(student) # print &lt;__main__.Student object at 0x000000B7FFB09358&gt; print(Student) # print &lt;class '__main__.Student'&gt; 函数和方法方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据。 使用__init__来创建构造函数：123456789101112131415class Student(object): def __init__(self, name, score): self.name = name self.score = score # 定义一个方法 def say(self, msg): return "%s: %s" % (self.name, msg)if __name__ == "__main__": student = Student("Jowan", 100) print(student.name, student.score, student.say("Hello World!")) # print Jowan 100 Jowan: Hello World! 类里面的所有方法都是以self为第一个参数，就指向创建的实例本身，在调用的时候不需要传入值。 访问限制Python默认属性是无访问限制的，可以自由调用和修改，如果需要设置不被外部访问，需要在开头加上两个下划线_，就变成私有(private)的了：1234567891011class Student(object): def __init__(self, name, score): self.__name = name self.__score = scoreif __name__ == "__main__": student = Student("Jowan", 100) print(student.__name, student.__score) 这时候在外面在调用私有变量，编译器会提示你： 如果还是执意运行的话，就会报错：1AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos; 当我们要访问这个私有变量的时候，需要这样操作，添加对应的get和set方法：123456789101112def get_name(self): return self.__namedef __set_name__(self, name): self.__name = namedef get_score(self): return self.__scoredef set_score(self, score): self.__score = score 其实双下划线开头的实例变量并不是一定不能从外部访问，不能直接访问__name的原因是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：12print(student._Student__name, student._Student__score)# print Jowan 100 继承前面说了(object)表示继承类某个类，如果没有就写object，下面声明一个父类：123456789101112131415161718192021class Animal(object): def run(self): print('Animal is running...')class Dog(Animal): passclass Cat(Animal): passif __name__ == "__main__": dog = Dog() dog.run() # print Animal is running... cat = Cat() cat.run() # print Animal is running... 实例属性与类属性Python包括实例属性和类属性。实例属性是实例绑定属性或者通过self设置，而类属性是这个类的所有实例共享：123456789101112131415161718192021class Student(object): classField = "classField" def __init__(self, name): self.name = nameif __name__ == "__main__": student1 = Student("Student1") print(student1.name) student2 = Student("Student2") print(student2.name) print(student1.classField) print(student2.classField)"""printStudent1Student2classFieldclassField""" 注意：不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性。 获取对象类型type()使用type()来判断对象类型，返回对应的Class类型：1print(type(123)) # &lt;class 'int'&gt; 使用types模块中的常量来判断一个对象是否是一个函数类型：1234type(fn) # types.FunctionTypetype(abs) # types.BuiltinFunctionTypetype(lambda x: x) # types.LambdaTypetype((x for x in range(10))) # types.GeneratorType isinstance()使用isinstance()来判断有继承关系的类型：12345678# object -&gt; Animal -&gt; Dog -&gt; Huskya = Animal()b = Dog()h = Husky()print(isinstance(h, Husky)) # Trueprint(isinstance(h, Dog)) # Trueprint(isinstance(h, Anima)) # Trueprint(isinstance(d, Husky)) # False 基本类型也可以用isinstance来判断：123isinstance('a', str) # Trueisinstance(123, int) # Trueisinstance(b'a', bytes) # True 同时还能多种类型里面判断：12isinstance([1, 2, 3], (list, tuple)) # Trueisinstance((1, 2, 3), (list, tuple)) # True dir()感谢 廖雪峰的Python教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数操作]]></title>
    <url>%2F2018%2F01%2F22%2FPython-learn-function%2F</url>
    <content type="text"><![CDATA[定义函数Python里面的函数没有大括号，通过冒号:开始一个函数，通过缩进来编写函数内容，通过return返回值。 12345def my_abs(x): if x &gt;= 0: return x else: return -x 如果没有写return，也会默认返回结果，默认结果是None。 在写函数指定参数的时候，一般是这样写：12345678def my_abs(x, y, z): if x &gt;= 0: return x else: return -xprint(my_abs(-9, y = 1, z = 2)) 默认参数值：123456def multiply_by(a, b=2): return a * bprint(multiply_by(3, 47)) # print 141print(multiply_by(3)) # print 6 函数的可变参数，使用*：1234def varargs(*args): return args varargs(1, 2, 3) #=&gt; (1,2,3) 同时可以设置可变数量的关键字参数，使用**：12345def keyword_args(**kwargs): return kwargskeyword_args(big="foot", loch="ness")# &#123;"big": "foot", "loch": "ness"&#125; 空函数在python里面可以定义一个函数为空函数，使用pass声明：12def thePasss(): pass 这样就定义了一个空函数，什么也不写，编译器不会报错，可以将代码成功运行，这样做的原因是为了当你在写一个函数的时候，还没想好要怎么写内容，就可放个pass，来先顶顶，不会造成错误。 pass除了能在函数里面使用，还能在其他地方使用，比如在：12if age &gt;= 18: pass]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python读写文件操作]]></title>
    <url>%2F2018%2F01%2F22%2FPython-learn-readAndWriteFile%2F</url>
    <content type="text"><![CDATA[读写文件Python有一些内置函数(如open)来读取和写入文件的信息。 Open函数open函数功能是用来打开一个文件，可以进行读操作和写操作，通过设置函数第二个参数的值来设定文件的访问方式： r表示以读取模式打开 rb表示读取二进制文件 w表示以写入模式打开 wb表示写入二进制文件 a表示以追加模式打开。 open函数返回的对象是文件对象，在使用过后记得关闭(close)。 读取文件通过设置open函数的第二个参数为r，来进行读取文件：1234# 打开一个文件f = open("input.txt", "r")# 关闭文件f.close() input.txt内容为：12I am a temporary file.Maybe someday, I&apos;ll become a real file. 由于IO操作可能会产生IOError，所以我们可以将close操作放在finally里面：12345try: f = open("input.txt", "r")finally: if f: f.close() Python引入了with语句来自动帮我们调用close()方法：12with open("input.txt", "r") as f: print(f.read()) read()调用该方法可以一次读取文件的全部内容，当然如果你一个文件过大的话，可以反复调用read(size)方法，每次最多读取size个字节的内容：123456789101112131415161718f = open("input.txt", "r")# 读取全部内容print(f.read())"""print:I am a temporary file.Maybe someday, I'll become a real file."""# 读取部分内容print(f.read(32))"""print:I am a temporary file.Maybe som"""f.close() readline()调用该方法可以每次读取一行文件的内容：123456789with open("input.txt", "r") as f: print(f.readline())"""print:I am a temporary file.""" reallines()调用该方法可以一次读取所有内容并按行返回个数组：123456789101112with open("input.txt", "r") as f: for line in f.readlines(): print(line)"""print:I am a temporary file.Maybe someday, I'll become a real file.""" 写入文件通过设置open函数的第二个参数为w或者a，来进行写入文件。 w是写入，如果该文件不存在则先创建该文件，再写入，如果已存在该文件，则先删除，再创建，然后写入。 a是追加，如果该文件不存在则先创建该文件，再写入，如果已存在该文件，则在文件后面追加写入。 由于当我们写文件时，不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法后，才会将数据全部写入磁盘。 write()所以使用with语句，确保及时写入数据：123with open("output.txt", "r") as f: f.write("write\n") 其中，output.txt内容为：1This is output file. writelines()写入文件同样可以将数组写进文件：123with open("output.txt", "r") as f: f.writelines(["1\n", "2\n", "3\n"]) 最后文件内容：12345This is output file.write123 读写二进制文件通过设置open函数的第二个参数为rb或者wb，来进行读写二进制文件，如图片，视频等等，读取的内容都是十六进制表示的字节。 读取一张图片：1234with open("timg.jpg", "rb") as f: for line in f.readlines(): print(line) 打印的内容为（省略了一些）：1234b&apos;\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00C\x00\t\x06\x07\x08\x07\x06\t\x08\x07\x08\n&apos;b&apos;\n&apos;b&apos;\t\x0b\r... 字符编码一般文件的编码都是UTF-8，但是如果是其他编码的文件，那么需要在open函数的第三个参数设置encoding编码类型：12345# gbkTxt.txt 内容为 测试with open("gbkTxt.txt", "r", encoding="gbk") as f: print(f.read())# print 测试 如果一个文件里面的存在非法编码的字符，那么就会产生UnicodeDecodeError，如何处理这种情况呢？ open函数提供了一个errors参数，来进行遇到编码错误后的处理，最简单的方式是直接忽略：12with open('test.txt', 'r', encoding='gbk', errors='ignore') as f: ... 总结Python进行文件读写操作还是很方便的，最主要的就是要记住打开文件后，要记得关闭文件操作close，通常使用with操作来自动关闭；在遇到编码不一样的时候要设置对应的编码，同时可以忽略编码错误的操作，读取二进制文件的操作也是很简单。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Read</tag>
        <tag>Write</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin的JobCancellationException操作]]></title>
    <url>%2F2018%2F01%2F19%2FKotlin_learn_jobCancellationException%2F</url>
    <content type="text"><![CDATA[在使用协程(Deferred)请求网络的时候，往往会加取消请求的操作，在这里就用到了协程的取消cancel()。 但是，但是在使用cancel()取消的时候，会报JobCancellationException异常，是正常取消协程的异常，所以我们需要这样做： 123456789101112fun Deferred&lt;Any&gt;?.cancelByActive() = this?.run &#123; try &#123; if (isActive) &#123; cancel() &#125; &#125; catch (_: JobCancellationException) &#123; &#125; catch (e: Exception) &#123; e.printStackTrace() &#125;&#125; 不能单独写一个catch (e: Exception)，需要另外catch异常JobCancellationException。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Coroutines</tag>
        <tag>Cancel</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习笔记]]></title>
    <url>%2F2018%2F01%2F17%2FPython_learn_article%2F</url>
    <content type="text"><![CDATA[注释 单行注释# 多行注释&#39;&#39;&#39; &#39;&#39;&#39;或者&quot;&quot;&quot; &quot;&quot;&quot; 获取变量类型使用type函数来获取变量的类型：12345number = 9print(type(number)) # print &lt;class 'int'&gt;float_number = 9.0print(type(float_number)) # print &lt;class 'float'&gt; **强转python强转通过函数来强转，如：12345float_number = 9.0print(float_number)print(int(float_number)) # 强转为intprint(str(float_number)) # 强转为字符串print(float(float_number)) # 强转为float 次方Python提供次方操作符**：12number = 9.0print(number ** 3) # print 81.0 链式比较Python链式比较同时进行，如下面的：123456one = 1two = 2three = 3# 等同于 one &lt; two 和 two &lt; three 同时进行比较print(one &lt; two &lt; three) # print True 索引下标负值Python的索引下标可以是负值，从最后一个开始计数，从-1开始：123long_string = "This is a very long string!"exclamation = long_string[-1]print(exclamation) # print ! slicing 通过[start:end]来切割字符串：12345monty_python = "Monty Python"monty = monty_python[:5] # monty_python[:5] is equal to monty_python[0:5]print(monty) # print Montypython = monty_python[6:] # print(python) # print Python 同时也能切割数组1234squares = [1, 4, 9, 16, 25] # create new listprint(squares) # print [1, 4, 9, 16, 25]print(squares[1:-1]) # print [4, 9, 16] 字符串格式化在Python中，采用的格式化方式和C语言是一致的，用%实现：1234name = "Jowan"print("Hello, PyCharm! My name is %s!" % name) # print Hello, PyCharm! My name is Jowan!years = 25print("I'm %d years old" % years) # print I'm 25 years old 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 格式化整数和浮点数还可以指定是否补0和整数与小数的位数：12print('%2d-%02d' % (3, 1)) # print 3-01print('%.2f' % 3.1415926) # print 3.14 另一种格式化的方法：1234567# formatprint("&#123;0&#125; can be &#123;1&#125;".format("strings", "formatted"))# print strings can be formatted# 或者自定义print("&#123;name&#125; can be &#123;food&#125;".format(food="lasagna", name="Bob"))# print Bob can be lasagna 数组增删改通过append函数添加一个item，通过+=添加多个：1234567animals = ['elephant', 'lion', 'tiger', "giraffe"] # create new listanimals += ["monkey", 'dog'] # add two itemsprint(animals) # print ['elephant', 'lion', 'tiger', 'giraffe', 'monkey', 'dog']animals.append("dino") # addprint(animals) # print ['elephant', 'lion', 'tiger', 'giraffe', 'monkey', 'dog', 'dino'] 数组的item替换：12345animals = ['elephant', 'lion', 'tiger', "giraffe", "monkey", 'dog']animals[1:3] = ['cat'] # replace 2 itemsprint(animals) # print ['elephant', 'cat', 'giraffe', 'monkey', 'dog']animals[0] = 'lion'print(animals) # print ['lion', 'monkey', 'dog'] 通过remove函数删除item，或者直接替换删除：1234567animals = ['elephant', 'lion', 'tiger', "giraffe", "monkey", 'dog'] # create new listanimals[1:3] = ['cat'] # replace 2 itemsprint(animals) # print ['elephant', 'cat', 'giraffe', 'monkey', 'dog']animals[1:3] = [] # remove 2 itemsprint(animals) # print ['elephant', 'monkey', 'dog'] 通过clear函数清空数组内容：1animals.clear() tuple元祖元组与列表几乎相同，元组和列表之间唯一的重要区别是元组不能被改变：你不能从元组中添加，改变或者删除元素。元组由括号内的逗号运算符构成：12alphabet = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z') 单个项目元组必须有一个尾随逗号：12alphabet = ('b', )beta = ('d', ) dictPython的dict(dictionary)类似与Map，使用key-value存储。1234567891011# create new dictionary.phone_book = &#123;"John": 123, "Jane": 234, "Jerard": 345&#125; print(phone_book) # print &#123;'John': 123, 'Jane': 234, 'Jerard': 345&#125;# 添加phone_book["Jill"] = 345print(phone_book) # print &#123;'John': 123, 'Jane': 234, 'Jerard': 345, 'Jill': 345&#125;# 删除del phone_book['John']print(phone_book) # print &#123;'John': 123, 'Jane': 234, 'Jerard': 345, 'Jill': 345&#125; 或者键值对对应值：12345678910111213141516phone_book = &#123;"John": 123, "Jane": 234, "Jerard": 345&#125;print(phone_book.keys()) # print dict_keys(['John', 'Jane', 'Jerard', 'Jill'])print(phone_book.values()) # print keys = phone_book.keys() # print dict_values([123, 234, 345, 456])for key in keys: print(phone_book[key])"""print123234345456""" 布尔操作Python的或||用or表示，和&amp;&amp;用and表示：123456name = "John"age = 17print(name == "John" or age == 17) # print Trueprint(name == "John" and age == 23) # print False Python的布尔操作不是按顺序的，而是is和not先执行，or再执行，and是最后执行的：12345678name = "John"age = 17print(name == "John" or not age &gt; 17) # print Trueprint(name == "Ellis" or not age &gt; 17) # print Trueprint(name is "Ellis" or not (name == "John" and age == 17)) # print False 条件判断Python的条件判断是没有括号的，通过冒号:开始，代码块缩进：12345678age = 20if age &gt;= 6: print('teenager')elif age &gt;= 18: print('adult')else: print('kid')# 打印teenager if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else if语句的完整形式就是：12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; for循环123# for each number i in range 0-4. for i in range(5): # range(5) function returns list [0, 1, 2, 3, 4] print(i) 用于字符串：1234hello_world = "Hello, World!"for ch in hello_world: # print each character from hello_world print(ch) while循环12345678square = 1# 当square小于或等于10的时候循环while square &lt;= 10: print(square) square += 1 print("Finished") # This code is executed once break和continuebreak12345678count = 0while True: print(count) count += 1 if count &gt;= 5: break# print 0, 1, 2, 3, 4 continue1234for i in range(5): if i == 3: continue print(i) # print 0, 1, 2, 4 try/except使用try/except代码块来处理异常：12345try: # 使用 raise 来抛出一个错误 raise IndexError("This is an index error")except IndexError as e: pass 感谢 廖雪峰的Python教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Try</tag>
        <tag>Except</tag>
        <tag>Tuple</tag>
        <tag>Dict</tag>
        <tag>Pass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实现流的读取的方案]]></title>
    <url>%2F2018%2F01%2F17%2FKotlin_learn_streamRead%2F</url>
    <content type="text"><![CDATA[在Java对流的读取是下面的那样，当前不要忘记流的关闭close。 1234567// java 代码void someFunc(InputStream in, OutputStream out) throws IOException &#123; int read; while ((read = in.read()) != -1) &#123; out.write(read); &#125;&#125; 但是在kotlin中等式不是一个表达式，所以不能那样子写，kotlin是这样的使用的，有几种写法：在使用流或者数据库之类的资源需要关闭close的情况下，可以使用use扩展函数来实现自动关闭的操作 第一种写法，文艺青年：通过闭包返回来实现1234567891011121314fun someFunc(`in`: InputStream, output: OutputStream) &#123; try &#123; var read: Int = -1 `in`.use &#123; input -&gt; output.use &#123; while (&#123; read = input.read();read &#125;() != -1) &#123; it.write(read) &#125; &#125; &#125; &#125; catch (t: Throwable) &#123; t.printStackTrace() &#125;&#125; 第二种写法，二逼青年： 通过正常写法来实现123456789101112131415fun someFunc(`in`: InputStream, output: OutputStream) &#123; try &#123; var read: Int = `in`.read() `in`.use &#123; input -&gt; output.use &#123; while (read != -1) &#123; it.write(read) read = input.read() &#125; &#125; &#125; &#125; catch (t: Throwable) &#123; t.printStackTrace() &#125;&#125; 第三种写法，优秀青年： 通过使用also扩展函数来实现1234567891011121314fun someFunc(`in`: InputStream, output: OutputStream) &#123; try &#123; var read: Int = -1 `in`.use &#123; input -&gt; output.use &#123; while (input.read().also &#123; read = it &#125; != -1) &#123; it.write(read) &#125; &#125; &#125; &#125; catch (t: Throwable) &#123; t.printStackTrace() &#125;&#125; 我们来看一下also函数是什么样的： also函数，传入一个拉姆达并且调用，拉姆达的参数是调用also的实例，然后返回实例，很好理解，就是哪个调用的就返回哪个，并且将它传入拉姆达里面。 举个栗子：123456789data class User(val name: String, val age: Int)fun getMain() &#123; val userOut = User("jowan", 25) println(userOut.also &#123; println("also---$it") // 这里的it表示什么，同时打印什么 &#125;) // 这里会打印什么&#125; 打印什么应该猜到了吧！！ 以上代码参考了萌雀julao的博客，如有疑问，请各种方式私聊我。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探CMake开发NDK]]></title>
    <url>%2F2018%2F01%2F16%2FAndroid_CMake_NDK%2F</url>
    <content type="text"><![CDATA[事前准备打开Android Studio-&gt;Setting-&gt;Android SDK，下载安装CMake、LLDB、NDK。 在新建项目的时候默认会配置好所有的环境，如果是旧的项目需要以下准备：在gradle.properties文件中添加对过时的NDK的兼容使用1android.useDeprecatedNdk=true 在模块的build.gradle里面添加1234567891011121314android &#123; defaultConfig &#123; externalNativeBuild &#123; cmake &#123; cppFlags "" &#125; &#125; &#125; externalNativeBuild &#123; cmake &#123; path "CMakeLists.txt" &#125; &#125;&#125; CMakeLists文件 CMakeLists.txt是CMake的配置文件，用于表明版本、依赖、等信息，文件位置在app/CMakeLists.txt。123456789101112131415161718192021222324252627# 设置构建本地库所需的最小版本的cbuild。cmake_minimum_required(VERSION 3.4.1)# 创建并命名一个库，将其设置为静态# 或者共享，并提供其源代码的相对路径。# 您可以定义多个库，而cbuild为您构建它们。# Gradle自动将共享库与你的APK打包。add_library( hello-lib #设置库的名称。即SO文件的名称，生产的so文件为“libhello-lib.so”,在加载的时候“System.loadLibrary(&quot;hello-lib&quot;);” SHARED # 将库设置为共享库。 src/main/jni/hello.cpp # 提供一个源文件的相对路径 src/main/jni/helloJni.cpp # 提供同一个SO文件中的另一个源文件的相对路径 )#搜索指定的预构建库，并将该路径存储为一个变量。因为cbuild默认包含了搜索路径中的系统库，所以您只需要指定您想要添加的公共NDK库的名称。cbuild在完成构建之前验证这个库是否存在。find_library(log-lib # 设置path变量的名称。 log # 指定NDK库的名称 你想让CMake来定位。 )#指定库的库应该链接到你的目标库。您可以链接多个库，比如在这个构建脚本中定义的库、预构建的第三方库或系统库。target_link_libraries( hello-lib #指定目标库中。与 add_library的库名称一定要相同 $&#123;log-lib&#125; # 将目标库链接到日志库包含在NDK。 )#如果需要生产多个SO文件的话，写法如下add_library( natave-lib #设置库的名称。另一个so文件的名称 SHARED # 将库设置为共享库。 src/main/jni/nataveJni.cpp # 提供一个源文件的相对路径 )target_link_libraries( natave-lib #指定目标库中。与 add_library的库名称一定要相同 $&#123;log-lib&#125; # 将目标库链接到日志库包含在NDK。 ) Cpp文件下面的代码是默认生成的：1234567JNIEXPORT jstring JNICALLJava_com_glee_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) &#123; std::string hello = "Hello from C++"; return env-&gt;NewStringUTF(hello.c_str());&#125; JNIEXPORT &amp; JNICALLJNIEXPORT和JNICALL这两个宏（被定义在jni.h）确保这个函数在本地库外可见，并且编译器会进行正确的调用转换。函数规范在JNI中C/C++的函数名是有规范要求的，由以下几部分串接而成 Java_前缀 完全限定的类名，并用下划线_作为分隔符 第一参数JNIEnv* env 第二个参数jobject或jclass 其他参数按类型映射 返回参数按类型映射 操作这里的操作都是新的项目中操作，如果是旧项目，在相对应的创建相对应的文件。 编写Native方法下面来写几个Native方法，由于我们是使用kotlin代码，所以将native关键字替换为external。 external将一个声明标记为不是在Kotlin中实现（通过JNI访问或者在JavaScript中实现） 12external fun oneJniStr(): Stringexternal fun helloJniStr(): String 编写Cpp函数在Java文件中，CMake可以一键生成Cpp函数： 如果是kotlin文件，那么在native-lib.cpp文件里面添加下面代码：12345678910111213extern "C"JNIEXPORT jstring JNICALLJava_top_jowanxu_jnitest_MainActivity_oneJniStr(JNIEnv *env, jobject instance) &#123; return env-&gt;NewStringUTF("oneJniStr1");&#125;extern "C"JNIEXPORT jstring JNICALLJava_top_jowanxu_jnitest_MainActivity_helloJniStr(JNIEnv *env, jobject instance) &#123; return env-&gt;NewStringUTF("helloJniStr1");&#125; 因为extern &quot;C&quot;的作用是告诉编译器以C方式编译。 调用然后在Activit中调用对应方法：1234sample_text.text = stringFromJNI()fab.setOnClickListener &#123; sample_text.text = ("$&#123;oneJniStr()&#125;------$&#123;helloJniStr()&#125;")&#125; 结果： 设置生成的平台在defaultConfig里面添加需要生成的平台：1234ndk &#123; abiFilters 'x86', 'x86_64', 'armeabi', 'armeabi-v7a', 'arm64-v8a'&#125; 总结使用CMake来写JNI还是特别方便的，比起以前的mk来编写，还是简单了好多，并且CMake支持一键生成native方法，支持在C语言中有代码提示，如果在C中写错了会有错误提示，支持在C中打断点进行debug。 感谢 【NDK】Android Studio2.2+使用CMake依赖多个第三方库 Android Studio配置CMake开发NDK]]></content>
      <categories>
        <category>Native</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Native</tag>
        <tag>CMake</tag>
        <tag>JNI</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout中Chains和Guideline的使用]]></title>
    <url>%2F2018%2F01%2F15%2FAndroid-ConstraintLayout-Chains%2F</url>
    <content type="text"><![CDATA[前面介绍了如何使用ConstraintLayout，在用ConstraintLayout的时候千万要运行一下，在手机上看看结果，因为有时候在AS上面看是没问题的，但是运行到手机上面还是会又不一样的效果的。然后本文将来介绍ConstraintLayout中的Chain也就是链条，还有ConstraintLayout辅助线Guideline的使用。 Chains链条是什么？简单说就是一条链将同一轴（水平或者垂直）上面给连接起来，使他们能够统一行动。 在了解链条之前，我们来写一个栗子，来见识下链条的作用和强大的功能，下面的布局是好几个不同的Tab组成的，每一行的Tab都是一个链条，每一行都是不同的style： 下面是实现的代码（省略了一些属性）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!-- weight chain --&gt;&lt;TextView android:id="@+id/weightStart" android:layout_width="0dp" app:layout_constraintHorizontal_weight="1" /&gt;&lt;TextView android:id="@+id/weightCenter" android:layout_width="0dp" app:layout_constraintHorizontal_weight="2" /&gt;&lt;TextView android:id="@+id/weightEnd" android:layout_width="0dp" app:layout_constraintHorizontal_weight="2" /&gt;&lt;!-- spread chain--&gt;&lt;TextView android:id="@+id/spreadStart" app:layout_constraintBottom_toTopOf="@id/weightStart" app:layout_constraintEnd_toStartOf="@id/spreadCenter" app:layout_constraintStart_toStartOf="parent" /&gt;&lt;TextView android:id="@+id/spreadCenter" /&gt;&lt;TextView android:id="@+id/spreadEnd" /&gt;&lt;!-- packed chain --&gt;&lt;TextView android:id="@+id/packedStart" app:layout_constraintHorizontal_chainStyle="packed" /&gt;&lt;TextView android:id="@+id/packedCenter" /&gt;&lt;TextView android:id="@+id/packedEnd" /&gt;&lt;!-- spread_inside chain --&gt;&lt;TextView android:id="@+id/insideStart" app:layout_constraintHorizontal_chainStyle="spread_inside" /&gt;&lt;TextView android:id="@+id/insideCenter"/&gt;&lt;TextView android:id="@+id/insideEnd" /&gt;&lt;!-- packed chain with bias --&gt;&lt;TextView android:id="@+id/packedBiasStart" app:layout_constraintHorizontal_bias="0.2" app:layout_constraintHorizontal_chainStyle="packed" /&gt;&lt;TextView android:id="@+id/packedBiasCenter" /&gt;&lt;TextView android:id="@+id/packedBiasEnd" /&gt; 可以看出，有五种不同的操作，而且每一行都是设置第一个控件的属性，然后每一行都是不同的显示，下面我们进入正题。。 Creating a chain如何创建一个链条，当两个控件双向链接的时候，如下图所示，A和B里面的两条链，加上A和B两个控件，叫做一个链条。 下面的代码就是将两个按钮链接在一起，成为一个chain(省略一些属性)：1234567891011&lt;Button android:id="@+id/upload" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toStartOf="@id/discard" app:layout_constraintStart_toStartOf="parent" /&gt;&lt;Button android:id="@+id/discard" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toEndOf="@id/upload" /&gt; Chain heads 什么是链头，一个链条里面的第一个元素即为头，水平最左边，垂直最上边的控件，链头的作用是控制整个链条的属性，如上面的A控件就是链头。 Margins in chains在链头上面设置margin，整个链条都会响应这个margin，比如设置链头的一个左边android:layout_marginStart=&quot;10dp&quot;，这整个链条都会响应这个margin： Chain Style 链条可以设置不同的style，通过设置下面两个属性分别设置水平或者垂直： layout_constraintHorizontal_chainStyle layout_constraintVertical_chainStyle 而style包括三种： spread(默认)-元素被分散开 spread_inside-与spread类似，只是链条的端点不会被分散 packed-链条内的元素将被捆在一起 同时还有两种组合，在链条里面，可以使用weight和bias： spread + weight-将元素的尺寸设置为MATCH_CONSTRAINT时，可以与weight平分空间 packed + bias- 前面说过bias是偏重的意思，这里就是将链条集体偏重。 在文章一开始，我们就写好了包含的所有的style，不明白的可以往上面重新看，至于省略的代码，写一下就出来了。 GuidelineGuideline是只能用在ConstraintLayout布局里面的一个工具类，用于辅助布局，类似为辅助线，可以设置android:orientation属性来确定是横向的还是纵向的。 当设置为vertical的时候，Guideline的宽度为0，高度是parent也就是ConstraintLayout的高度 同样设置为horizontal的时候，高度为0，宽度是parent的宽度 重要的是Guideline是不会显示到界面上的，默认是GONE的。 Guideline还有三个重要的属性，每个Guideline只能指定其中一个： layout_constraintGuide_begin，指定左侧或顶部的固定距离，如100dp，在距离左侧或者顶部100dp的位置会出现一条辅助线 layout_constraintGuide_end，指定右侧或底部的固定距离，如30dp，在距离右侧或底部30dp的位置会出现一条辅助线 layout_constraintGuide_percent，指定在父控件中的宽度或高度的百分比，如0.8，表示距离顶部或者左侧的80%的距离。 通过一个栗子便能理解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;android.support.constraint.Guideline android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/guidelineBegin" app:layout_constraintGuide_begin="100dp" android:orientation="vertical"/&gt;&lt;Button android:text="Button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/button" app:layout_constraintLeft_toLeftOf="@+id/guidelineBegin" android:layout_marginTop="16dp" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;android.support.constraint.Guideline android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/guidelineEnd" app:layout_constraintGuide_end="100dp" android:orientation="vertical"/&gt;&lt;Button android:text="Button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/buttonEnd" app:layout_constraintRight_toLeftOf="@+id/guidelineEnd" android:layout_marginTop="48dp" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;android.support.constraint.Guideline android:id="@+id/guidelinePercent" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_percent="0.8" /&gt;&lt;Button android:text="Button3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/buttonPercent" app:layout_constraintLeft_toLeftOf="@+id/guidelinePercent" android:layout_marginTop="96dp" app:layout_constraintTop_toTopOf="parent" /&gt; 预览： 当你要用一个控件占屏幕宽度的一半的时候，可以用layout_constraintGuide_percent，如下面代码：1234567891011121314151617&lt;android.support.constraint.Guideline android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/guidelineBegin" app:layout_constraintGuide_percent="0.5" app:layout_constraintStart_toStartOf="@id/button" android:orientation="vertical"/&gt;&lt;Button android:text="Button" android:layout_width="0dp" android:layout_height="wrap_content" android:id="@+id/button" app:layout_constraintStart_toStartOf="parent" app:layout_constraintEnd_toStartOf="@+id/guidelineBegin" android:layout_marginTop="16dp" app:layout_constraintTop_toTopOf="parent" /&gt; 效果图： 是不是很简单呢！！！ 总结链条能够很好的帮助我们将几个控件统一管理，同时Guideline能帮我们辅助布局，而不用添加一个其他的View并且设置GONE，Guideline都帮我们实现了。 感谢 ConstraintLayout/Chains Guideline ConstraintLayout 完全解析 快来优化你的布局吧 ConstraintLayout 属性详解 和Chain的使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ConstraintLayout</tag>
        <tag>Chains</tag>
        <tag>Guideline</tag>
        <tag>Spread</tag>
        <tag>Spread_inside</tag>
        <tag>Packed</tag>
        <tag>Bias</tag>
        <tag>Weight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout的使用]]></title>
    <url>%2F2018%2F01%2F14%2FAndroid_ConstraintLayout%2F</url>
    <content type="text"><![CDATA[ConstraintLayout是谷歌推出的一个新布局，字面意思是约束布局，距离发布已经有一段时间了，下面会有一个复杂布局的代码对比。对于ConstraintLayout，有篇文章写了关于它的性能优势： 解析ConstraintLayout的性能优势 我们知道，当我们的布局越来越复杂的时候，所使用的嵌套就越来多，性能自然而然的就会有所下降，而ConstraintLayout恰恰就是为了这个操作而诞生的。 对于ConstraintLayout的可视化操作可以说是非常牛逼啊，参考ConstraintLayout完全解析，但是我个人不习惯用可视化的去拖拽控件，所以在这里来写在xml上面写各种属性。 事前准备引入ConstraintLayout在Android Studio 2.3以后，默认创建的布局就是ConstraintLayout布局，如果不是2.3以后的版本，在build.gradle文件中引入ConstraintLayout，当前版本是1.0.2： 12345dependencies &#123; compile 'com.android.support.constraint:constraint-layout:1.0.2' // 3.0以前使用compile，3.0以后使用implementation // implementation 'com.android.support.constraint:constraint-layout:1.0.2'&#125; 转换成ConstraintLayout如果你需要将原来的布局转成ConstraintLayout布局的话，可以在打开xml文件后，点击Design选项，然后找到Component Tree窗口，最后右键布局，选择Convert layout to ConstraintLayout选项 对比布局代码下面我们来通过一个布局，来对比ConstraintLayout和其他布局来实现下面的布局内容的代码： 首先有除了ConstraintLayout之外的布局来实现，代码太长，所以省去属性，有能力的可以自己去写一下：123456789101112131415161718192021222324&lt;RelativeLayout&gt; &lt;ImageView /&gt; &lt;FloatingActionButton /&gt; &lt;RelativeLayout&gt; &lt;TextView /&gt; &lt;LinearLayout&gt; &lt;TextView /&gt; &lt;RelativeLayout&gt; &lt;EditText /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout&gt; &lt;TextView /&gt; &lt;RelativeLayout&gt; &lt;EditText /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;TextView /&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout &gt; &lt;Button /&gt; &lt;Button /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 够复杂的，RelativeLayout布局嵌套LinearLayout布局，里面又嵌套多个布局，严重影响布局的绘制。那么我们来看使用ConstraintLayout布局之后的代码是怎么样的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="top.jowanxu.constraintlayoutdemo.MainActivity"&gt; &lt;ImageView android:id="@+id/banner" android:layout_width="0dp" android:layout_height="0dp" android:background="@color/colorAccent" android:gravity="center" app:layout_constraintDimensionRatio="16:6" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="@dimen/fab_margin" app:layout_constraintBottom_toBottomOf="@+id/banner" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.98" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/banner" app:srcCompat="@android:drawable/ic_dialog_email" /&gt; &lt;TextView android:id="@+id/title" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:layout_marginTop="10dp" android:text="Singapore" android:textAppearance="@style/Base.TextAppearance.AppCompat.Title" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/banner" /&gt; &lt;TextView android:id="@+id/camera" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:layout_marginTop="10dp" android:padding="10dp" android:text="Camera" android:textAppearance="@style/TextAppearance.AppCompat.Tooltip" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/title" /&gt; &lt;EditText android:id="@+id/cameraEdit" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginEnd="10dp" android:hint="Leica M Typ 240" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toEndOf="@+id/camera" app:layout_constraintTop_toTopOf="@+id/camera" /&gt; &lt;TextView android:id="@+id/settings" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:layout_marginTop="10dp" android:padding="10dp" android:text="Settings" android:textAppearance="@style/TextAppearance.AppCompat.Tooltip" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/cameraEdit" /&gt; &lt;EditText android:id="@+id/settingsEdit" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginEnd="10dp" android:hint="f/4 16s ISO 200" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toEndOf="@+id/settings" app:layout_constraintTop_toTopOf="@+id/settings" /&gt; &lt;TextView android:id="@+id/content" android:layout_width="0dp" android:layout_height="0dp" android:layout_margin="10dp" android:layout_marginBottom="8dp" android:layout_marginEnd="8dp" android:layout_marginStart="8dp" android:text="Singapore offically the Republic of Singapore.Singapore offically the Republic of Singapore.Singapore offically the Republic of Singapore.Singapore offically the Republic of Singapore.Singapore offically the Republic of Singapore." android:textAppearance="@style/Base.TextAppearance.AppCompat.Body1" app:layout_constraintBottom_toTopOf="@+id/discard" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/settingsEdit" /&gt; &lt;Button android:id="@+id/upload" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="UPLOAD" app:layout_constraintBottom_toBottomOf="@+id/discard" app:layout_constraintEnd_toStartOf="@+id/discard" /&gt; &lt;Button android:id="@+id/discard" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="10dp" android:layout_marginEnd="10dp" android:text="DISCARD" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 简单概括就是，没有一层嵌套，而且是一个完全扁平的层次结构：123456789101112&lt;ConstraintLayout&gt; &lt;ImageView/&gt; &lt;FloatingActionButton/&gt; &lt;TextView/&gt; &lt;TextView/&gt; &lt;EditText/&gt; &lt;TextView/&gt; &lt;EditText/&gt; &lt;TextView/&gt; &lt;Button/&gt; &lt;Button/&gt;&lt;/ConstraintLayout&gt; 开始ConstraintLayout所包含的约束有： Dimension constraints Relative positioning Centering positioning Margins Visibility behavior Chains Dimensions constraintsDimensions constraints字面意思就是尺寸约束，可以设置ConstraintLayout布局的大小，和设置布局里面控件的尺寸约束。 Minimum dimensions on ConstraintLayoutConstraintLayout布局与其他布局一样可以设置最大尺寸和最小尺寸： android:minWidth android:minHeight android:maxWidth android:maxHeight Widgets dimension constraints 设置布局里面控件的尺寸约束，我们知道，在普通布局里面，我们每个控件的宽高，都是在三个类型里面设置值的： 固定的值(如100dp)，对应图上a wrap_content，对应图上a match_parent，对应图上b，设置margin对应c 但是在ConstraintLayout布局里面，控件的宽高变为： 固定的值(如100dp)，对应图上a wrap_content，对应图上a match_constraint，也就是0dp，对应图上b，设置margin对应c 与其他布局不同的是ConstraintLayout里面没有match_parent，而是用0dp也就是match_constraint替换了他，看下官网怎么说的： Important: MATCH_PARENT is not recommended for widgets contained in a ConstraintLayout. Similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”. 意思是，ConstraintLayout已经弃用MATCH_PARENT了，通过使用MATCH_CONSTRAINT，同时设置控件的left/right或者top/bottom来约束parent来达到与MATCH_PARENT一样的效果，如：123android:layout_width="0dp"app:layout_constraintEnd_toEndOf="parent"app:layout_constraintStart_toStartOf="parent" 下面举个栗子,将RelativeLayout和ConstraintLayout写一下下面的布局 RelativeLayout里面12345678910111213141516&lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentStart="true" android:layout_alignParentTop="true" android:text="Button" /&gt;&lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentTop="true" android:layout_toEndOf="@+id/button" android:layout_alignParentEnd="true" android:text="asdfasdfsdfasdfasdfasdfasdfasdfsadfsdafasdfasdfasdf" /&gt; 然后ConstraintLayout布局12345678910111213141516&lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button1" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="asdfasdfsdfasdfasdfasdfasdfasdfsadfsdafasdfasdfasdf" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toEndOf="@+id/button1" app:layout_constraintTop_toTopOf="parent" /&gt; 为什么会出现这样的情况呢，跟我们预期的不一样，当一个控件的两边都有约束的时候，会将这个控件居中，当这个控件宽度或者高度特别大的时候（超出屏幕），则会将左右两边超出的距离相同，上面说了，要达到MATCH_PARENT效果，需要将尺寸设置为MATCH_CONSTRAINT也就是0dp，我们来看一下结果： RadioConstraintLayout里面可以设置控件的比例，对应宽高比width:height，属性为： layout_constraintDimensionRatio 如果我们要把上面的16:6这样的写出来，那么我们先要将左右的约束设置成parent，同时设置宽高为MATCH_CONSTRAINT，然后设置layout_constraintDimensionRatio为16:6：123456789&lt;Button android:id="@+id/button1" android:layout_width="0dp" android:layout_height="0dp" android:layout_marginTop="8dp" android:text="Button1" app:layout_constraintDimensionRatio="16:6" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" /&gt; 而在LinearLayout上设置却要这样写：12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:weightSum="22"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="6" android:text="Button" /&gt;&lt;/LinearLayout&gt; 对比下，差别还是很明显的，ConstraintLayout用起来还是非常舒服的。 当然，还支持单方向的比例，相对应的方向的尺寸设置为MATCH_CONSTRAINT：1234&lt;!-- 宽度比例，对应的宽度即为200dp --&gt;android:layout_width="0dp"android:layout_height="100dp"app:layout_constraintDimensionRatio="W,2:1" 1234&lt;!-- 高度比例，对应的高度即为100dp --&gt;android:layout_width="200dp"android:layout_height="0dp"app:layout_constraintDimensionRatio="H,2:1" Relative positioningRelative positioning字面意思是相对定位，这个的属性类似与相对布局(RelativeLayout)的属性，属性的值包括parent和控件的id如@+id/button，包含： layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf 通过上面我们可以看出，这里的属性是layout_constraintXX_toYYOf的，这里的XX和YY分别表示什么样的方向？我们先来通过一个方向的属性来了解，其他以此类推：layout_constraintStart_toStartOf、layout_constraintStart_toEndOf和layout_constraintEnd_toStartOf、layout_constraintEnd_toEndOf123456789101112131415161718192021222324252627282930313233&lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button1" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button2" app:layout_constraintStart_toEndOf="@+id/button1" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;Button android:id="@+id/button3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button3" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;Button android:id="@+id/button4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button4" app:layout_constraintEnd_toStartOf="@+id/button3" app:layout_constraintStart_toEndOf="@+id/button2" app:layout_constraintTop_toTopOf="parent" /&gt; 我们来看预览图： 从上面看出，layout_constraintXX_toYYOf属性的XX表示当前控件的位置，YY则表示需要约束的控件的位置，下面是一个控件的各边表示： Centering positioning and bias 字面意思就是居中定位，当我们在相对布局到时候，如果要居中一个控件的时候123456&lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerHorizontal="true" android:text="Button" /&gt; 在ConstraintLayout里面，可以这样将控件居中123456&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="button" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent"/&gt; 预览图都是显示居中 因为在ConstraintLayout里面，每个约束都是类似于在对应方向上，有相反的力 去拉控件，而在这里，则会水平居中显示。 bias上面说到每个约束都是一个拉力，而bias则表示这个拉力在两边的偏重，对应横向竖向偏重： layout_constraintHorizontal_bias layout_constraintVertical_bias 同样用上面的栗子，加入app:layout_constraintHorizontal_bias=&quot;0.9&quot;属性，对应左边拉力偏重90%，右边拉力偏重10%： MarginsConstraintLayout里面的margin与普通的属性一样，只是值不能为负数。 Note that a margin can only be positive or equals to zero, and takes a Dimension. Margins when connected to a GONE widget设置一个控件为GONE时的margin值，下面是包含的属性： layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom 举个栗子：12345678910111213141516171819&lt;!-- 省去一些代码 --&gt;&lt;Button android:id="@+id/button1" app:layout_constraintStart_toStartOf="parent" /&gt;&lt;Button android:id="@+id/button2" android:layout_marginStart="60dp" app:layout_constraintStart_toEndOf="@+id/button1" app:layout_goneMarginStart="160dp" /&gt;&lt;Button android:id="@+id/button3" app:layout_constraintStart_toStartOf="@+id/button1" app:layout_constraintTop_toBottomOf="@+id/button2" /&gt;&lt;Button android:id="@+id/button4" android:layout_marginStart="60dp" app:layout_constraintStart_toEndOf="@+id/button3" app:layout_constraintTop_toBottomOf="@+id/button2" app:layout_goneMarginStart="160dp" /&gt; 预览图： 当我们将button3的设置为GONE的时候，结果为： 对比可以看出： 当设置了goneMargin属性时候，约束的控件如果不是GONE的时候，则不会生效； 当goneMargin属性和margin属性同时存在的时候，margin属性不会生效。 Visibility behavior字面意思是可见性行为，当一个控件设置为GONE的时候，在布局计算的时候仍会加进去，在布局过程中，将被解析成一个点，所有的margin也将为0，但是对于其他控件的约束仍然存在。 如果我们需要上面的图，在A被隐藏后，仍然保持B的位置不变，那么我们就要设置B的goneMargin的值为A的宽度和margin与B的margin值的和，也就是goneMarginStart = A.width + A.marginStart + B.marginStart 1234567891011121314151617181920&lt;!-- 示例代码 --&gt; &lt;Button android:id="@+id/button1" android:layout_width="100dp" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:text="Button1" android:visibility="gone" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="100dp" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:text="Button2" app:layout_constraintStart_toEndOf="@+id/button1" app:layout_constraintTop_toTopOf="parent" app:layout_goneMarginStart="120dp" /&gt; 总结ConstraintLayout比传统布局的性能更出色，而且ConstraintLayout对于一些复杂的布局具有天然的优势，所以还没有使用ConstraintLayout的同学，赶紧加入到里面来吧，ConstraintLayout还有一些内容将在下一篇文章介绍(Chain和Guideline)。 参考 ConstraintLayout 属性详解 和Chain的使用 ConstraintLayout 完全解析 快来优化你的布局吧 developer.android.google/ConstraintLayout 谷歌ConstraintLayoutExamples]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ConstraintLayout</tag>
        <tag>Bias</tag>
        <tag>GoneMargin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_请勿将kotlin声明为属性]]></title>
    <url>%2F2017%2F12%2F01%2FKotlin_learn_kotlinNameError%2F</url>
    <content type="text"><![CDATA[误将属性的名写成kotlin造成的错误。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Field</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_协程（Coroutines）的使用]]></title>
    <url>%2F2017%2F11%2F30%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Some APIs initiate long-running operations (such as network IO, file IO, CPU- or GPU-intensive work, etc) and require the caller to block until they complete. Coroutines provide a way to avoid blocking a thread and replace it with a cheaper and more controllable operation: suspension of a coroutine.Coroutines simplify asynchronous programming by putting the complications into libraries. The logic of the program can be expressed sequentially in a coroutine, and the underlying library will figure out the asynchrony for us. The library can wrap relevant parts of the user code into callbacks, subscribe to relevant events, schedule execution on different threads (or even different machines!), and the code remains as simple as if it was sequentially executed. 协程提供了一种避免阻塞线程并用更廉价、更可控的操作替代线程阻塞的方法：协程挂起。协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器！）上调度执行，而代码则保持如同顺序执行一样简单。 协程的官方使用说明 自己写了个请求网络的协程demo 123456789// Your first coroutineprivate fun oneCoroutine() &#123; launch &#123; // launch new coroutine delay(1000L) // non-blocking delay for 1 second (default time unit is ms) println("World!") // print after delay &#125; println("Hello,") // main function continues while coroutine is delayed Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive&#125; 1234567891011// Bridging blocking and non-blocking worldsprivate fun twoCoroutine() = runBlocking&lt;Unit&gt; &#123; // start main coroutine launch &#123; // launch new coroutine delay(1000L) println("World!") &#125; println("Hello,") // main coroutine continues while child is delayed delay(2000L) // non-blocking delay for 2 seconds to keep JVM alive&#125; 1234567891011// Waiting for a jobprivate fun threeCoroutine() = runBlocking &#123; val job = launch &#123; // launch new coroutine and keep a reference to its Job delay(1000L) println("World!") &#125; println("Hello,") job.join() // wait until child coroutine completes&#125; 123456789101112// Extract function refactoringprivate fun fourCoroutine() = runBlocking &#123; val job = launch &#123; doWorld() &#125; "Hello,".println() job.join()&#125;// this is your first suspending functionsuspend fun doWorld() &#123; delay(1000L) println("World!")&#125; 1234567891011// Coroutines ARE light-weightprivate fun fiveCoroutine() = runBlocking&lt;Unit&gt; &#123; val jobs = List(10) &#123; // launch a lot of coroutines and list their jobs launch &#123; print("$&#123;it&#125;___") delay(1000L) print("$it.") &#125; &#125; jobs.forEach &#123; it.join() &#125; // wait for all jobs to complete&#125; 1234567891011// Coroutine are like daemon threadsprivate fun sixCoroutine() = runBlocking &#123; launch &#123; repeat(1000) &#123; "I'm sleeping $it ...".println() delay(500L) &#125; &#125; delay(10_000L)&#125; 1234567891011121314// Cancelling coroutine executionprivate fun cancelCoroutine() = runBlocking &#123; val job = launch &#123; repeat(1000) &#123; "I'm sleeping $it ...".println() delay(500L) &#125; &#125; delay(1300L) // delay a bit println("main: I'm tired of waiting!") job.cancelAndJoin() println("main: Now I can quit.")&#125; 1234567891011121314151617181920// Cancellation is cooperativeprivate fun cancellationCoroutine() = runBlocking &#123; val startTime = System.currentTimeMillis() val job = launch &#123; var nextPrintTime = startTime var i = 0 while (i &lt; 5) &#123; // computation loop, just wastes CPU // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) &#123; println("I'm sleeping $&#123;i++&#125; ...") nextPrintTime += 500L &#125; &#125; &#125; delay(1400L) // delay a bit println("main: I'm tired of waiting!") job.cancelAndJoin() // cancels the job and waits for its completion println("main: Now I can quit.")&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin_属性自动生成方法所引发问题]]></title>
    <url>%2F2017%2F11%2F29%2FKotlin_%E5%B1%9E%E6%80%A7%E5%BC%95%E5%8F%91%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Kotlin中创建一个属性，如果是val，那么会自动生成getter方法，如果是var，那么会自动生成getter和setter方法。 1234class MethodFoo() &#123; var a: Int = 1 var b: Int = 2&#125; 生成的class内容1234567891011121314151617181920public final class MethodFoo &#123; private int a = 1; private int b = 2; public final int getA() &#123; return this.a; &#125; public final void setA(int var1) &#123; this.a = var1; &#125; public final int getB() &#123; return this.b; &#125; public final void setB(int var1) &#123; this.b = var1; &#125;&#125; 自动生成get和set在开发的时候，经常会用到一些常量，而常量一般放在一个公共的类里面，在Kotlin中，我们是这样写的：123456789101112object Constant &#123; val ACTION_FINDVIEWBYID = "FindViewById" val ACTION_BUTTERKNIFE = "ButterKnife" val SELECTED_TEXT_SUFFIX = ".xml" val PSI_METHOD_BY_ONCREATE = "onCreate" val PSI_METHOD_BY_ONCREATEVIEW = "onCreateView" val CREATOR_COMMAND_NAME = "Generate Injections" val CLASS_TYPE_BY_ACTIVITY = "activity" val CLASS_TYPE_BY_FRAGMENT = "fragment" val FIELD_ON_CLICK = "OnClick" val FIELD_ONCLICK = "onClick"&#125; 生成的代码是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public final class Constant &#123; @NotNull private static final String ACTION_FINDVIEWBYID = "FindViewById"; @NotNull private static final String ACTION_BUTTERKNIFE = "ButterKnife"; @NotNull private static final String SELECTED_TEXT_SUFFIX = ".xml"; @NotNull private static final String PSI_METHOD_BY_ONCREATE = "onCreate"; @NotNull private static final String PSI_METHOD_BY_ONCREATEVIEW = "onCreateView"; @NotNull private static final String CREATOR_COMMAND_NAME = "Generate Injections"; @NotNull private static final String CLASS_TYPE_BY_ACTIVITY = "activity"; @NotNull private static final String CLASS_TYPE_BY_FRAGMENT = "fragment"; @NotNull private static final String FIELD_ON_CLICK = "OnClick"; @NotNull private static final String FIELD_ONCLICK = "onClick"; public static final Constant INSTANCE; @NotNull public final String getACTION_FINDVIEWBYID() &#123; return ACTION_FINDVIEWBYID; &#125; @NotNull public final String getACTION_BUTTERKNIFE() &#123; return ACTION_BUTTERKNIFE; &#125; @NotNull public final String getSELECTED_TEXT_SUFFIX() &#123; return SELECTED_TEXT_SUFFIX; &#125; @NotNull public final String getPSI_METHOD_BY_ONCREATE() &#123; return PSI_METHOD_BY_ONCREATE; &#125; @NotNull public final String getPSI_METHOD_BY_ONCREATEVIEW() &#123; return PSI_METHOD_BY_ONCREATEVIEW; &#125; @NotNull public final String getCREATOR_COMMAND_NAME() &#123; return CREATOR_COMMAND_NAME; &#125; @NotNull public final String getCLASS_TYPE_BY_ACTIVITY() &#123; return CLASS_TYPE_BY_ACTIVITY; &#125; @NotNull public final String getCLASS_TYPE_BY_FRAGMENT() &#123; return CLASS_TYPE_BY_FRAGMENT; &#125; @NotNull public final String getFIELD_ON_CLICK() &#123; return FIELD_ON_CLICK; &#125; @NotNull public final String getFIELD_ONCLICK() &#123; return FIELD_ONCLICK; &#125; private Constant() &#123; INSTANCE = (Constant)this; ACTION_FINDVIEWBYID = "FindViewById"; ACTION_BUTTERKNIFE = "ButterKnife"; SELECTED_TEXT_SUFFIX = ".xml"; PSI_METHOD_BY_ONCREATE = "onCreate"; PSI_METHOD_BY_ONCREATEVIEW = "onCreateView"; CREATOR_COMMAND_NAME = "Generate Injections"; CLASS_TYPE_BY_ACTIVITY = "activity"; CLASS_TYPE_BY_FRAGMENT = "fragment"; FIELD_ON_CLICK = "OnClick"; FIELD_ONCLICK = "onClick"; &#125; static &#123; new Constant(); &#125;&#125; 这….生成了那么多的get方法，如果我有100个字段，那么就多生成了100个get方法，我只是想要Constant.fieldName这样子调用这个字段而已，根本不需要用到get，这样明显是创建了多余的方法，方法数增多容易报65535错。 如何避免生成在Kotlin中，可以使用两种方法来停止自动生成get和set方法。 使用const关键字123456789101112object Constant &#123; const val ACTION_FINDVIEWBYID = "FindViewById" const val ACTION_BUTTERKNIFE = "ButterKnife" const val SELECTED_TEXT_SUFFIX = ".xml" const val PSI_METHOD_BY_ONCREATE = "onCreate" const val PSI_METHOD_BY_ONCREATEVIEW = "onCreateView" const val CREATOR_COMMAND_NAME = "Generate Injections" const val CLASS_TYPE_BY_ACTIVITY = "activity" const val CLASS_TYPE_BY_FRAGMENT = "fragment" const val FIELD_ON_CLICK = "OnClick" const val FIELD_ONCLICK = "onClick"&#125; 来看一下编译后的内容12345678910111213141516171819202122232425262728293031public final class Constant &#123; @NotNull public static final String ACTION_FINDVIEWBYID = "FindViewById"; @NotNull public static final String ACTION_BUTTERKNIFE = "ButterKnife"; @NotNull public static final String SELECTED_TEXT_SUFFIX = ".xml"; @NotNull public static final String PSI_METHOD_BY_ONCREATE = "onCreate"; @NotNull public static final String PSI_METHOD_BY_ONCREATEVIEW = "onCreateView"; @NotNull public static final String CREATOR_COMMAND_NAME = "Generate Injections"; @NotNull public static final String CLASS_TYPE_BY_ACTIVITY = "activity"; @NotNull public static final String CLASS_TYPE_BY_FRAGMENT = "fragment"; @NotNull public static final String FIELD_ON_CLICK = "OnClick"; @NotNull public static final String FIELD_ONCLICK = "onClick"; public static final Constant INSTANCE; private Constant() &#123; INSTANCE = (Constant)this; &#125; static &#123; new Constant(); &#125;&#125; 使用@JvmField注解123456789101112object Constant &#123; @JvmField val ACTION_FINDVIEWBYID = "FindViewById" @JvmField val ACTION_BUTTERKNIFE = "ButterKnife" @JvmField val SELECTED_TEXT_SUFFIX = ".xml" @JvmField val PSI_METHOD_BY_ONCREATE = "onCreate" @JvmField val PSI_METHOD_BY_ONCREATEVIEW = "onCreateView" @JvmField val CREATOR_COMMAND_NAME = "Generate Injections" @JvmField val CLASS_TYPE_BY_ACTIVITY = "activity" @JvmField val CLASS_TYPE_BY_FRAGMENT = "fragment" @JvmField val FIELD_ON_CLICK = "OnClick" @JvmField val FIELD_ONCLICK = "onClick"&#125; 来看一下编译后的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class Constant &#123; @JvmField @NotNull public static final String ACTION_FINDVIEWBYID = "FindViewById"; @JvmField @NotNull public static final String ACTION_BUTTERKNIFE = "ButterKnife"; @JvmField @NotNull public static final String SELECTED_TEXT_SUFFIX = ".xml"; @JvmField @NotNull public static final String PSI_METHOD_BY_ONCREATE = "onCreate"; @JvmField @NotNull public static final String PSI_METHOD_BY_ONCREATEVIEW = "onCreateView"; @JvmField @NotNull public static final String CREATOR_COMMAND_NAME = "Generate Injections"; @JvmField @NotNull public static final String CLASS_TYPE_BY_ACTIVITY = "activity"; @JvmField @NotNull public static final String CLASS_TYPE_BY_FRAGMENT = "fragment"; @JvmField @NotNull public static final String FIELD_ON_CLICK = "OnClick"; @JvmField @NotNull public static final String FIELD_ONCLICK = "onClick"; public static final Constant INSTANCE; private Constant() &#123; INSTANCE = (Constant)this; ACTION_FINDVIEWBYID = "FindViewById"; ACTION_BUTTERKNIFE = "ButterKnife"; SELECTED_TEXT_SUFFIX = ".xml"; PSI_METHOD_BY_ONCREATE = "onCreate"; PSI_METHOD_BY_ONCREATEVIEW = "onCreateView"; CREATOR_COMMAND_NAME = "Generate Injections"; CLASS_TYPE_BY_ACTIVITY = "activity"; CLASS_TYPE_BY_FRAGMENT = "fragment"; FIELD_ON_CLICK = "OnClick"; FIELD_ONCLICK = "onClick"; &#125; static &#123; new Constant(); &#125;&#125; 后记当我们使用Kotlin定义大量的公共字段的时候，一定要这样写来避免方法数过多。 感谢Kotlin属性引发的方法数问题。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Method</tag>
        <tag>Property</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_when的一个小功能]]></title>
    <url>%2F2017%2F11%2F22%2FKotlin_learn_when2Or%2F</url>
    <content type="text"><![CDATA[使用when来通过智能转换替换OR。 在网上看到一个问题是说有两个方法，同名不同参数123456fun foo(long: Long) &#123; // doSomething&#125;fun foo(int: Int) &#123; // doSomething&#125; 然后现在有个变量是未定类型val someValue: Any = &quot;0&quot; // 0 or 0L，在使用foo方法的时候，然后他是这样写的，问说如何智能转换，不要使用||。 12345678if (someValue is Int || someValue is Long) &#123; foo(someValue)&#125;// 或者这样if (someValue is Int) foo(someValue)else if (someValue is Long) foo(someValue) 使用when来替代它1234when (someValue) &#123; is Long -&gt; foo(someValue) is Int -&gt; foo(someValue)&#125; 这样就体现了Kotlin的智能转换功能了]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>When</tag>
        <tag>OR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_委托模式（Delegate）和委托属性（Delegate Properties）]]></title>
    <url>%2F2017%2F11%2F22%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[委托模式已经被证明是实现继承的一个很好的替代方式，在扩展一个基类并且重写方法时，基类就必须依赖子类的实现，当不断地修改的时候，基类就会失去当初的性质，Kotlin中就将类默认为final，确保不会被修改。 有一种模式是装饰器模式，本质就是创建一个新类，实现与基类一样的接口，并且将类的实现作为一个字段保存，这样就能在基类不被修改就能直接修改基类的实例。但是这样的缺点是会造成很多的样板代码。 1234567891011121314class DelegatingCollection&lt;T&gt; : Collection&lt;T&gt; &#123; private val innerList = mutableListOf&lt;T&gt;() override val size: Int get() = innerList.size override fun contains(element: T): Boolean = innerList.contains(element) override fun containsAll(elements: Collection&lt;T&gt;): Boolean = innerList.addAll(elements) override fun isEmpty(): Boolean = innerList.isEmpty() override fun iterator(): Iterator&lt;T&gt; = innerList.iterator()&#125; 当你实现Collection接口的时候，需要重写这几个方法，这里面的代码量是很多的，但是如果用了委托，那么代码就是这样的 1class DelegatingCollection2&lt;T&gt;(innerList: Collection&lt;T&gt; = mutableListOf&lt;T&gt;()) : Collection&lt;T&gt; by innerList 这么简单？就能实现那几个方法？我们来看一下生成的代码 是不是省去了很多手写的代码量，下面我们来介绍这种属性。 委托模式(Delegate)Kotlin支持委托模式，是允许对象组合实现与继承相同的代码复用的，简单来说就是操作的对象不用自己去执行，而是将任务交给另一个对象操作，这样的模式就叫委托模式，被操作的对象叫委托。 委托模式是有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。 类委托同样我们用上面集合的栗子，现在我们已经是委托到一个对象了，如果我们要修改集合里面的方法的时候，可以直接重写，而不用重复的去写新的方法，下面我们来在一个集合里面插入数据，并且获取插入的次数。 下面代码是默认实现MutableCollection接口，获取插入的次数1234567891011121314151617181920212223242526272829303132333435class DefaultCollection&lt;T&gt; : MutableCollection&lt;T&gt; &#123; private val innerList = mutableListOf&lt;T&gt;() private var addedSum = 0 override fun add(element: T): Boolean &#123; addedSum++ return innerList.add(element) &#125; override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; addedSum += elements.size return innerList.addAll(elements) &#125; override val size: Int get() = innerList.size override fun contains(element: T): Boolean = innerList.contains(element) override fun containsAll(elements: Collection&lt;T&gt;): Boolean = innerList.addAll(elements) override fun isEmpty(): Boolean = innerList.isEmpty() override fun iterator(): MutableIterator&lt;T&gt; = innerList.iterator() override fun clear() = innerList.clear() override fun remove(element: T): Boolean = innerList.remove(element) override fun removeAll(elements: Collection&lt;T&gt;): Boolean = innerList.removeAll(elements) override fun retainAll(elements: Collection&lt;T&gt;): Boolean &#123; TODO("not implemented") //To change body of created functions use File | Settings | File Templates. &#125;&#125; 实现类委托12345678910111213class DelegatingCollection3&lt;T&gt;(private val innerList: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerList &#123; private var addedSum = 0 override fun add(element: T): Boolean &#123; addedSum++ return innerList.add(element) &#125; override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; addedSum += elements.size return innerList.addAll(elements) &#125;&#125; 是不是省去很多无用的代码，只需要重写我们需要的方法add和addAll，其他没有写出来的方法全部都交给委托来实现。 而且没有对底层集合的实现方法引入任何的依赖，所以对被调用的操作具有完全的控制，如不用担心集合是不是通过循环中调用add来实现addAll。 委托属性(Delegate Properties)有一种属性，在使用的时候每次都要手动实现它，但是可以做到只实现一次，并且放到库中，一直使用，这种属性称为委托属性。委托属性包括： 延迟属性(lazy properties)：数据只在第一次被访问的时候计算。 可观察属性(observable properties)：监听得到属性变化通知。 Map委托属性(Storing Properties in a Map)：将所有属性存在Map中。 123class Foo &#123; var p: String by Delegate()&#125; 委托模式的语法是val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;在by后面的expression就是委托的部分，会将属性的get()和set()委托给getValue()和setValue()方法。 1234567class Foo &#123; private val delegate = Delegate() var p: String set(value: String) = delegate.setValue(..., value) get() = delegate.getValue(...)&#125; 委托属性不需要实现任何的接口，但是要提供getValue()方法(如果是var的话要提供setValue()方法)，方法前加operator关键字。 下面是一个自定义的Delegate类： 123456789class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return "$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println("$value has been assigned to '$&#123;property.name&#125; in $thisRef.'") &#125;&#125; 当从委托属性p获取到Deletage的的实例时，Deletage的getValue就会被调用，getValue函数中的第一个参数就是p获取到的实例，第二个参数就是属性p。 12val e = Example()println(e.p) 打印出来的内容是： 1Example@33a17727, thank you for delegating ‘p’ to me! 由于p是var类型的，所有可以调用setValue函数，前两个参数与getValue参数一样，第三个就是要赋予的值： 1e.p = "NEW" 这下打印出来的内容就是： 1NEW has been assigned to ‘p’ in Example@33a17727. 注意：自 Kotlin1.1起可以在函数或代码块中声明一个委托属性，因此委托属性不一定是类的成员 委托标准Kotlin的标准库中对于一些有用的委托提供了工厂(Factory)方法，这些接口在Kotlin标准库中声明。12345678interface ReadOnlyProperty&lt;in R, out T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T&#125;interface ReadWriteProperty&lt;in R, T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)&#125; 延迟属性 Lazy 函数lazy()接收一个Lambdas表达式，然后并返回一个Lazy &lt;T&gt;的实例，它可以作为实现lazy属性的委托：第一次调用get()函数的时候会向执行Lambdas传递到lazy()函数，并且保存结果，后面调用的get()函数会直接返回报错的结果。 首先我们来看一个栗子，里面先不用到lazy，我们来看如何12345678910111213141516171819202122232425262728293031323334fun loadName(person: Person): String &#123; println("Load Name for $&#123;person.name&#125;") return person.name&#125;fun loadAge(person: Person): Int &#123; println("Load Age for $&#123;person.age&#125;") return person.age&#125;class Person(val name: String, val age: Int) &#123; private var _names: String? = null val newName: String get() &#123; if (_names == null) &#123; _names = loadName(this) &#125; return _names!! &#125; private var _ages: Int? = null val newAge: Int get() &#123; if (_ages == null) &#123; _ages = loadAge(this) &#125; return _ages!! &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person("Alice", 23) p.newName.println() p.newName.println()&#125; 首先先判断_names是否为空，然后通过一个方法，里面进行了一些操作，来赋予_names值，最后newName的值即为_names。打印的内容： 那么如果我们用lazy来代替这种写法会是什么样的呢？ 1234567891011121314fun loadName(person: Person): String &#123; /*代码与上面一样*/&#125;fun loadAge(person: Person): Int &#123; /*代码与上面一样*/&#125;class Person(val name: String) &#123; val newName by lazy &#123; loadName(this) &#125; val newAge by lazy &#123; loadAge(this) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; /*代码与上面一样*/&#125; 打印出来的内容，和上面是一模一样的。 对比一下，当我们的属性越来越多，那么重复的代码也就越来越多，使用lazy省去了很多多余的代码。 默认地，对于lazy属性的计算是加了同步锁（synchronized） 的： 这个值只在一个线程被计算，并且所有的线程会看到相同的值。如果要将同步锁关闭，可以多个线程同步执行，就加LazyThreadSafetyMode.PUBLICATION参数即可： 1234val lazyValue: String by lazy(LazyThreadSafetyMode.PUBLICATION) &#123; println("computed!") "Hello"&#125; 如果要关掉线程安全配置，就加LazyThreadSafetyMode.NONE参数即可：1234val lazyValue: String by lazy(LazyThreadSafetyMode.NONE) &#123; println("computed!") "Hello"&#125; 可观察属性 ObservableDelegates.observable()有两个参数：初始化值和handler，每次对属性赋值操作，都会回调该handler方法（在属性赋值后执行），该方法里面有三个参数，分别是：被赋值的属性，旧值和新值。举个例子：1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable("&lt;no name&gt;") &#123; prop, old, new -&gt; println("$old -&gt; $new") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = "first" user.name = "second"&#125; 在User类中，&lt;no name&gt;就是初始化值，{}包住的代码块就是handler方法，pro, old, new就是该方法的三个参数，打印出来的内容为：12&lt;no name&gt; -&gt; firstfirst -&gt; second 如果需要拦截修改属性值动作并禁止修改，可以使用vetoable()取代observable()，handler需要返回一个Boolean，true表示同意修改，false表示禁止修改，该回调会在属性值修改前调用。将上面的例子里面的observable()修改为vetoable()后：123456789101112131415import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.vetoable("&lt;no name&gt;") &#123; prop, old, new -&gt; println("$old -&gt; $new") false &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = "first" user.name = "second"&#125; 打印的结果是： 如果改为true，那就更observable()打印的一样了： Map委托属性(Storing Properties in a Map)可以用Map作为委托用于委托属性，多用于JSON解析上。 下面举个栗子，一个类里面有一个Map存放一些属性，通过setAttribute来设置这些属性： 1234567891011121314151617181920212223242526class Person &#123; private val _attributes = hashMapOf&lt;String, String&gt;() fun setAttribute(attrName: String, value: String) &#123; _attributes[attrName] = value &#125; // 获取键值为name的值 val name: String get() = _attributes["name"]!! // 获取键值为company的值 val company: String get() = _attributes["company"]!! // 获取键值为address的值 val address: String get() = _attributes["address"]!! // 获取键值为email的值 val email: String get() = _attributes["email"]!!&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person() val data = mapOf("name" to "Dmitry", "company" to "JetBrains") for ((attrName, value) in data) p.setAttribute(attrName, value) println(p.name) // 打印Dmitry&#125; 然后我们将这些属性委托给Map，再将代码简写一下123456789101112class Person2(private val attributes: Map&lt;String, String&gt;) &#123; val name: String by attributes val company: String by attributes val address: String by attributes val email: String by attributes&#125;fun main(args: Array&lt;String&gt;) &#123; val data = mapOf("name" to "Dmitry", "company" to "JetBrains") val p = Person2(data) println(p.name) // Dmitry&#125; 同样对比，省去重复代码，我们来看一下生成的代码是什么样子的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class Person2 &#123; // $FF: synthetic field static final KProperty[] $$delegatedProperties = new KProperty[]&#123;(KProperty)Reflection.property1(new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(Person2.class), "name", "getName()Ljava/lang/String;")), (KProperty)Reflection.property1(new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(Person2.class), "company", "getCompany()Ljava/lang/String;")), (KProperty)Reflection.property1(new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(Person2.class), "address", "getAddress()Ljava/lang/String;")), (KProperty)Reflection.property1(new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(Person2.class), "email", "getEmail()Ljava/lang/String;"))&#125;; @NotNull private final Map name$delegate; @NotNull private final Map company$delegate; @NotNull private final Map address$delegate; @NotNull private final Map email$delegate; private final Map attributes; @NotNull public final String getName() &#123; Map var1 = this.name$delegate; KProperty var3 = $$delegatedProperties[0]; return (String)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName()); &#125; @NotNull public final String getCompany() &#123; Map var1 = this.company$delegate; KProperty var3 = $$delegatedProperties[1]; return (String)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName()); &#125; @NotNull public final String getAddress() &#123; Map var1 = this.address$delegate; KProperty var3 = $$delegatedProperties[2]; return (String)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName()); &#125; @NotNull public final String getEmail() &#123; Map var1 = this.email$delegate; KProperty var3 = $$delegatedProperties[3]; return (String)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName()); &#125; public Person2(@NotNull Map attributes) &#123; Intrinsics.checkParameterIsNotNull(attributes, "attributes"); super(); this.attributes = attributes; this.name$delegate = this.attributes; this.company$delegate = this.attributes; this.address$delegate = this.attributes; this.email$delegate = this.attributes; &#125;&#125; 局部委托属性（1.1 起）123456789101112fun main(args: Array&lt;String&gt;) &#123; example("localDelegate")&#125;fun example(value: String) &#123; val localDelegate by lazy &#123; print("first ") value &#125; localDelegate.println() // 打印first localDelegate localDelegate.println() // 打印localDelegate&#125; 现在，Kotlin支持局部委托属性。 委托属性要求下面的代码是个委托类Delegate，里面有两个函数，一个是getValue函数，一个是setValue函数。 123456789class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return "$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println("$value has been assigned to '$&#123;property.name&#125; in $thisRef.'") &#125;&#125; 只读属性（read-only，使用val定义）委托类需提供getValue函数，参数要求： thisRef：第一个参数，必须是属性对应的类或父类型。(上面的thisRef: Any?) property：第二个参数，必须是“KProperty&lt;&gt;”或它的父类型(上面的`property: KProperty&lt;&gt;`)。 函数返回类型必须跟属性同类型（或者子类型）。 可变属性（mutable，使用var定义）委托类需提供getValue函数和setValue函数，参数要求： thisRef：第一个参数，同getValue对应的参数 property：第二个参数，同getValue对应的参数 新增(new value)：第三个参数，类型必须跟属性一样或其父类型。 getValue() 和setValue()函数可以作为委托类的成员函数或者扩展函数来使用。 当需要委托一个属性给一个不是原来就提供这些函数的对象的时候，后者更为方便。 两种函数都需要用operator关键字修饰。 接口委托类可以实现ReadOnlyPropery和ReadWriteProperty接口中的带operator的方法，这些接口在Kotlin标准库中声明：12345678interface ReadOnlyProperty&lt;in R, out T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T&#125;interface ReadWriteProperty&lt;in R, T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)&#125; 提供委托（自 1.1 起）provideDelegate为提供委托，它可以为属性提供对象委托逻辑，可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。provideDelegate 的参数与 getValue 相同： thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型。 property —— 必须是类型 KProperty&lt;*&gt; 或其超类。 例如，在绑定之前检查属性名称：123456789101112131415class ResourceLoader(resId: ResourceID) &#123; operator fun provideDelegate(thisRef: MyUI, prop: KProperty&lt;*&gt;): ReadOnlyProperty&lt;MyUI, String&gt; &#123; checkProperty(thisRef, prop.name) // 创建委托 &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; &#125;&#125;fun MyUI.bindResource(id: ResourceID): ResourceLoader &#123; return ResourceLoader(id)&#125;class MyUI &#123; val image by bindResource(ResourceID.image_id) //bindResource()产生委托对象 val text by bindResource(ResourceID.text_id)&#125; 在创建 MyUI 实例期间，为每个属性调用provideDelegate方法，并立即执行必要的验证。 如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名：1234567891011class MyUI &#123; val image by bindResource(ResourceID.image_id, "image") val text by bindResource(ResourceID.text_id, "text")&#125;fun &lt;T&gt; MyUI.bindResource( id: ResourceID&lt;T&gt;, propertyName: String ): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(this, propertyName) // 创建委托&#125; 由于暂时没用的这个提供委托，所以在这里也不过多的介绍，上面是官网的一个栗子。 一个委托实例下面来看一个自定义的Delegate，用来访问SharedPreference，这段代码是Kotlin for Android Developer的示例： 123456789101112131415161718192021222324252627282930313233343536class Preference&lt;T&gt;(val context: Context, val name: String, val default: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; val prefs by lazy &#123; context.getSharedPreferences("default", Context.MODE_PRIVATE) &#125; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return findPreference(name, default) &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; putPreference(name, value) &#125; private fun &lt;U&gt; findPreference(name: String, default: U): U = with(prefs) &#123; val res: Any = when (default) &#123; is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException("This type can be saved into Preferences") &#125; res as U &#125; private fun &lt;U&gt; putPreference(name: String, value: U) = with(prefs.edit()) &#123; when (value) &#123; is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException("This type can be saved into Preferences") &#125;.apply() &#125;&#125; 使用的时候： 12345678class ExampleActivity : AppCompatActivity()&#123; var a: Int by Preference(this, "a", 0) fun whatever()&#123; println(a)//会从SharedPreference取这个数据 aInt = 9 //会将这个数据写入SharedPreference &#125;&#125; 这样就很方便了，再也不用去重复写getSharedPreference()、commit()、edit()、apply()之类的东西了。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Delegate</tag>
        <tag>Propertie</tag>
        <tag>Observable</tag>
        <tag>Lazy</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_运算符重载]]></title>
    <url>%2F2017%2F11%2F15%2FKotlin%E5%AD%A6%E4%B9%A0_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在前面写了关于集合和范围的内容，里面包括了一点运算符重载的内容，在这里我们来详细了解运算符重载的知识，内容参考《Kotlin实战》（Kotlin in Action）。 什么是运算符重载？ 简单来说，就是Kotlin通过调用自己代码中定义特定的函数名的函数（成员函数或者扩展函数），并且用operator修饰符标记，来实现特定的语言结构，例如如果你在一个类上面定义了一个特定函数命名plus的函数，那么按照Kotlin的约定，可用在这个类的实例上使用+运算符，下面是代码。 用于重载运算符的所有函数都必须使用operator关键字标记。 123456789101112// 一个简单的数据类data class Foo(val x: Int, val y: Int) &#123; operator fun plus(other: Foo) : Foo = Foo(x + other.x, y + other.y)&#125;fun main(args: Array&lt;String&gt;) &#123; // 使用的时候 val f1 = Foo(10, 20) val f2 = Foo(30, 40) // 直接用+运算符代替plus函数，事实上会调用plus函数 println(f1 + f2) // 打印内容为Foo(x=40, y=60)&#125; 那么Java如何调用运算符函数呢？ 重载的运算符实际上是被定义成一个函数，Java调用Kotlin运算符就跟调用普通函数一样调用就行。 重载算术运算符算术运算符包括二元运算符、复合赋值运算符、一元运算符，当Kotlin在给一个集合添加元素的时候，是调用add方法，用到重载的话，我们就可以直接用+=来进行这个操作，就会显得更加的优雅。。。1234567891011fun Any.println() = println(this)fun main(args: Array&lt;String&gt;) &#123; val list = arrayListOf(1, 2 ,3) list.println() // 打印[1, 2, 3] list.add(4) list.println() // 打印[1, 2, 3, 4] list += 5 list.println() // 打印[1, 2, 3, 4, 5]&#125; 重载二元算术运算符二元算术运算符就是常见的+、-、*、/和取余%，优先级与数学的是一样的，*、/和%要高于+、-的优先级。 下面我们列举对应的函数名： 表达式 函数名 a * b times a / b div a % b rem,mod(弃用) a + b plus a - b minus 下面我们来写个类，里面包含这几种函数，同时还有扩展函数的定义。 123456789101112131415161718192021fun Any.println() = println(this)// Extensionoperator fun Foo.minus(other: Foo): Foo = Foo(x - other.x, y - other.y)operator fun Foo.div(other: Foo): Foo = Foo(x / other.x, y / other.y)data class Foo(val x: Int, val y: Int) &#123; operator fun plus(other: Foo): Foo = Foo(x + other.x, y + other.y) operator fun times(other: Foo): Foo = Foo(x * other.x, y * other.y) operator fun rem(other: Foo): Foo = Foo(x % other.x, y % other.y)&#125;fun main(args: Array&lt;String&gt;) &#123; val f1 = Foo(30, 40) val f2 = Foo(10, 20) (f1 - f2).println() // 打印Foo(x=20, y=20) (f1 + f2).println() // 打印Foo(x=40, y=60) (f1 * f2).println() // 打印Foo(x=300, y=800) (f1 / f2).println() // 打印Foo(x=3, y=2) (f1 % f2).println() // 打印Foo(x=0, y=0)&#125; 除了定义相同类型的运算数之外，还能定义运算数类型不同的运算符：12345678data class Foo(val x: Int, val y: Int) &#123; operator fun times(other: Double): Foo = Foo((x * other).toInt(), (y * other).toInt())&#125;fun main(args: Array&lt;String&gt;) &#123; val f1 = Foo(30, 40) (f1 * 1.5).println() // 打印Foo(x=45, y=60)&#125; 当你通过这样子去调用这个运算符的时候1(1.5 * f1).println() 这时候，编译器会提示你出错了 为什么会这样呢？ 因为Kotlin的运算符不会自动至此交换性（交换运算符的左右两边）。 那要怎么样才能那样写呢？ 需要定义一个单独的运算符1operator fun Double.times(other: Foo): Foo = Foo((this * other.x).toInt(), (this * other.y).toInt()) 这样子就能直接支持运算符两边互换使用了。。。12(f1 * 1.5).println()(1.5 * f1).println() 运算符函数不是单一返回类型的，也是可以定义不同的返回类型，下面举个栗子：12345operator fun Char.times(count: Int): String = toString().repeat(count)fun main(args: Array&lt;String&gt;) &#123; ('a' * 3).println() // 打印aaa&#125; 在上面的代码中，这个运算符是Char类型的扩展函数，参数类型是Int类型，所以是Char * Int这样的操作，返回类型是String。 注意：运算符和普通函数一样，可以重载operator函数，可以定义多个同名，但是参数不一样的方法。 重载复合赋值运算符什么是复合赋值运算符？类似于+=这样的，合并了两部操作的运算符，同时赋值，称为符合运算符。 下面我们列举对应的函数名： 表达式 函数名 a += b timesAssign a /= b divAssign a %= b remAssign a += b plusAssign a -= b minusAssign 12345fun main(args: Array&lt;String&gt;) &#123; var f1 = Foo(1, 2) f1 += Foo(3, 4) f1.println() // 打印Foo(x=4, y=6)&#125; 上面的+=等同于f1 = f1 + Foo(3, 4)，这些操作当然是只对可变变量有效的。 默认情况下，复合赋值运算符是可以修改变量所引用的对象，同时重新分配引用，但是在将一个元素添加到一个可变集合的时候，+=是不会重新分配引用的：12345fun main(args: Array&lt;String&gt;) &#123; val list = mutableListOf&lt;Int&gt;() list += 42 list.println() // 打印[42]&#125; 同样我们可以对复合赋值运算符进行重载，同样可以定义多个同名，但是参数不一样的方法：123456789operator fun MutableCollection&lt;Int&gt;.plusAssign(element: Int) &#123; this.add(element - 1)&#125;fun main(args: Array&lt;String&gt;) &#123; val list = mutableListOf&lt;Int&gt;() list += 42 list.println() // 打印[41]&#125; 如果在plus和plusAssign两个函数同时被定义且适用，那么编译器就会报错，最好在设计新类的时候保持（可变性）一致，尽量不同时定义plus和plusAssign运算。如Foo类是不可变的，那么只提供plus运算，如果一个类是可变的，如构造器，那么只需提供plusAssign和类似的运算就够了。 实际上+=可以被转换为plus或者plusAssign函数调用，而Kotlin的标准库中为集合支持这两种方法。 +和-运算符会返回一个新的集合。 +=和-=用于可变集合，会修改集合，如果是只读，那么就会返回一个修改过的副本，也就是说只有在只读集合被定义为var类型的时候，才能使用+=和-=。 123456789101112131415fun main(args: Array&lt;String&gt;) &#123; // 可变类型 val list = mutableListOf&lt;Int&gt;(1, 2) // += 修改list list += 3 // + 返回一个新的List val newList = list + listOf&lt;Int&gt;(4, 5) // 除了使用单个元素参数，也可使用元素类型相同的集合 list.println() // 打印[1, 2, 3] newList.println() // 打印[1, 2, 3, 4, 5] var varList = listOf&lt;Int&gt;(1, 2) // 只读集合类型为var varList.println() // 打印[1, 2] varList += 3 varList.println() // 打印[1, 2, 3]&#125; 重载一元运算符Kotlin中允许重载一元运算符，如-a,+a等等，同样我们列举支持的一元运算符和对应的函数名： 表达式 函数名 +a unaryPlus -a unaryMinus !a not ++a, a++ inc --a, a-- dec 重载一元运算符过程与前面一样，通过预先定义的一个名称来声明函数（成员函数或者扩展函数），并且用operator修饰符标记。 注意：一元运算符是没有参数的。 12345678data class Foo(val x: Int, val y: Int)operator fun Foo.unaryMinus() = Foo(-x, -y)fun main(args: Array&lt;String&gt;) &#123; val f1 = Foo(1, 2) (-f1).println() // 打印Foo(x=-1, y=-2)&#125; 当重载自增自减运算符符是，编译器自动支持前缀--a和后缀a--语义。1234567operator fun BigDecimal.inc() = this + BigDecimal.ONEfun main(args: Array&lt;String&gt;) &#123; var bd = 0 (bd++).println() // 打印0 (++bd).println() // 打印2&#125; 重载比较运算符比较运算符，可以在除了基本数据类型外的任意对象上使用，当Java中使用equals或compareTo时，在Kotlin中，直接用运算符重载。比较运算符分为等号运算符和排序运算符。 表达式 函数名 a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b) ?: (b === null)) a &gt; b a.compareTo(b) &gt; 0 a &lt; b a.compareTo(b) &lt; 0 a &gt;= b a.compareTo(b) &gt;= 0 a &lt;= b a.compareTo(b) &lt;= 0 等号运算符equals在我们平时使用判断字符串是否与某个字符串相等的时候，会使用equals函数来判断，然而在Kotlin中，我们可以是用==来代替equals函数，~=来代替!qeuals。在Java中如果使用null对象来equals的话，会爆空指针异常，而Kotlin中的==是支持可空类型的，因为会先判断是否为空，如a == b会先检查a是否为空，如果不是，就会调用a.equals(b)，否则只有两个参数都是空值，结果才为真。 下面我们来重载equals运算符123456789101112131415161718data class Foo(val x: Int, val y: Int) &#123; override operator fun equals(other: Any?): Boolean = when &#123; // 使用恒等运算符来判断两个参数是否同一个对象的引用 other === this -&gt; true other !is Foo -&gt; false else -&gt; other.x == x &amp;&amp; other.y == y &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val f1 = Foo(1, 2) val f2 = Foo(1, 2) val f3 = Foo(10, 20) (f1 == f2).println() // true (f1 == f2).println() // true (f1 != f2).println() // false (null == f1).println() // false&#125; 注意：===与Java一样，检查两个参数是否是同一个对象的引用，如果是基本数据类型，检查值是否相同，===和!==不能被重载。 排序运算符compareTo在Java中，基本数据类型集合排序通常都是使用&lt;和&gt;来比较，而其他类型需要使用element1.compareTo(element2)来比较的。而在Kotlin中，通过使用比较运算符(&gt;``&lt;``&gt;=``&lt;=)来进行比较。 比较运算符会被转换成compareTo函数，compareTo的返回类型必须为Int。1234567class Person(private val firstName: String, private val lastName: String) : Comparable&lt;Person&gt; &#123; override fun compareTo(other: Person): Int = compareValuesBy(this, other, Person::lastName, Person::firstName)&#125;fun main(args: Array&lt;String&gt;) &#123; (Person("Alice", "Smith") &lt; Person("Bob", "Johnson")).println() // 打印false&#125; compareValuesBy函数是按顺序依次调用回调方法，两两一组分别做比较，然后返回结果，如果则返回比较结果，如果相同，则继续调用下一个，如果没有更多回调来调用，则返回0。 override标记 从上面可以看到，equals和compareTo都是被override标记的，之所以会被标记，是因为在Any类中已经定义了equals函数，而所有的对象都默认继承Any类，所有才重载的时候需要使用override标记，而且equals不能定义为扩展函数，因为Any类的实现是重要优先于扩展函数。同样，compareTo在Comparable接口中已经定义了，所有在重载的时候，需要使用override标记。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Operator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_关键字与操作符（Keywords and Operators）]]></title>
    <url>%2F2017%2F10%2F30%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Kotlin中有一些常用的关键字和标识符，同时还有一些操作符和特殊符号，这些都是和Java有不一样的地方的，这里将他们介绍一下，方便记忆和回看。 硬关键字(Hard Keywords)Kotlin中的硬关键字不能作为标识符 package与Java一样，Kotlin的源文件同样以包声明开始的。1234567package foo.barfun baz() &#123;&#125;class Goo &#123;&#125;// ... interfaceinterface表示声明一个接口，123456interface MyInterface &#123; fun bar() fun foo() &#123; // 可选的方法体 &#125;&#125; classKotlin的类的声明与Java一样，使用class关键字12class Invoice &#123;&#125; objectobject为同时声明一个类及其实例，请看对象表达式。 super具体内容可看Kotlin学习_类和继承、接口与实现。 引用一个方法或属性的超类实现 12345678910111213open class Foo &#123; open fun f() &#123; println("Foo.f()") &#125; open val x: Int get() = 1&#125;class Bar : Foo() &#123; override fun f() &#123; super.f() println("Bar.f()") &#125; override val x: Int get() = super.x + 1&#125; 在此构造函数中调用超类构造函数 12345class MyView : View &#123; constructor(ctx: Context) : super(ctx) constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)&#125; nullnull是表示不指向任何对象的对象引用的常量。 this引用当前接收者 在次构造函数（二级构造函数）中调用同一个类中的另一个构造函数。 12345678class Person(val name: String) &#123; constructor(name: String, paret: Person) : this(name) &#123; parent.children.add(this) &#125; constructor(name: String, parent: Person, count: Int) : this(name) &#123; parent.children.add(this) &#125;&#125; typealias类型别名为现有类型提供替代名称。如果类型名称太长，您可以引入不同的较短的名称，并使用新的名称。缩短长泛型类型：123typealias NodeSet = Set&lt;Network.Node&gt;typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt; 可以为功能类型提供不同的别名：123typealias MyHandler = (Int, String, Any) -&gt; Unittypealias Predicate&lt;T&gt; = (T) -&gt; Boolean asas是一个中缀操作符。用于类型转换as是不安全的转换操作符，如果as转换失败，会抛出一个异常，这就是不安全的。1val x: String = y as String 上面的代码表示将y强转为String类型，如果y为null，那么将不能转换成String，因为String是不可空的类型，那么就会抛出一个异常，所以如果y的类型是可空类型的话，那么强转的类型就必须是可空的1val x: String? = y as String? 用于指定导入包的别名as除了用于类型转换之外，还有一个作用就是可以指定导入包的别名12import foo.Bar // Bar 可访问import bar.Bar as bBar // bBar 代表“bar.Bar” as?as?与as类似，也是转换操作符，但是与as不同的是，as?是安全的，也就是可空的，可以避免抛出异常，在转换失败是会返回null1val x: String? = y as? String as后面的类型是个可空的类型，而as?后面的类型确实非空类型，但是as?转换的类型却是可空的，这样是主要的区别。 if和else在Kotlin中，if表达式表示返回一个值(true或false)，Kotlin中没有三目运算符。而else与Java定义一样，定义一个if表达式条件为false时执行的分支。1234567891011121314//传统用法var max = aif (a &lt; b) max = b//带 else var max: Intif (a &gt; b) max = aelse max = b//作为表达式val max = if (a &gt; b) a else b true和false指定布尔类型的”真”值和”假”值。 while和dowhile是开始一个while循环(前置条件的循环)，而do为开始一个do/while循环（后置条件的循环），do...while 与Java的一样，有一个区别是，语句块里面的变量在外面是可见的1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) // y 在这是可见的 forfor表示开始一个for循环123for (item: Int in ints) &#123; // ...&#125; whenKotlin中的when就类似与Java的switch，但是与switch不同的是，when在其它分支都不匹配的时候默认匹配 else 分支，如果没有把所有可能和分支条件列出来，那么else是强制的，这与switch的default也有区别。1234567when (x) &#123; 1 -&gt; print("x == 1") 2 -&gt; print("x == 2") else -&gt; &#123; // 默认 print("x is neither 1 nor 2") &#125;&#125; breakbreak用于终止循环的执行,使用break 跳转到标签处，跳出循环1234567loop@ for (i in 1..10) &#123; for (j in i..10) &#123; if (j == 5) break@loop // 跳出循环 Log.e(Tag, j.toString()) // j 为5的时候跳出了循环，只打印1、2、3、4 &#125;&#125; continuecontinue用于跳到最近的闭合循环的下一次循环1234567loop@ for (i in 1..10) &#123; for (j in i..10) &#123; if (j == 5) continue@loop // 跳出本次循环，进行下一次循环 Log.e(Tag, j.toString()) // j 为5的时候跳出了循环，所有不会打印5 &#125;&#125; returnreturn默认从最直接包围它的函数或者匿名函数返回。123456fun foo() &#123; ints.forEach &#123; if (it == 0) return // 跳出forEach print(it) &#125;&#125; funfun表示声明一个函数123fun test() &#123;&#125; in用于指定for循环中迭代的对象1for (item in collection) print(item) 用作中缀操作符以检查一个值属于一个区间、一个集合或者其他定义contains方法的实体。123456if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;if(a in b)&#123; // a in b等同于b.contains(a) println("a in b")&#125; 在when中使用12345when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") else -&gt; print("none of the above")&#125; 将一个类型参数标记为逆变123456789abstract class Comparable&lt;in T&gt; &#123; abstract fun compareTo(other: T): Int&#125;fun demo(x: Comparable&lt;Number&gt;) &#123; x.compareTo(1.0) // 1.0 拥有类型 Double，它是 Number 的子类型 // 因此，我们可以将 x 赋给类型为 Comparable &lt;Double&gt; 的变量 val y: Comparable&lt;Double&gt; = x // OK！&#125; !in!in表示与in相反用作中缀操作符以检查一个值不属于一个区间、一个集合或者其他定义contains方法的实体。123456if (i !in 1..10) &#123; // 表示i不在1到10区间 println(i)&#125;if(a !in b)&#123; // a !in b等同于!b.contains(a) println("a !in b")&#125; 在when中使用12345when (x) &#123; in 1..10 -&gt; print("x is in the range") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125; is和!is是否符合给定类型类似与Java的instanceOf，is操作符或其否定形式!is来检查对象是否符合给定类型：12345678910if (obj is String) &#123; print(obj.length)&#125;if (obj !is String) &#123; // 与 !(obj is String) 相同 print("Not a String")&#125;else &#123; print(obj.length)&#125; 在when表达式中用于判定是否符合1234fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125; throw和trythrow和try与Java定义一样，throw为抛出一个异常，而try为捕获异常。1234567891011throw MyException("Hi There!")try &#123; // 一些代码&#125;catch (e: SomeException) &#123; // 处理程序&#125;finally &#123; // 可选的 finally 块&#125; valval表示声明一个只读属性或局部变量1val name: String = …… varval表示声明一个可变属性或局部变量1var name: String = …… 软关键字(Soft Keywords)以下符号在适用的上下文中充当关键字，而在其他上下文中可用作标识符： import导入一个包里面的类文件1import foo.Bar // 导入foo包里面的Bar by将接口的实现委托给另一个对象1234567891011121314interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) Derived(b).print() // 输出 10&#125; 将属性访问器的实现委托给另一个对象123456789101112class Example &#123; var p: String by Delegate()&#125;class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return "$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println("$value has been assigned to '$&#123;property.name&#125; in $thisRef.'") &#125;&#125; get声明属性的getter12val isEmpty: Boolean get() = this.size == 0 用作注解使用处目标 set声明属性的setter12345var stringRepresentation: String get() = this.toString() set (value) &#123; setDataFormString(value) // 格式化字符串,并且将值重新赋值给其他元素 &#125; 用作注解使用处目标 dynamic引用一个Kotlin/JS代码中的动态类型1val dyn: dynamic = …… catch与Java一样，处理异常123456try &#123; // 一些代码&#125;catch (e: SomeException) &#123; // 处理程序&#125; finally与Java一样，try退出时总会执行的块123456789try &#123; // 一些代码&#125;catch (e: SomeException) &#123; // 处理程序&#125;finally &#123; // 可选的 finally 块&#125; constructor声明一个主构造函数或次构造函数12class Person constructor(firstName: String) &#123;&#125; init主构造函数不能包含任何的代码。初始化的代码可以放到以init关键字作为前缀的初始化块中：12345class Customer(name: String) &#123; init &#123; logger.info("Customer initialized with value $&#123;name&#125;") &#125;&#125; param、setparam、delegate、field、file、property用作注解使用处目标123class Example(@field:Ann val foo, // 标注 Java 字段 @get:Ann val bar, // 标注 Java getter @param:Ann val quux) // 标注 Java 构造函数参数 使用目标(Use-site Targets)支持的有： file property使用此目标的注解对Java不可见 field get 属性的getter set 属性的setter receiver 扩展函数或属性的接收器参数 param 构造函数参数 setparam 属性的setter的参数 delegate 该字段存储代理属性的代理实例 receiverwherewhera用于指定泛型多个类型的上界约束12345fun &lt;T&gt; cloneWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;T&gt; where T : Comparable, T : Cloneable &#123; return list.filter &#123; it &gt; threshold &#125;.map &#123; it.clone() &#125;&#125; 修饰词关键字(Modifier Keywords)out将类型参数标记为协变12345678abstract class Source&lt;out T&gt; &#123; abstract fun nextT(): T&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs // 这个没问题，因为 T 是一个 out-参数 // ……&#125; annotationannotation表示声明一个注解类1annotation class Fancy companioncompanion表示声明一个伴生对象12345class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125; constconst表示将属性标记为编译期常量，可用于注解当中123const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() &#123; …… &#125; externalexternal表示将一个声明标记为不是在 Kotlin 中实现（通过JNI访问或者在 JavaScript中实现）1234567891011121314151617// JNIexternal fun foo(x: Int): Double// JavaScriptexternal fun alert(message: Any?): Unitexternal class Node &#123; val firstChild: Node fun append(child: Node): Node fun removeChild(child: Node): Node // 等等&#125;external val window: Window inline声明一个函数为内联函数123inline fun lock&lt;T&gt;(lock: Lock, body: () -&gt; T): T &#123; // ……&#125; crossinlinecrossinline表示禁止传递给内联函数的lambda中的非局部返回123456inline fun f(crossinline body: () -&gt; Unit) &#123; val f = object: Runnable &#123; override fun run() = body() &#125; // ……&#125; noinlinenoinline表示一个内联函数如果只有一些被内联，另外的不想内联，可以将函数禁用内联：123inline fun &lt;T&gt; T.one (inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) &#123;&#125; 如果一个内联函数没有可内联的函数参数并且没有具体化类型参数，则会产生一个禁告，因为这样的内联函数没有什么用处。 finalfinal为禁止成员覆盖。123open class AnotherDerived() : Base() &#123; final override fun v() &#123;&#125; // v方法不可被重写&#125; open允许一个类子类化或覆盖成员，open与final相反，它允许其他类从这个类继承，默认情况下，在Kotlin中所有的类都是final123open class Base(p: Int)class Derived(p: Int) : Base(p) data声明一个类为数据类1data class User(val name: String, val age: Int) abstract与Java一样，abstract将一个类或成员标记为抽象1234567open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; enum声明一个枚举类12345enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125; inner声明一个内部类，允许在嵌套类中引用外部类实例12345678class Outer &#123; private val bar: Int = 1 inner class Inner &#123; fun foo() = bar &#125;&#125;val demo = Outer().Inner().foo() // == 1 sealed声明一个密封类（限制子类化的类）1234sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() lateinit延迟初始化属性，允许在构造函数之外初始化非空属性1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // 直接解引用 &#125;&#125; operator将一个函数标记为重载一个操作符，也就是操作符重载 override与Java类型，override表示重写，Derived.v() 函数上必须加上 override标注。如果没写，编译器将会报错。1234567open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived() : Base() &#123; override fun v() &#123;&#125;&#125; private可见性，将一个声明标记为在当前类或文件中可见 protected可见性，将一个声明标记为在当前类及其子类中可见 internal可见性，将一个声明标记为在当前模块中可见 public可见性，将一个声明标记为在任何地方可见 reifiedsuspend将一个函数或lambda表达式标记为挂起式（可用做协程）123suspend fun doSomething(foo: Foo): Bar &#123; ……&#125; infix允许以中缀表示法调用函数123456789101112// 给 Int 定义扩展infix fun Int.shl(x: Int): Int &#123;……&#125;// 用中缀表示法调用扩展函数1 shl 2// 等同于这样1.shl(2) tailrectailrec表示将一个函数标记为尾递归（允许编译器将递归替换为迭代）12345678private fun findFixPoint(): Double &#123; var x = 1.0 while (true) &#123; val y = Math.cos(x) if (x == y) return y x = y &#125;&#125; varargvararg表示可变参数（通常是最后一个参数）：123456fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // 在这里ts的类型是数组 result.add(t) return result&#125; 使用：1val list = asList(1, 2, 3) 当我们调用vararg函数，不仅可以接收可以一个接一个传递参数，例如asList(1, 2, 3)，也可以将一个数组传递进去，在数组变量前面加spread操作符，就是*号：12val a = arrayOf(1, 2, 3)val list = asList(-1, 0, *a, 4) // 表示(-1, 0, 1, 2, 3, 4) 特殊标识符(Special Identifiers)fieldfield为备用字段，Kotlin中的类并不允许使用字段，在自定义getter和setter的时候，可以使用field来起到局部变量的作用。123456var counter = 0 //初始化值会直接写入备用字段 get() = field set(value) &#123; if (value &gt;= 0) field = value &#125; 编译器会检查访问器的代码,如果使用了备用字段(或者访问器是默认的实现逻辑)，就会自动生成备用字段，否则就不会。123// 这种情况并不需要备用字段，所有不会生成备用字段val isEmpty: Boolean get() = this.size == 0 注意：field标识符只允许在属性的访问器函数内使用. itit为单个参数的隐式名称，若函数参数对应的函数只有一个参数，在使用时，可以省略参数定义(连同-&gt;)，直接使用it代替参数：12val doubled = ints.map &#123; it -&gt; it * 2 &#125;ints.filter &#123; it &gt; 0 &#125; // it表示 '(it: Int) -&gt; Boolean' 这种方式可以写成LINQ-style代码：123strings.filter &#123; it.length == 5 &#125;.sortBy &#123; it &#125;.map &#123; it.toUpperCase() &#125; 操作符和特殊符号(Operators and Special Symbols)+、-、*、/、%数学操作符，其中*还能用于将数组传给vararg参数12345678fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // ts is an Array result.add(t) return result&#125;val a = arrayOf(1, 2, 3)val list = asList(-1, 0, *a, 4) ==除了作为赋值操作符外，还用于指定参数的默认值123fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size) &#123;&#125; +=、-=、*=、/=、%=广义赋值操作符 ++、--递增递减操作符 &amp;&amp;、||、!逻辑“与”、“或”、“非”操作符，对应的中缀函数 and(bits) – 位与 or(bits) – 位或 xor(bits) – 位异或 inv() – 位非 ==、!=相等操作符，对于非原生类型会翻译为调用equals() ===、!==引用相等操作符，引用相等由===（以及其否定形式 !==）操作判断。a === b 当且仅当a和b指向同一个对象时求值为true。 &lt;、&gt;、&lt;=、&gt;=比较操作符，对于非原生类型会翻译为调用compareTo() [、]索引访问操作符，会翻译为调用get与set !!一个表达式非空1val l = b!!.length ?.执行安全调用，如果接收者非空，就调用一个方法或访问一个属性1b?.length ?:如果左侧的值为空，就取右侧的值（elvis操作符）1val l = b?.length ?: -1 ::创建一个成员引用或者一个类引用123fun isOdd(x: Int) = x % 2 != 0val numbers = listOf(1, 2, 3)println(numbers.filter(::isOdd)) // 输出 [1, 3] ..创建一个区间1val s = 1..10 ?将类型标记为可空1val s: String? = null -&gt;分隔lambda表达式的参数与主体1val sum = &#123; x: Int, y: Int -&gt; x + y &#125; 分隔在函数类型中的参数类型与返回类型声明12345678// less类型是函数参数fun &lt;T&gt; max(collection: Collection&lt;T&gt;, less: (T, T) -&gt; Boolean): T? &#123; var max: T? = null for (it in collection) if (max == null || less(max, it)) max = it return max&#125; 分隔 when 表达式分支的条件与代码体1234567when (x) &#123; 1 -&gt; print("x == 1") 2 -&gt; print("x == 2") else -&gt; &#123; print("x is neither 1 nor 2") &#125;&#125; @引入一个注解12345@Fancy class Foo &#123; @Fancy fun baz(@Fancy foo: Int): Int &#123; return (@Fancy 1) &#125;&#125; 引入或引用一个循环标签12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 引入或引用一个lambda表达式标签123456fun foo() &#123; ints.forEach lit@ &#123; if (it == 0) return@lit print(it) &#125;&#125; 引用一个来自外部作用域的 this表达式12345678910111213141516171819202122class A &#123; // 隐式标签 @A inner class B &#123; // 隐式标签 @B fun Int.foo() &#123; // 隐式标签 @foo val a = this@A // A 的 this val b = this@B // B 的 this val c = this // foo() 的接收者，一个 Int val c1 = this@foo // foo() 的接收者，一个 Int val funLit = lambda@ fun String.() &#123; val d = this // funLit 的接收者 &#125; val funLit2 = &#123; s: String -&gt; // foo() 的接收者，因为它包含的 lambda 表达式 // 没有任何接收者 val d1 = this &#125; &#125; &#125;&#125; 引用一个外部超类1234567891011class Bar : Foo() &#123; override fun f() &#123; /* …… */ &#125; override val x: Int get() = 0 inner class Baz &#123; fun g() &#123; super@Bar.f() // 调用 Foo 实现的 f() println(super@Bar.x) // 使用 Foo 实现的 x 的 getter &#125; &#125;&#125; ;分隔位于同一行的多个语句123map.forEach &#123; _, value -&gt; println("$value!");println("$value!") &#125; $在字符串模版中引用变量或者表达式12val s = "abc"val str = "$s.length is $&#123;s.length&#125;" // 求值结果为 "abc.length is 3" _在lambda表达式中代替未使用的参数123map.forEach &#123; _, value -&gt; println("$value!") &#125; 在解构声明中代替未使用的参数1val (_, status) = getResult()]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Operator</tag>
        <tag>Keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_内联函数（inline）]]></title>
    <url>%2F2017%2F10%2F25%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure, i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead. 使用高阶函数在运行时会带来一些坏处：每个函数都是一个对象, 而且它还要捕获一个闭包，也就是说在函数体内部访问的那些外层变量的内存占用(函数对象和类都会占用内存) 以及虚方法调用都会带来运行时的消耗。 内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换，但是由于在编译时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间开销上不会像函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省，因此如果一个内联函数是很大的话，会大幅增加调用它的那个函数的体积。 设置内联使用关键字inline即可设置函数为内联函数：123inline fun &lt;T&gt; T.one (inlined: () -&gt; Unit) &#123;&#125; 禁用内联(noinline)如果只有一些被内联，另外的不想内联，则可以使用关键字noinline可以将函数禁用内联：123inline fun &lt;T&gt; T.one (inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) &#123;&#125; 如果一个内联函数没有可内联的函数参数并且没有具体化类型参数，则会产生一个禁告，因为这样的内联函数没有什么用处。 具体化类型参数(Reified type parameters)什么是具体化类型参数，使用 reified 修饰符来限定类型参数，可以在函数内部访问它了，就像是一个普通的类。为什么要会有这样的参数，举个栗子，访问一个类型作为参数传递的时候，是这样的：12345678fun &lt;T&gt; TreeNode.findParentOfType(clazz: Class&lt;T&gt;): T? &#123; var p = parent while (p != null &amp;&amp; !clazz.isInstance(p)) &#123; p = p.parent &#125; @Suppress("UNCHECKED_CAST") return p as T?&#125; 如果要向上遍历，并且检查每隔节点是不是特定的类型，调用的时候一点都不优雅1treeNode.findParentOfType(MyTreeNode::class.java) 如果改成这样的话就很优雅了：1treeNode.findParentOfType&lt;MyTreeNode&gt;() 这样就是具体化类型参数所带来的一些好处，函数就要修改为1234567inline fun &lt;reified T&gt; TreeNode.findParentOfType(): T? &#123; var p = parent while (p != null &amp;&amp; p !is T) &#123; p = p.parent &#125; return p as T?&#125; 上面提到的如果一个内联函数的参数都是noinline的话，会发出一个警告，这时候可以加个具体化参数来解除警告123inline fun &lt;reified T&gt; T.one (noinline inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) &#123;&#125; 具体化参数类型只能在内联函数上使用。 非局部返回(Non-local returns)在Kotlin中，只能使用一个正常非限定的return来退出一个命名函数或者匿名函数，意味着退出Lambdas表达式不能使用单独的return，必须标签，这是由于Lambda表达式不能使包含它的函数返回12345fun foo() &#123; ordinaryFunction &#123; return // 错误：不能使 `foo` 在此处返回 &#125;&#125; 如果Lambdas表达式传给的函数是内联函数的话，return也是内联的，可以单独return12345fun foo() &#123; inlineFunction &#123; return // OK：该 lambda 表达式是内联的 &#125;&#125; 而这种返回（位于 lambda 表达式中，但退出包含它的函数）在Kotlin中称为非局部返回。例如我们常用的foreach也是内联函数 调用123456fun hasZeros(ints: List&lt;Int&gt;): Boolean &#123; ints.forEach &#123; if (it == 0) return true // 从 hasZeros 返回 &#125; return false&#125; 如果有内联函数的调用不是由自己函数体传递的，而是由另一个执行上下面的Lambdas表达式参数传递调用，如局部对象或者嵌套函数等，这样的Lambdas表达式是不允许局部控制操作，为了标识这种情况，加crossinline关键字123456inline fun f(crossinline body: () -&gt; Unit) &#123; val f = object: Runnable &#123; override fun run() = body() &#125; // ……&#125; 当前break和continue在内联的Lambda表达式中还不支持 内联属性（自 1.1 起）inline修饰符可用于没有备用字段的属性访问器：123456val foo: Foo inline get() = Foo()var bar: Bar get() = …… inline set(v) &#123; …… &#125; 可以标注整个属性：123inline var bar: Bar get() = …… set(v) &#123; …… &#125; 公有 API 内联函数的限制当一个内联函数是 public 或 protected 而不是 private 或 internal 声明的一部分时，就会认为它是一个模块级的公有 API。可以在其他模块中调用它，并且也可以在调用处内联这样的调用。 这带来了一些由模块做这样变更时导致的二进制兼容的风险——声明一个内联函数但调用它的模块在它修改后并没有重新编译。 为了消除这种由非公有 API 变更引入的不兼容的风险，公有 API 内联函数体内不允许使用非公有声明，即，不允许使用 private 与 internal 声明以及其部件。 一个 internal 声明可以由 @PublishedApi 标注，这会允许它在公有 API 内联函数中使用。当一个 internal 内联函数标记有 @PublishedApi 时，也会像公有函数一样检查其函数体。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>inline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android逆向 Smali学习]]></title>
    <url>%2F2017%2F10%2F24%2FAndroid%E9%80%86%E5%90%91_Smali%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[描述符和数据类型Smali数据类型，基本类型和引用类型.对象和数组都是引用类型 Java类型 Smali类型描述符 int I long J double D boolean Z float F short S char C byte B void V 对象类型 L 数组类型 [ 下面我们来看下这三种类型的代码 基本类型Java1234// 由于有9个基本类型，这里我只写出两个int和voidprivate int a = 1;// 变量是没有void类型的，所以用方法表示private void getVoid(String a, int b)&#123;&#125; Smali1234567891011121314# instance fields.field private a:I# 先不看方法里面的内容，后面会说.method private getVoid(Ljava/lang/String;I)V .registers 3 .param p1, "a" # Ljava/lang/String; .param p2, "b" # I .prologue .line 4 return-void.end method .field表示一个字段，紧跟着private表示该字段的可见性，然后a表示字段名，I表示字段类型为int，中间用:隔开。 .method表示一个方法，private同样是可见性，getVoid(Ljava/lang/String;I)表示方法名为getVoid，参数为Ljava/lang/String;和I类型，Ljava/lang/String;为对象类型，以L开头，;结尾，后面的V表示返回值为void。 对象类型Java123private String a;private static String b;private OtherClass c; Smali12345678# static fields.field private static b:Ljava/lang/String;# instance fields.field private a:Ljava/lang/String;.field private c:Lcom/example/test/OtherClass; L即上面定义的java类类型,表示后面跟着的是类的全限定名.比如java中的java.lang.String对应的描述是Ljava/lang/String; 注意：全限定名就是，一个类的完整类名如String的完整类名是java.lang.String，并将里面的.替换成/，然后在末尾加上;结尾，这样的就叫全限定名。 数组类型Java12private int[] a = new int[1];private String[] b = new String[1]; Smali1234# instance fields.field private a:[I.field private b:[Ljava/lang/String; [表示数组类型，后面跟着基本类型或者对象类型，一维数组用一个[，二维数组用两个[表示，如int[][]对应的描述就是[[I，而对象类型数组，则是后面加上类的全限定名，如String[][]对应的是[[Ljava/lang/String; 指令Java对应Smali描述使用指令来完成的，下面我们来一一说明指令的作用。 文件头我们在创建一个类的时候，会有包名，会有类名，类会继承父类，这就是文件头内容。 Java1234package com.example.test;public final class TestClass extends OtherClass &#123;&#125; Smali123.class public final Lcom/example/test/TestClass;.super Lcom/example/test/OtherClass;.source "TestClass.java" 这三行是每个文件的前三行，一定会有的。.class声明该类的全限定名，声明了该类的可见性（访问权限），声明了该类为final（非权限修饰符），格式为：123.class &lt;访问权限修饰符&gt; [非权限修饰符] &lt;类名&gt;# 访问权限修饰符即public, protected, private和default. # 非权限修饰符则指的是final, abstract. .super表示声明该类的父类，默认父类为Ljava/lang/Object;，格式为1.super &lt;父类名&gt; .source表示声明该类的源文件名称，这里就是TestClass.java1.source &lt;源文件名称&gt; 文件内容讲了文件头之后，接下来的就是文件正文了，也就是类的主体部分，主体内容大致包括接口描述、注解描述、字段描述、方法描述四个部分。 接口描述在写一个类的时候，有时候会实现一个接口，我们来看看是转换的内容1234package com.example.test;public class TestClass implements OtherInterface, OtherClass &#123;&#125; Smali1234567.class public Lcom/example/test/TestClass;.super Ljava/lang/Object;.source "TestClass.java"# interfaces.implements Lcom/example/test/OtherInterface;.implements Lcom/example/test/OtherClass; .implements就表示实现的接口描述，后面只能描述一个接口，多个接口用多个.implements描述。 注解描述1234567891011package com.example.test;import org.junit.Test;public class TestClass &#123; @Test public void annotationFun() &#123; &#125;&#125; Smali1234567891011# virtual methods.method public annotationFun()V .registers 1 # 这里就是注解了 .annotation runtime Lorg/junit/Test; .end annotation .prologue .line 10 return-void.end method 字段描述12private final String fieldOne = "123";private static String fieldTwo = "123"; Smali123456# static fields.field private static fieldTwo:Ljava/lang/String;# instance fields.field private final fieldOne:Ljava/lang/String; 方法描述12345678package com.example.test;public class TestClass &#123; public void annotationFun() &#123; &#125;&#125; Smali12345678# virtual methods.method public annotationFun()V .registers 1 .prologue .line 7 return-void.end method]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Smali</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Xposed实现QQ/TIM自动确认电脑扫一扫登录]]></title>
    <url>%2F2017%2F10%2F12%2F%E4%BD%BF%E7%94%A8Xposed%E5%AE%9E%E7%8E%B0QQ-TIM%E8%87%AA%E5%8A%A8%E7%A1%AE%E8%AE%A4%E7%94%B5%E8%84%91%E6%89%AB%E4%B8%80%E6%89%AB%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[缘由不知道大家有没有用过QQ/TIM登录的时候使用扫描二维码登录的功能呢？ 也就是登录界面的右下角那里有个二维码的按钮 点击之后就会出现二维码 然后用手机QQ/TIM打开扫一扫界面，扫了之后，会弹出允许登录的界面 然后我们需要点击允许登录TIM/QQ，电脑端就登录成功了。 但是每次登录都要点击允许登录，我觉得好麻烦，所以就实现了自动点击功能，这篇文章就是来介绍如何使用Xposed来实现自动点击。 实践首先我们先整理一下思路，先要获取确认登录界面的Class，然后获取允许登录这个控件的Field，然后通过调用performClick这个方法来实现点击。 查找确认登录Activity接下来，我们需要获取确认登录界面的Activity是哪一个，在这里我们先下载一个软件当前界面，可以获取到当前界面的Activity 在这里我们找到了确认界面的Activity的类名是com.tencent.biz.qrcode.activity.QRLoginActivity，然后我们进行下一步 反编译classes.dex当前使用的apk版本是2.0.0，然后改后缀，打开压缩包，复制里面的dex文件 然后通过dex2jar将dex转换成jar文件，然后用jd-gui打开jar包，最后在classes6-dex2jar.jar里面找到QRLoginActivity类 使用AndroidKiller由于我们需要获取控件相关的内容，就需要获取控件的id、text之类的东西，那么仅仅靠dex2jar和jd-gui两个东西是完成不了的，所以这里我们需要用到AndroidKiller，AndroidKiller是一款可视化的安卓应用逆向工具，具体使用，大家自行上网搜索，这里不介绍。 获取text引用将我们的TIM的apk打开，然后搜索允许登录内容，找到对应的16进制内容 找到之后，发现有两个16进制的值，一个是7f0a0872，一个是7f0a0ba9，既然有两个，那么就有分别去搜索这两个值的调用，我这里有搜索过，第二个才是我们需要的，我们来看搜索结果 可以看出，这个值的引用是在hxq类上面调用的，点开jd-gui，找到这个类，同样是在classes6-dex2jar.jar里面 可以看出这个类是个Handler类，那么我们就可以这样理解，当扫描二维码后，会调用sendMessage之类的方法，然后在handleMessage里面进行修改控件的Text值。 Hook方法通过上面的说明，我们可以很明确的知道该hook的地方在哪里了： 首先我们需要将Hook控件初始化的方法，然后再Hook我们的hxq类里面的handleMessage方法 之后进行判断控件的值是不是包含允许登录的内容(因为二维码过期我们不需要进行处理，只有登录的时候才进行处理)，如果包含的话就调用performClick这个方法实现点击。 找到初始化方法如何找到初始化方法呢，通过搜索findviewbyid，找到了doOnCreate方法 然后我们Hook这个方法123456789101112// 获取Classfinal Class&lt;?&gt; aClass = XposedHelpers.findClassIfExists("com.tencent.biz.qrcode.activity.QRLoginActivity", lpparam.classLoader);if (aClass == null) &#123; return;&#125;// Hook指定方法XposedHelpers.findAndHookMethod(aClass, "doOnCreate", Bundle.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // 操作 &#125;&#125;); 反射获取控件通过获取QRLoginActivity的Class之后，我们通过反射获取里面的所有变量，然后通过判断变量的类型，然后判断控件的Text值是否包含允许登录内容，然后实现点击。12345678910111213141516171819202122232425262728293031for (Field declaredField : declaredFields) &#123; // 设置true declaredField.setAccessible(true); // 判断类型是否是Button if (declaredField.getGenericType().toString().contains("android.widget.Button")) &#123; // 获取值 final Button loginButton = (Button) declaredField.get(param.thisObject); if (loginButton == null) &#123; return; &#125; // 默认的Button的Text为空，需要在Handler这个类里面的方法后面加上判断 Class&lt;?&gt; handlerClass = XposedHelpers.findClassIfExists(resultStr, lpparam.classLoader); if (handlerClass == null) &#123; return; &#125; try &#123; // Hook方法，对handleMessage方法调用后，进行判断Button的Text进行判断，并且自动调用点击方法 XposedHelpers.findAndHookMethod(handlerClass, "handleMessage", Message.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // 当Button的Text为允许登录TIM/允许登录QQ的时候才实现点击 if (loginButton.getText().toString().contains("允许登录")) &#123; loginButton.performClick(); &#125; &#125; &#125;); &#125; catch (Throwable t) &#123; XposedBridge.log("Hook 出错 " + t); &#125; &#125;&#125; 最后打包，安装，激活重启 结果： 结语文章说的简单一点，实际上自己反编译并且查找内容，是一个比较繁琐的事情，明确的方向会减轻需要操作的步骤。 微信自动确认登录同样我们可以实现自动确认电脑端登录，这里就不再介绍了，大家可以自己试一试： GitHubGithub地址在此奉上：ScanLogin，欢迎star]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Xposed去除微博国际版的启动广告]]></title>
    <url>%2F2017%2F09%2F29%2F%E4%BD%BF%E7%94%A8Xposed%E5%8E%BB%E9%99%A4%E5%BE%AE%E5%8D%9A%E5%9B%BD%E9%99%85%E7%89%88%E7%9A%84%E5%90%AF%E5%8A%A8%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[前面有篇文章已经介绍了如何创建Xposed模块的文章了，这篇就让我们来实现一个简单的去除启动广告的功能吧。 起因为什么要是要去掉微博国际版的开屏广告呢，因为广告烦人啊，而且我打开微博的时间也是偶尔才会打开的，每次一打开就能看到广告，所以就想把这个开屏广告给删掉，奇怪的是，打开一次后，再关掉再打开是没有广告的，要隔一段时候才会出现广告，这个原因会在下面解释。 实践查找启动Activity首先我们先拿到微博国际版的apk，apk的版本是2.5.7-5。 然后拉到Android Studio里面，然后点击AndroidManifest.xml文件，然后搜索android.intent.category.LAUNCHER，找到启动的Activity，在这里我们找到Activity是com.weico.international.activity.LogoActivity 反编译classes.dex在这里所用到的反编译工具都是可以在网上找到，工具为dex2jar和jd-gui，大家自行搜索下载。找到了启动的Activity后呢，我们就要将apk给反编译，把里面的classes.dex文件提取出来，首先将微博国际版的apk后缀改为.zip，然后打开 然后将里面的两个dex文件，拷贝出来，放到dex2jar目录里面，然后拖两个文件到dex2jar.bat上面，让其转换成jar文件 转换过程 转换完成之后会出现classes_dex2jar.jar和classes2_dex2jar.jar两个文件 然后我们用jd-gui打开这两个jar文件，然后找到LogoActivity 查找广告使用jd-gui打开LogoActivity之后，我们就要在里面查找广告相关的内容了，我们搜索ad，最后找到loginOrGlance方法和openGDTAD方法。通过下面代码可以看出，真正显示广告的是openGDTAD方法，而loginOrGlance方法则是判断当前启动是否需要显示广告，这下找到源头就好办了。123456789101112131415161718192021222324252627282930313233343536373839private void loginOrGlance()&#123; if (!Setting.getInstance().loadBoolean("first_open_guide")) &#123; Setting.getInstance().saveBoolean("first_open_guide", true); startActivityForResult(new Intent(this.me, GuideActivity.class), 1025); return; &#125; if (AccountsStore.getCurAccount() != null) &#123; if (Setting.getInstance().loadInt("display_ad") == 1) &#123; if (System.currentTimeMillis() - Setting.getInstance().loadLong("ad_display_time") &gt; ProcessMonitor.repeatedTime) &#123; openGDTAD(); return; &#125; initMainTabActivity(); return; &#125; initMainTabActivity(); return; &#125; initGuestActivity();&#125;// 加载广告private void openGDTAD()&#123; getWindow().getDecorView().postDelayed(new Runnable() &#123; public void run() &#123; WIActions.startActivityWithAction(new Intent(LogoActivity.this.me, NewSplashActivity.class), Constant.Transaction.GROW_FADE); LogoActivity.this.finish(); &#125; &#125; , 600L);&#125; 广告间隔出现原因前面我们说过启动一次出现广告后，要隔一段时候才会重新出现广告，上面的代码System.currentTimeMillis() - Setting.getInstance().loadLong(&quot;ad_display_time&quot;) &gt; ProcessMonitor.repeatedTime，这里就是原因，当前时间跟上一次显示广告的时间相差超过ProcessMonitor.repeatedTime的值的时候，就会出现广告。我们来看一下repeatedTime的值是多少，进到ProcessMonitor类里面，值为1800000毫秒，也就是30分钟才出现一次广告，比起那些每次打开都会出现广告的好多了，但是也阻挡不了我干掉广告。 显示广告条件我们来看loginOrGlance方法里面的广告相关代码123456789101112if (Setting.getInstance().loadInt("display_ad") == 1)&#123; if (System.currentTimeMillis() - Setting.getInstance().loadLong("ad_display_time") &gt; ProcessMonitor.repeatedTime) &#123; openGDTAD(); return; &#125; initMainTabActivity(); return;&#125;initMainTabActivity();return; 可以看出，首先先判断display_ad的值是否为1，如果不为1，就直接调用启动主界面的initMainTabActivity()方法。如果为1，在继续判断上一次显示广告的时间ad_display_time是否超过30分钟，如果超过就显示，没有超过就启动主界面。所以，显示广告有两个条件 display_ad的值为1 上一次显示广告的时间和现在的时间相差30分钟 Hook方法这里我们来介绍一下Hook所用到的一下Xposed里面的方法findAndHookMethod方法，其参数对应为加载的类(Class&lt;?&gt;) + 方法名 + 参数类型(根据所Hook方法的参数的类型，即有多少个写多少个，加上.class) + XC_MethodHook回调接口。XC_MethodHook中定义了回调方法：beforeHookedMethod(MethodHookParam param)：被hook方法调用前执行，调用param.setResult可以跳过被Hook的方法。afterHookedMethod(MethodHookParam param) ： 被Hook方法调用后执行，调用param.setResult更改被hook方法的执行结果。 通过上面分析，我们知道了所需要的Hook的两个方法，这两个值居然是存到本地SharedPreferences里面，那么我们修改就更容易了。 一个是Setting.getInstance().loadInt(&quot;display_ad&quot;)，既是Setting类里面的loadInt方法。 1234public int loadInt(String paramString)&#123; return this.mSharedPreferences.getInt(paramString, -1);&#125; 一个是Setting.getInstance().loadLong(&quot;ad_display_time&quot;)，既是Setting类里面的loadLong方法。 1234public long loadLong(String paramString)&#123; return this.mSharedPreferences.getLong(paramString, -1L);&#125; 验证首先我们来验证一下我们上面的两个条件是否正确，打开我们的Tutorial类，在handleLoadPackage方法里面实现我们的Hook。我们先验证30分钟出现的条件，既然是要超过30分钟，那么我们只需要将loadLong(&quot;ad_display_time&quot;)返回的值改为-1L，也就是afterHookedMethod(MethodHookParam param)方法里面修改，就可以实现每次启动都能出现广告界面了1234567891011121314151617181920212223242526272829303132public class Tutorial implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; // 只对微博国际版进行操作 if (lpparam.packageName.equals("com.weico.international")) &#123; try &#123; // 获取Setting类 Class&lt;?&gt; aClass = XposedHelpers.findClassIfExists("com.weico.international.activity.v4.Setting", lpparam.classLoader); if (aClass == null) &#123; return; &#125; // Hook方法 XposedHelpers.findAndHookMethod(aClass, "loadLong", String.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; String param1 = (String) param.args[0]; // 如果参数为ad_display_time的时候将返回值改为-1L if (!TextUtils.isEmpty(param1) &amp;&amp; param1.equals("ad_display_time")) &#123; Log.e("info", "com.weico.international---loadLong---ad_display_time"); param.setResult(-1L); &#125; &#125; &#125;); &#125; catch (Throwable t) &#123; XposedBridge.log("Hook出错" + t); &#125; &#125; &#125;&#125; 接着运行重启手机，开机后，打开微博国际版。 可以看出，现在每次打开都会有广告，证明我们的猜测是正确的。 去除广告我们只需要将Setting.getInstance().loadInt(&quot;display_ad&quot;)的返回值改为-1就能实现去除广告的效果了，下面看代码12345678910111213141516171819202122232425262728293031323334353637383940414243public class Tutorial implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; // 只对微博国际版进行操作 if (lpparam.packageName.equals("com.weico.international")) &#123; try &#123; Class&lt;?&gt; aClass = XposedHelpers.findClassIfExists("com.weico.international.activity.v4.Setting", lpparam.classLoader); if (aClass == null) &#123; return; &#125; // Hook loadInt方法 XposedHelpers.findAndHookMethod(aClass, "loadInt", String.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; String param1 = (String) param.args[0]; // 如果参数为display_ad的时候将返回值改为-1 if (!TextUtils.isEmpty(param1) &amp;&amp; param1.equals("display_ad")) &#123; Log.e("info", "com.weico.international---loadInt---display_ad"); param.setResult(-1); &#125; &#125; &#125;); // Hook loadLong方法 XposedHelpers.findAndHookMethod(aClass, "loadLong", String.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; String param1 = (String) param.args[0]; // 如果参数为ad_display_time的时候将返回值改为当前时间 if (!TextUtils.isEmpty(param1) &amp;&amp; param1.equals("ad_display_time")) &#123; Log.e("info", "com.weico.international---loadLong---ad_display_time"); param.setResult(System.currentTimeMillis()); &#125; &#125; &#125;); &#125; catch (Throwable t) &#123; XposedBridge.log("Hook出错" + t); &#125; &#125; &#125;&#125; 接着运行重启手机，开机后，打开微博国际版。 可以看出，再也没有广告了。 总结这次使用Xposed实践，来去除微博国际版的启动广告，可以说是收获挺大的，Hook到所调用的方法，然后里面进行我们自己的操作，关键就是在于beforeHookedMethod和afterHookedMethod这两个方法里面实现的操作。 GithubGithub地址在此奉上：XposedRemoveAd，欢迎star]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究Exported属性对startActivity的影响]]></title>
    <url>%2F2017%2F09%2F28%2F%E6%8E%A2%E7%A9%B6Exported%E5%B1%9E%E6%80%A7%E5%AF%B9startActivity%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[缘由这几天想做一个点击跳转到TIM的扫一扫的Activity的功能，代码是这样的，就是普通的跳转12345678910Intent intent = new Intent();intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);ComponentName component = new ComponentName("com.tencent.tim", "com.tencent.biz.qrcode.activity.ScannerActivity");intent.setComponent(component);intent.setAction("android.intent.action.VIEW");try &#123; startActivity(intent);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 为什么我后面要加try/catch呢，因为不加的话会报异常，然后闪退，报的异常内容如下： 12345java.lang.SecurityException: Permission Denial: starting Intent &#123; act=android.intent.action.VIEW flg=0x10000000 cmp=com.tencent.tim/com.tencent.biz.qrcode.activity.ScannerActivity &#125; from ProcessRecord&#123;e0031ac 25553:top.jowanxu.xposedtest/u0a175&#125; (pid=25553, uid=10175) not exported from uid 10151 Exported属性wtf？没有权限？然后呢，百度了下，发现是Activity的属性exported的值为false，然后别的app就打不开这个Activity了，如果要打开的话，就必须和这个Activity在同一Application下或者uid相同才行。12345&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" ... android:sharedUserId="com.example.categorytest"&gt; ...&lt;/manifest&gt; 同一不能打开的还有在没有设置exported属性的时候，也没有设置intent-filter属性的话，也是打不开这个Activity的。123456789101112&lt;activityandroid:name=".ScannerActivity"android:label="@string/app_name" android:exported="false"/&gt; &lt;!-- 设置了exported属性值为false --&gt;&lt;!-- 如果Activity里面至少有一个filter的话，意味着这个Activity可以被其它应用从外部唤起，这个时候它的默认值是true --&gt;&lt;activityandroid:name=".SecondActivity"android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 然后我们Analyze APK一下我们的TIM的apk，打开它的AndroidManifest.xml文件，然后搜索ScannerActivity，发现ScannerActivity里面的exported的值果然是false。 既然如此的话，那就看一下当Activity的exported属性值为false的时候，为什么不能调起这个Activity，而且还会报异常。从startActivity的源码看起，既然我们一开始的问题是Permission Denial，那么我们查看的关键词就必须包含permission，这样看起源码来就方便许多。 源码Activity类首先是Activity里面的startActivity，发现他是调用自己的另一个同名不同参数的方法。 1234@Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125; 跳到startActivity(Intent intent, @Nullable Bundle options)方法后，因为options参数为null，所以是调用startActivityForResult(@RequiresPermission Intent intent, int requestCode)这个方法。 12345678910@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125; 跳到startActivityForResult方法后，发现又是调用同名不同参数的方法startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options)。 1234public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123; // requestCode = -1 startActivityForResult(intent, requestCode, null);&#125; 接着看mParent == null条件里面的代码，关键词startActivity，然后找到execStartActivity()，是Instrumentation类里面的方法。 12345678910111213141516171819public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; .... &#125; else &#123; .... &#125;&#125; Instrumentation类跳转到execStartActivity方法里，同样关键词startActivity，可以看到是ActivityManagerNative.getDefault().startActivity()方法和checkStartActivityResult()方法，我们先来看checkStartActivityResult()方法。 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; .... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null;&#125; 点进去之后发现，这里面就是我们经常startActivity之后，在类没找到或者没有在AndroidManifest中注册等等之后会报出的异常的判断方法。 1234567891011121314151617181920212223242526272829303132333435363738394041public static void checkStartActivityResult(int res, Object intent) &#123; if (res &gt;= ActivityManager.START_SUCCESS) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( "Unable to find explicit activity class " + ((Intent)intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?"); throw new ActivityNotFoundException( "No Activity found to handle " + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException("Not allowed to start activity " + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( "FORWARD_RESULT_FLAG used while also requesting a result"); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( "PendingIntent is not an activity"); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( "Starting under voice control not allowed for: " + intent); case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION: throw new IllegalStateException( "Session calling startVoiceActivity does not match active session"); case ActivityManager.START_VOICE_HIDDEN_SESSION: throw new IllegalStateException( "Cannot start voice activity on a hidden session"); case ActivityManager.START_CANCELED: throw new AndroidRuntimeException("Activity could not be started for " + intent); default: throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent); &#125;&#125; IActivityManager接口点击startActivity()之后，跳转到IActivityManager接口里面来了，这个接口就是管理Activity的，然后我们从ActivityManagerNative.getDefault().startActivity()看出调用者是在ActivityManangerNative类里面。 123456789101112/** * System private API for talking with the activity manager service. This * provides calls from the application back to the activity manager. * * &#123;@hide&#125; */public interface IActivityManager extends IInterface &#123; public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException; ....&#125; ActivityManagerNative类这时候到了ActivityManagerNative类里面，实现了IActivityManager接口，同时ActivityManagerNative还是一个抽象类，说明ActivityManagerNative.getDefault().startActivity()调用startActivity调用的对象是该类的子类。 123456789public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; .... static public IActivityManager getDefault() &#123; return gDefault.get(); &#125; ....&#125; 然后我们通过ctrl + shift + F打开搜索，关键词是extends ActivityManagerNative,scope选择custom，然后Find。 然后就找到了ActivityManagerService类 ActivityManagerService类ActivityManagerService类类是final类型，不能被继承，然后我们来看一下他的startActivity方法。 1234567891011121314public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123; .... @Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId()); &#125;&#125; startActivity方法是调用了startActivityAsUser方法，我们继续走下去，来到了startActivityAsUser方法后发现，是调用了ActivityStarter类里面的startActivityMayWait方法。 12345678910111213@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);&#125; ActivityStarter类startActivityMayWait方法内容很多，挑重点看，关键词startActivity，同时看permission相关的有没有，然后我们找到了startActivityLocked方法。12345678910111213141516171819202122232425final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; .... ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); .... ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); .... final ActivityRecord[] outRecord = new ActivityRecord[1]; int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask); .... return res; &#125;&#125; 继续，走到startActivityLocked方法里面，内容特别多，同样挑关键词startActivity和permission看，结果我们找到了mSupervisor.checkStartAnyActivityPermission方法和startActivityUnchecked方法，既然我们的目的是找跟permission相关的，那么我们就只看checkStartAnyActivityPermission方法内容吧。 12345678910111213141516171819202122232425262728final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; .... final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; .... boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho, requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp, resultRecord, resultStack, options); abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo); .... try &#123; mService.mWindowManager.deferSurfaceLayout(); err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); &#125; finally &#123; mService.mWindowManager.continueSurfaceLayout(); &#125; postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack); return err;&#125; ActivityStackSupervisor类根据mSupervisor.checkStartAnyActivityPermission我们来到了ActivityStackSupervisor类的checkStartAnyActivityPermission方法，方法内容不长，直接往下看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475boolean checkStartAnyActivityPermission(Intent intent, ActivityInfo aInfo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, boolean ignoreTargetSecurity, ProcessRecord callerApp, ActivityRecord resultRecord, ActivityStack resultStack, ActivityOptions options) &#123; // 判断权限 final int startAnyPerm = mService.checkPermission(START_ANY_ACTIVITY, callingPid, callingUid); // 如果startAnyPerm的值为0，也就是PERMISSION_GRANTED的话，直接返回true if (startAnyPerm == PERMISSION_GRANTED) &#123; return true; &#125; final int componentRestriction = getComponentRestrictionForCallingPackage( aInfo, callingPackage, callingPid, callingUid, ignoreTargetSecurity); final int actionRestriction = getActionRestrictionForCallingPackage( intent.getAction(), callingPackage, callingPid, callingUid); if (componentRestriction == ACTIVITY_RESTRICTION_PERMISSION || actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) &#123; if (resultRecord != null) &#123; resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode, Activity.RESULT_CANCELED, null); &#125; final String msg; // 重点就是这里了 if (actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) &#123; msg = "Permission Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " with revoked permission " + ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction()); &#125; else if (!aInfo.exported) &#123; msg = "Permission Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " not exported from uid " + aInfo.applicationInfo.uid; &#125; else &#123; msg = "Permission Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + aInfo.permission; &#125; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; if (actionRestriction == ACTIVITY_RESTRICTION_APPOP) &#123; final String message = "Appop Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + AppOpsManager.permissionToOp( ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction())); Slog.w(TAG, message); return false; &#125; else if (componentRestriction == ACTIVITY_RESTRICTION_APPOP) &#123; final String message = "Appop Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires appop " + AppOpsManager.permissionToOp(aInfo.permission); Slog.w(TAG, message); return false; &#125; if (options != null &amp;&amp; options.getLaunchTaskId() != -1) &#123; final int startInTaskPerm = mService.checkPermission(START_TASKS_FROM_RECENTS, callingPid, callingUid); if (startInTaskPerm != PERMISSION_GRANTED) &#123; final String msg = "Permission Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ") with launchTaskId=" + options.getLaunchTaskId(); Slog.w(TAG, msg); throw new SecurityException(msg); &#125; &#125; return true;&#125; 找了那么久，终于找到了，开头提出的问题，就是下面这段代码里面的!aInfo.exported出现的。123456789101112131415161718if (actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) &#123; msg = "Permission Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " with revoked permission " + ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction());&#125; else if (!aInfo.exported) &#123; msg = "Permission Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " not exported from uid " + aInfo.applicationInfo.uid;&#125; else &#123; msg = "Permission Denial: starting " + intent.toString() + " from " + callerApp + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + aInfo.permission;&#125;Slog.w(TAG, msg);throw new SecurityException(msg); aInfo的类型是ActivityInfo，里面有个exported的属性，就是我们在AndroidManifest.xml里面设置的值。123456789/** * Information you can retrieve about a particular application * activity or receiver. This corresponds to information collected * from the AndroidManifest.xml's &amp;lt;activity&amp;gt; and * &amp;lt;receiver&amp;gt; tags. */public class ActivityInfo extends ComponentInfo implements Parcelable &#123;&#125; 总结翻了那么多的源码，看到这里我们的疑惑就解除了，这里报异常是还没进行到调起要跳转的Activity的时候就已经报SecurityException异常了，也就是在checkStartAnyActivityPermission方法里面报异常，没有再往下面走startActivityUnchecked这里面启动Activity的代码。 所以，在exported属性为false的时候，别人是调用不了这个Activity的，那么我的一开始的想法是实现不了的，那就只能通过命令行来调起Activity了，当然这操作是需要root的。]]></content>
      <categories>
        <category>Activity</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed开发初体验]]></title>
    <url>%2F2017%2F09%2F21%2FXposed%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[本篇文章具体是Xposed开发，如何安装Xposed需自行上网查找。 Xposed什么是Xposed呢? “Xposed是一个适用于Android的框架。基于这个框架开发的模块可以改变系统和app应用的行为，而不需要修改APK。这是一个很棒的特性，意味着Xposed模块可以不经过任何修改，安装在各种不同的ROM上。Xposed模块可以很容易的开启和关闭。你只需要激活或者禁用Xposed模块，然后重启手机即可。” 很好理解，就是替换了/system/bin/app_process可执行文件，在启动Zygote时加载额外的jar文件（XposedBridge.jar），并执行一些初始化操作(执行XposedBridge的main方法)，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持，然后我们就可以在这个Zygote上下文中进行某些hook操作。 前提安装Xposed的前提是手机必须root，所以没有root手机的，就不用往下看了。 开发Xposed项目介绍完Xposed，那么接下来我们来开发Xposed的项目。 创建AS项目使用Android Studio创建一个新的项目，具体内容就不详细说了，基本都会创建项目的。 导入Xposed的api库要使用Xposed的东西，就必须导入相对应的api库， 导入jar包首先我们需要下载对应的jar包，然后导入到项目中的Libs文件夹里面，下载api-82-sources.jar，api-82.jar 注意这里要将compile改为provided，原因是Xposed里已有该jar包内容，再次打包进去会冲突，所以要改为provided。 同时也要将compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)也改为provided，如果不修改的话，就会导致handleLoadPackage没有回调。 Provided是对所有的build type以及favlors只在编译时使用，类似eclipse中的external-libs,只参与编译，不打包到最终apk。 gradle当然也可以用gradle导入Xposed，同样将compile改为provided1234567891011dependencies &#123; provided fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.2' testCompile 'junit:junit:4.12' provided 'de.robv.android.xposed:api:82'&#125; 声明Xposed模块创建Xposed项目后，还需要在AndroidMenafest.xml文件里面声明Xposed模块，在application里面添加三个meta-data标签（xposedmodule、xposeddescription、xposedminversion）。1234567891011121314151617&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;meta-data android:name="xposedmodule" android:value="true"/&gt; &lt;meta-data android:name="xposeddescription" android:value="Hook log test"/&gt; &lt;meta-data android:name="xposedminversion" android:value="53"/&gt;&lt;/application&gt; xposedmodule表示作为Xposed的一个模块 xposeddescription表示对本模块的描述，该描述会显示在安装好后的程序名称下方 xposedminversion表示jar包的最低版本号 创建hook类我们新建一个类，类名随意，然后实现IXposedHookLoadPackage接口，并且重写handleLoadPackage方法，里面就是我们要具体操作的地方。 1234567891011121314package top.jowanxu.xposedtest;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage;public class Tutorial implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; XposedBridge.log("=========Loaded app: " + lpparam.packageName); &#125;&#125; 声明类的入口创建完我们hook类之后，我们需要将该类加载到XposedInstaller中，也就是我们必须声明该类的位置，需要在xposed_init中声明。 xposed_init文件创建assests文件夹 然后在里面新建一个文件，文件名为xposed_init，没有后缀，然后在里面写入我们刚刚创建的类的完整类名， 运行搞完上面的步骤之后，我们直接run起来，程序跑起来之后，Xposed会提示是否激活 我们可以在Xposed里面看到我们的我们刚刚创建的项目 打勾，然后重启 重启之后然后打开Xposed的日志，点击保存 然后导出到电脑，搜索一下，就能找到我们自己打印的内容了 结语通过上面的例子我们可以很容易的通过Xposed来对app进行修改，所以使用Xposed需谨慎，不要乱下载一些有后台的模块，指不定那天就把你的帐号密码给泄露出去了。]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_when需写全case条件]]></title>
    <url>%2F2017%2F09%2F17%2FKotlin_learn_whenCaseFull%2F</url>
    <content type="text"><![CDATA[在使用when表达式多个case符合条件的时候，需要注意将判断写全。 使用Kotlin的when表达式来判断多个case符合条件，换成Java就是12345switch(x) &#123;case 1:case 2:break;&#125; 这里遇到一个坑，有一个方法：123456789fun check(value: Any?): String = when (value) &#123; is Int, Float, Double -&gt; &#123; if (value == 0) "value为0" else "value = $value" &#125; else -&gt; &#123; "value为空" &#125;&#125; 这个方法是用来判断输入的值，如果是Int、Float、Double类型的话就判断是否为0，如果不是的就返回字符串value为空。123456fun main(args: Array&lt;String&gt;) &#123; println(check(1)) println(check(11f)) println(check(8.01)) println(check(0))&#125; 打印结果为 ….居然是这样，跟我想的完全不一样，为什么会这样呢，看一下编译后的代码： 发现原因没有，只有Int类型的才有加instanceof判断，而另外两个却没有，那么得为Float和Double也加上is判断才行。123456789fun check(value: Any?): String = when (value) &#123; is Int, is Float, is Double -&gt; &#123; if (value == 0) "value为0" else "value = $value" &#125; else -&gt; &#123; "value为空" &#125;&#125; 再来看看编译后的代码： 还有打印的结果：]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>when</tag>
        <tag>case</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过GitHub和Hexo来搭建自己的个人博客]]></title>
    <url>%2F2017%2F09%2F02%2F%E9%80%9A%E8%BF%87GitHub%E5%92%8CHexo%E6%9D%A5%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建个人博客在我大学的时候建过一次，那时候是用新浪云和Wordpress搭建的，那时候新浪云服务是免费的，后来变收费，博客就没有了。之前便想着再弄个自己的博客出来，这几天就着手弄了起来。看到很多人的个人博客是用github来当服务器，然后通过Hexo来搭建博客框架，那么新建个人博客也用这两个来搭建吧。 GitHub主页创建仓库想必大家都有自己的Github账号吧，没有的可以到GitHub官网注册账号，注册完后，我们来下一步，在我们的GitHub上面右上角的New repository来创建一个仓库。 仓库名必须遵守相应格式：your_username.github.io，这样子在访问主页的时候直接用your_username.github.io就能访问。 我这里因为是已经创建了一个仓库了，所以会有提示，然后点Create repository确定创建仓库。 设置Pages接下来我们来设置我们的GitHub Pages，打开我们刚刚创建的仓库，然后创建一个主页index.html然后在里面输入代码1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;I'm hosted with GitHub Pages.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 然后保存 接下来我们打开GitHub Pages的设置，点开Settings 移到下面的GitHub Pages 可以看出，我现在能用https://jowanxu.github.io/来访问我的github主页了，这里我是用我的一个新创建的号来演示的。 通过上面的配置，我们能通过your_username.github.io来访问我们的博客主页了。 Clone仓库创建完仓库后（可直接安装Git,忽略Clone），我们需要将代码下载到本地，这里就需要用到Git了。 安装Git Windows：下载并安装 git，msysGit Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装完Git后，在命令行输入git --version，判断是否成功 如果出现不存在命令，那么就添加Git目录下bin目录的环境变量，添加完后要重新打开命令行，然后在判断是否成功。 这里我使用msysGit的Bash窗口来进行操作的。 配置Git参数安装完Git后，需要配置本地Git的参数，右键一个文件夹，然后选择Git Bash，打开Bash窗口，然后 然后我们来设置Git的姓名和邮箱：12git config --global user.name &quot;Firstname Lastname&quot;git config --global user.email &quot;your_email@example.com&quot; 配置完成后，会在~/.gitconfig中生成相应的本地Git配置信息。 添加SSH KeyGitHub上连接已有仓库是验证是通过SSH的公开密钥进行认证的，在这里我们来生成我们自己的SSH Key，输入下面的命令，输入完后回车，会让你输入密钥的文件名和密码，系统会在/Users/your_user_directory/.ssh/x下生成私有密钥id_rsa和公开密钥id_rsa.pub 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 我们可以看到生成的文件 id_rsa文件内容是这样的，由-----BEGIN RSA PRIVATE KEY-----开始，和-----END RSA PRIVATE KEY-----结束 id_rsa.pub的内容是这样的，由ssh-rsa开头的 然后我们在GitHub上面添加本地SSH密钥信息，在右上角选择Settings进入设置界面 然后选中SSH and GPG keys，点击New SSH key Title可以随便填，打开公开密钥id_rsa.pub，复制里面的内容到Key里面，填完密钥后，点Add SSH key就OK了。 ssh-agent我们要通过ssh-agent来添加刚刚创建的密钥，来登陆GitHub，ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，通过输入下面两条命令添加，第一条命令是反引号`，不是单引号’12eval `ssh-agent -s`ssh-add hexo_rsa（上面创建的密钥文件名） 然后我们登陆一下GitHub，看是否登陆成功1ssh -T git@github.com 登陆成功~~~ Hexo框架Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。安装Hexo需要用到npm，而安装npm则需要安装Node.js，Node.js可以在官网下载，下载完成直接安装，然后通过命令行来判断是否安装完成 npm设置淘宝NPM镜像，来提高下载速度1npm install -g cnpm --registry=https://registry.npm.taobao.org 设置完镜像后，就可以安装Hexo了1npm install -g hexo-cli 然后用命令行查看是否安装成功1hexo -version 接下来我们需要创建一个文件夹，文件名随意，也可以在已存在的文件夹里面，但是里面必须是什么文件都没有，然后进入到文件夹里面，来初始化Hexo1hexo init 如果没有出现错误，那么我们的Hexo博客框架就安装完成了，生成的目录内容如下，其中_config.yml是网站的配置信息，我们大部分的参数都是在这个文件里面修改 接下来我们来启动Hexo服务1hexo s 也可以开启debug模式，debug模式可以实时更新，方便查看修改后的结果。1hexo s --debug 然后我们在浏览器上输入localhost:4000来打开Hexo Hexo常用命令new如果我们要创建一篇文章的话，我们可以通过new命令来创建，也可以直接在博客目录下面的\source\_posts里面创建markdown文件。1hexo new [layout] &lt;title&gt; 如果标题包含空格的话，请使用引号括起来。 generategenerate命令是用来生成静态文件的，在我们发布到GitHub的仓库的时候，需要先生成，才能上传。1hexo generate 可以简写为1hexo g server开启服务器，网址为http://localhost:40001hexo server 同样可以简写为1hexo s deploy部署网址，上传到我们的GitHub的仓库上面。1hexo deploy 同样可以简写为1hexo d clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果对站点的更改无论如何也不生效，运行该命令。1hexo clean Hexo配置Git我们要上传GitHub必须要先设置一些内容，打开博客目录下面的配置文件_config.yml，找到deploy，然后在type那里输入git，在repo那里输入我们的仓库地址，在branch那里输入master，message为上传日志，可不写 一般我们上传到GitHub的时候我们用这条命令来执行，生成静态文件并且部署到服务器。1hexo g -d 上传完成之后，我们可以在博客文件夹里面的.deploy_git目录管理我们的仓库文件，那么我们上面就不需要Clone仓库下来了。 下一步我们来通过域名解析GitHub主页地址来访问个人博客。 域名在本地搭建完个人博客后，我们就要将代码上传到我们的GitHub仓库上面去，然后我们就可以通过your_username.github.io来访问我们的博客主页了，但是我们如果要修改GitHub的域名的话是改不了的，只有我们自己去购买域名，然后通过域名解析将我们的GitHub主页的域名解析到我们自己买的域名上面，这样我们就可以通过我们自定义的域名来访问我们的博客了。 购买域名购买域名可以在域名提供商购买一个价格合适的个人域名，在这里我用阿里云的上注册购买，阿里云直接用支付宝登陆就行，而且还有部分域名可以1元首年购买的优惠，打开阿里云域名注册官网，然后输入自己想要的域名，当然你也可以选中1元的域名，输入完点查询 然后选择自己想要的域名，加入清单，然后支付 支付完成后我们点击右上角的控制台，进入我们的管理界面，然后打开域名与网站（万网），里面就能看到我们刚刚购买的域名了 绑定域名购买完域名后，我们需要在博客目录下的\source目录下建立CNAME文件（没有后缀名、全部大写），写入你所购买的域名地址。这里我写入的www.jowanxu.top。 然后我们来绑定我们的GitHub主页，继续在阿里云管理控制台，然后选择云解析DNS选项界面 然后点击我们的域名，进入解析设置 默认会有两个解析，一个是CHAME，一个是A，CHAME里面输入我们的GitHub主页your_username.github.io，A那里输入我们GitHub主页的IP，如何获取主页IP呢，通过命令行的ping来获取然后保存就OK啦。 GitHub设置上面弄完之后，我们还需要在我们GitHub仓库上面修改我们的source，才能搞定，打开我们的仓库，然后点击Settings 然后找到GitHub Pages，将source改为master branch，然后保存 并且填入我们自己购买的域名地址，然后保存 然后我们就能收到创建成功的邮件了。 最后我们的GitHub Pagers里面是这样子的，证明成功了 然后我们就能通过自己购买的域名来直接访问到我们放在GitHub上面的个人博客了，如我的博客。 如果你觉得默认自带的主题不好看，可以自己去捣鼓其他的主题，Hexo支持特别多的主题，可以在这个网址上选择自己喜欢的，我这里用到的主题是NexT主题。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_run/let/apply/with的区别]]></title>
    <url>%2F2017%2F07%2F07%2FKotlin_learn_advanceFun%2F</url>
    <content type="text"><![CDATA[run、let、apply、with都是kotlin的标准库里面的函数，这几个函数都有相似的地方，但是又有区别。 run函数 可以看出run是一个扩展函数，并且有返回值的，将最后一行做为返回，默认返回Unit，那么我们来写个例子：123456789101112131415data class User(val name: String = "jowan", val age: Int = 24)fun main(args: Array&lt;String&gt;) &#123; val user = User() // runUnit类型为Unit val runUnit = user.run &#123; println("runUnit:$this") // 打印runUnit:User(name=jowan, age=24) &#125; println("runUnit type:$runUnit") // 打印runUnit type:kotlin.Unit // run类型为User val run = user.run &#123; println("run:$this") // 打印run:User(name=jowan, age=24) User(age = 1) &#125;&#125; let函数 可以看出let也是一个扩展函数，与run函数一样，同样是有返回值，将最后一行做为返回，默认返回Unit，但是与run不同的时候，let有参数而run没有：12345678910111213141516data class User(val name: String = "jowan", val age: Int = 24)fun main(args: Array&lt;String&gt;) &#123; val user = User() // letUnit类型为Unit val letUnit = user.let &#123; println("letUnit:$it") &#125; println("letUnit type:$letUnit") // let类型为User val let = user.let &#123; it -&gt; println("let:$it") User(age = 2) &#125;&#125; apply函数 可以看出apply函数也是一个扩展函数，也有返回值，默认返回该对象，与run的区别是run返回最后一行，apply返回该对象：123456789101112data class User(val name: String = "jowan", val age: Int = 24)fun main(args: Array&lt;String&gt;) &#123; val user = User() // apply类型为User val apply = user.apply &#123; println("apply:$this") // 打印apply:User(name=jowan, age=24) &#125; apply.let &#123; println("apply let:$it") // 打印apply let:User(name=jowan, age=24) &#125;&#125; with函数 可以看出with函数不是扩展函数，与let和apply有点像，同样是有返回值，将最后一行做为返回，默认返回Unit，并且可以直接调用对象的方法和变量：1234567891011121314151617data class User(val name: String = "jowan", val age: Int = 24)fun main(args: Array&lt;String&gt;) &#123; val user = User() // withUnit类型为Unit val withUnit = with(user) &#123; println("withUnit:$this") // 打印withUnit:User(name=jowan, age=24) &#125; // with类型为User val with = with(user) &#123; println("with:$this, name:$name, age:$age") // 打印with:User(name=jowan, age=24), name:jowan, age:24 User(age = 111) &#125; with.let &#123; println("with let:$it") // 打印with let:User(name=jowan, age=111) &#125;&#125; 小结 函数名 返回值 参数 函数类型 run 闭包返回 无 扩展函数 let 闭包返回 it 扩展函数 apply this 无 扩展函数 with 闭包返回 无 非扩展函数]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>run</tag>
        <tag>let</tag>
        <tag>apply</tag>
        <tag>with</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_解构声明（Destructuring Declarations）]]></title>
    <url>%2F2017%2F07%2F04%2FKotlin%E5%AD%A6%E4%B9%A0_%E8%A7%A3%E6%9E%84%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Kotlin1.1.3发布，Kotlin 插件现在支持在编辑器的提示中显示推导的变量、函数和参数类型。默认情况下该功能是禁用的，可以在编辑器的设置中启用它。 下面进入正文，有时候要获取一个对象的属性，会定义很多个变量，这样子就会很麻烦，而在Kotlin中有个很方便的用法，就是使用解构声明。 创建变量在Java中创建多个变量123Person person = new Person("person", 1);String name = person.getPerson();int age = person.getAge(); 而在Kotlin中创建变量的话是这样的12345data class Person(val name: String, val age: Int)val person = Person("jowan", 1)var name = person.namevar age = person.age 使用解构变量，同时创建多个变量1234567data class Person(val name: String, val age: Int)fun main(args: Array&lt;String&gt;) &#123; val (name, age) = Person(&quot;person&quot;, 1) println(name) // 打印person println(age) // 打印1&#125; 这种语法就是解构声明，解构声明可以一次创建多个变量，通常用于数据类当中。我们来看一下解构声明跟普通变量创建的区别： 编译后的代码： 在声明数据类的时候，会自动生成componentN()方法，对应按声明顺序出现的所有属性，如name就是component1()，age就是component2()，而解构声明的val (dName, dAge)事实上就是调用component1()和component2()方法。 循环解构声明同样可以用在循环当中：123456789101112data class Person(val name: String, val age: Int)val list: List&lt;Person&gt; = listOf(Person("one", 1), Person("two", 2), Person("three", 3), Person("four", 4))fun main(args: Array&lt;String&gt;) &#123; list.forEach &#123; (name, age) -&gt; println("name:$name, age:$age") &#125;&#125; 我们来看一下编译后的代码： 打印结果： 函数解构声明也可以用在函数中，从函数中返回值：12345678910111213fun getPair(after: String?, afterAge: Int?): Pair&lt;String, Int&gt; &#123; var name = "wangzai" var age = 23 // 处理返回的数据 name = after ?: name age = afterAge ?: age return Pair(name, age)&#125;fun main(args: Array&lt;String&gt;) &#123; val (name, age) = getPair("jowan", null) println("name:$name, age:$age") // 打印name:jowan, age:23&#125; 编译后的代码： Map解构声明还可以Map中，前提条件是： 通过提供一个iterator()函数将映射表示为一个值的序列 通过提供函数component1()和component2()来将每个元素呈现为一对 在Kotlin标准库里面自带有这样的扩展： 举个栗子：1234567val map: Map&lt;String, Int&gt; = mapOf("one" to 1, "two" to 2, "three" to 3, "four" to 4)fun main(args: Array&lt;String&gt;) &#123; map.forEach &#123; (name, age) -&gt; println("name:$name, age:$age") &#125;&#125; 编译后的代码： 下划线代替未使用变量(1.1版本)-Underscore for unused variables (since 1.1)如果在解构声明中有用不到的变量，则可以使用下划线代替，如上面的栗子：12345678fun getPair(): Pair&lt;String, Int&gt; &#123; return Pair("one", 1)&#125;fun main(args: Array&lt;String&gt;) &#123; val (_, age) = getPair() println("age:$age") // 打印出age:1&#125; 来看看编译后的内容 可以看出没有声明使用下划线的变量。 在Lambda中的解构(1.1版本)-Destructuring in Lambdas (since 1.1)如果Lambda具有Pair类型的参数（或Map.Entry或具有相应componentN函数的任何其他类型），则可以通过将它们放在括号中来引入几个新参数：123456789val map = mapOf(1 to 1, 2 to 2, 3 to 3)map.forEach &#123; entry -&gt; println("$&#123;entry.value&#125;!")&#125;map.forEach &#123; a, b -&gt; println("$a!$b!")&#125; 注意声明参数和声明解构对之间的区别：{ a -&gt; ... }一个参数：123456val map = mapOf(1 to 1, 2 to 2, 3 to 3)map.forEach &#123; entry -&gt; println("$&#123;entry.value&#125;!") // 打印1!2!3!&#125; 编译后的内容： { a, b -&gt; ... }两个参数：123456val map = mapOf(1 to 1, 2 to 2, 3 to 3)map.forEach &#123; a, b -&gt; println("$a!$b!") // 打印1!1!2!2!3!3!&#125; 编译后的内容： 居然是这个样子的，我IDE是用IntelliJ IDEA的。 这时候怎么办呢？问了下大佬，大佬说可以换一种反编译的工具来看。。。 那么就换一种反编译的工具，在这里使用jd-gui来查看class文件里面的内容，打开jd-gui，然后把class文件拖进去就可以： { (a, b) -&gt; ... } 一个Pair类型的解构：123456val map = mapOf(1 to 1, 2 to 2, 3 to 3)map.forEach &#123; (_, value) -&gt; println("$value!") // 打印1!2!3!&#125; 编译后的内容： 这里可以看出解构对和两个参数的区别，解构对是通过调用iterator的，而两个参数则是通过调用BiConsumer里面的accept方法的。 { (a, b), c -&gt; ... }一个Pair类型的解构和一个参数：12345val maps = mapOf((1 to 1) to 3, (2 to 2) to 2, (3 to 3) to 1)maps.forEach &#123; (a, b), c -&gt; println("$a!$b!$c") // 打印1!1!32!2!23!3!1&#125; 编译后的内容： 同样用jd-gui来看编译后的代码： 解构声明也可以指定解构的类型：12345map.mapValues &#123; (_, value) -&gt; "$value!" &#125;map.mapValues &#123; (_, value): Map.Entry&lt;Int, String&gt; -&gt; "$value!" &#125;map.mapValues &#123; (_, value: String) -&gt; "$value!" &#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_类型别名（Type aliases）和注解（Annotations）]]></title>
    <url>%2F2017%2F06%2F28%2FKotlin%E5%AD%A6%E4%B9%A0_%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[接下来学习Kotlin中的注解(Annotations)和类型别名(Type aliases)。 类型别名(Type aliases) 1.1版本类型别名为现有类型提供替代名称。如果类型名称太长，您可以引入不同的较短的名称，并使用新的名称。缩短长泛型类型：123typealias NodeSet = Set&lt;Network.Node&gt;typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt; 可以为功能类型提供不同的别名：123typealias MyHandler = (Int, String, Any) -&gt; Unittypealias Predicate&lt;T&gt; = (T) -&gt; Boolean 可以为内部和嵌套类创建新名称：123456789class A &#123; inner class Inner&#125;class B &#123; inner class Inner&#125;typealias AInner = A.Innertypealias BInner = B.Inner Kotlin中定义的类型别名 类型别名不会引入新类型，它们相当于相应的底层类型，在代码中添加了typealias Predicate &lt;T&gt;并使用Predicate&lt;Int&gt;时，Kotlin编译器始终将其扩展为(Int) -&gt; Boolean。因此，只要需要一般功能类型，就可以传递类型的变量，反之亦然：1234567891011121314typealias Predicate&lt;T&gt; = (T) -&gt; Boolean // 这里可以看出变量的类型是函数类型，参数是`T`，返回值是`Boolean`/*foo方法的返回值是Boolean，因为p的类型为Predicate&lt;Int&gt;，而Predicate&lt;Int&gt;是(Int) -&gt; Boolean。*/fun foo(p: Predicate&lt;Int&gt;) = p(42)fun main(args: Array&lt;String&gt;) &#123; val f: (Int) -&gt; Boolean = &#123; it &gt; 0 &#125; println(foo(f)) // prints "true" val p: Predicate&lt;Int&gt; = &#123; it &gt; 0 &#125; // 这里的Predicate&lt;Int&gt;等同于(Int) -&gt; Boolean println(listOf(1, -2).filter(p)) // prints "[1]"&#125; 注解声明(Annotation Declaration)与Java一样，Kotlin中也是有注解的，同样是用annotation关键字声明：1annotation class Fancy Kotlin同样可以通过元注解来自定义注解，在这里介绍下元注解： @Retention注解 指定该注解是否存储在编译后的Class文件中，以及它在运行时能否通过反射可见，有三个值，默认是AnnotationRetention.RUNTIME，分别为： AnnotationRetention.SOURCE：不存储在编译后的Class文件。 AnnotationRetention.BINARY：存储在编译后的Class文件，但是反射不可见。 AnnotationRetention.RUNTIME：存储在编译后的Class文件，反射可见。 @Target注解 表示该注解可以用于什么地方，类型有 AnnotationTarget.CLASS：类，接口或对象，注解类也包括在内。 AnnotationTarget.ANNOTATION_CLASS：只有注解类。 AnnotationTarget.TYPE_PARAMETER：Generic type parameter (unsupported yet)通用类型参数（还不支持）。 AnnotationTarget.PROPERTY：属性。 AnnotationTarget.FIELD：字段，包括属性的支持字段。 AnnotationTarget.LOCAL_VARIABLE：局部变量。 AnnotationTarget.VALUE_PARAMETER：函数或构造函数的值参数。 AnnotationTarget.CONSTRUCTOR：仅构造函数（主函数或者第二函数）。 AnnotationTarget.FUNCTION：方法（不包括构造函数）。 AnnotationTarget.PROPERTY_GETTER：只有属性的getter。 AnnotationTarget.PROPERTY_SETTER：只有属性的setter。 AnnotationTarget.TYPE：类型使用。 AnnotationTarget.EXPRESSION：任何表达式。 AnnotationTarget.FILE：文件。 AnnotationTarget.TYPEALIAS：@SinceKotlin(&quot;1.1&quot;)类型别名，Kotlin1.1已可用。 @Repeatable注解 表示允许在同一申明类型（类，属性，或方法）的多次使用同一个注解 @MustBeDocumented注解 决定了注解是公共API的一部分，因此应该包含在用于注解的元素的生成文档注解中。 实例这里声明一个Fancy注解：12345@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)@Retention(AnnotationRetention.SOURCE)@MustBeDocumentedannotation class Fancy 说明：Fancy注解可用在类，接口、对象、注解类、方法（不包括构造函数）、函数或构造函数的值参数和任何的表达式，不存储在编译后的Class文件，可用于生成文档中。 使用(Usage)12345@Fancy class Foo &#123; // 用在类上 @Fancy fun baz(@Fancy foo: Int): Int &#123; // 用在方法上，用在函数的值参数上 return (@Fancy 1) // 用在任意表达式上 &#125;&#125; 如果需要用到主构造函数上，就需要添加constructor关键字，并且在他之前添加注解：123class Foo @Inject constructor(dependency: MyDependency) &#123; // ...&#125; 注解属性访问器：1234class Foo &#123; var x: MyDependency? = null @Inject set&#125; 构造方法(Constructors)带参数构造函数的注解：123annotation class Special(val why: String)@Special("example") class Foo &#123;&#125; 参数类型可以有： 类型对应于Java原始类型（Int，Long等） 字符串 类（Foo::class） 枚举 其他注解 以上类型的数组 注解参数必须是nullable类型，因为JVM不支持将null作为注解属性的值存储。 如果注解被用作另一个注解的参数，它的名称不以@字符做为前缀：12345678annotation class ReplaceWith(val expression: String)annotation class Deprecated( val message: String, val replaceWith: ReplaceWith = ReplaceWith(""))@Deprecated("This function is deprecated, use === instead", ReplaceWith("this === other")) // 这里的ReplaceWith注解呗用作另一个注解的参数，则不需要加@符号 如果您需要将类指定为注解的参数，请使用Kotlin类（KClass）。Kotlin编译器将自动将其转换为Java类，以便Java代码能够正常看到注解和参数：12345import kotlin.reflect.KClassannotation class Ann(val arg1: KClass&lt;*&gt;, val arg2: KClass&lt;out Any?&gt;)@Ann(String::class, Int::class) class MyClass Lambda注解也可以用在lambda表达式中。123annotation class Suspendableval f = @Suspendable &#123; Fiber.sleep(10) &#125; 注解使用目标(Annotation Use-site Targets)当注解属性或主构造函数参数时，有多个Java元素是从相应的Kotlin元素生成的，因此生成的Java字节码中的多个注解位置，要指定应该如何精确地生成注解，使用以下语法：123class Example(@field:Ann val foo: String, // 标注 Java 字段 @get:Ann val bar: String, // 标注 Java getter @param:Ann val quux: String) // 标注 Java 构造函数参数 可以使用相同的语法来注解整个文件，但必须放在最上面，在包指令之前或在所有导入之前：123@file:JvmName("Foo")package org.jetbrains.demo 如果有一个使用目标(Use-site Targets)具有多个注解，可以添加方括号[]，并将所有注解放在括号中：1234class Example &#123; @set:[Inject VisibleForTesting] var collaborator: Collaborator&#125; 使用例子：123456annotation class Ann()annotation class Annn()class Example(@field:[Ann Annn] val foo: String) &#123; @set:[Ann Annn] var fsoo: String = ""&#125; 使用目标(Use-site Targets)支持的有： file property使用此目标的注解对Java不可见 field get 属性的getter set 属性的setter receiver 扩展函数或属性的接收器参数 param 构造函数参数 setparam 属性的setter的参数 delegate 该字段存储代理属性的代理实例 其中，要注解扩展函数的接收器参数，请使用以下语法：12annotation class Fancyfun @receiver:Fancy String.myExtension() &#123; &#125; 如果不指定使用目标(Use-site Targets)，则会根据所使用注解的@Target注解来选择目标。如果有多个适用目标，则使用以下列表中的第一个适用目标： param property field Java AnnotationsJava注解与Kotlin 100％兼容：1234567891011121314import org.junit.Testimport org.junit.Assert.*import org.junit.Ruleimport org.junit.rules.*class Tests &#123; // apply @Rule annotation to property getter @get:Rule val tempFolder = TemporaryFolder() @Test fun simple() &#123; val f = tempFolder.newFile() assertEquals(42, getTheAnswer()) &#125;&#125; 由于Java中编写的注解的参数顺序并没有定义，因此无法使用常规函数调用语法来传递参数，所以就需要使用命名参数语法：12345// Javapublic @interface Ann &#123; int intValue(); String stringValue();&#125; 在Kotlin中调用，使用命名参数：12// Kotlin@Ann(intValue = 1, stringValue = "abc") class C 与Java一样，默认的参数名为value，它的值可以被指定而没有明确的名称：1234// Javapublic @interface AnnWithValue &#123; String value();&#125; 参数名为默认值的时候，可以直接写值：12// Kotlin@AnnWithValue("abc") class C 如果value的参数类型为数组类型的时候，在Kotlin中必须使用vararg这个参数类型：1234// Javapublic @interface AnnWithArrayValue &#123; String[] value();&#125; 12// Kotlin@AnnWithArrayValue("abc", "foo", "bar") class C 如果参数名部位默认值并且为数组类型的时候：1234// Javapublic @interface AnnWithArrayMethod &#123; String[] names();&#125; 在Kotlin中必须使用arrayOf，并且使用命名参数：12// Kotlin@AnnWithArrayMethod(names = arrayOf("abc", "foo", "bar")) class C Java注解的实例的值可以做为Kotlin中的属性：1234// Javapublic @interface Ann &#123; int value();&#125; 1234// Kotlinfun foo(ann: Ann) &#123; val i = ann.value&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_设置默认值]]></title>
    <url>%2F2017%2F06%2F20%2FKotlin_learn_setDefaultValue%2F</url>
    <content type="text"><![CDATA[当我们调用一个为空的属性的时候，需要进行空的判断，那么如何避免这样？如何设置kotlin里面的默认值呢，比如函数参数的默认值，数据类的属性的默认值？ 首先有这样的代码： 123456data class User(val name: String?, val age: Int?)fun main(args: Array&lt;String&gt;) &#123; var user = User(null, 23) println(user.name?.let &#123; user.name &#125; ?: "jowan")&#125; 这样子写是不是很麻烦，那么这里我们可以将其写成一个方法，这样子调用的话就很方便了：12345678910data class User(val name: String?, val age: Int?)fun &lt;T&gt; T?.getDefault(default: T): T = this?.let &#123; this &#125; ?: defaultfun main(args: Array&lt;String&gt;) &#123; val (name, _) = User(null, 23) println(name.getDefault("jowan")) val (_, age2) = User("jowan", null) println(age2.getDefault(23))&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Default</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_集合（Collections）和范围（Ranges）]]></title>
    <url>%2F2017%2F06%2F19%2FKotlin%E5%AD%A6%E4%B9%A0_%E9%9B%86%E5%90%88%E5%92%8C%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[集合(Collections)Kotlin的集合类型和Java不一样，Kotlin的集合分为可变（读写）和不可变（只读）类型（lists, sets, maps, etc），可变类型是在不可变类型前面加Mutable： List&lt;out E&gt;和MutableList&lt;E&gt; Set&lt;out E&gt;和MutableSet&lt;E&gt; Map&lt;K, out V&gt;和MutableMap&lt;K, V&gt; 举个栗子：123456789val numbers: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)val readOnlyView: List&lt;Int&gt; = numbersprintln(numbers) // prints "[1, 2, 3]"numbers.add(4)println(readOnlyView) // prints "[1, 2, 3, 4]"// readOnlyView.clear() // 报错val strings = hashSetOf("a", "b", "c", "c")assert(strings.size == 3) 为什么加了Mutable前缀就是可变类型？ 我们先来看List，List实现了Collection接口，而MutableList实现的是List和MutableCollection接口 可以看出，MutableCollection接口实现了Collection接口，并且在里面添加了add和remove等操作方法，所以加了Mutable前缀就是可变类型，而没有的就是不可变类型。 创建集合Kotlin没有用于创建列表或集合的专用语法结构，只能使用标准库中的方法：listOf(), mutableListOf(), setOf(), mutableSetOf(),mapOf()等等。 12345678910111213// 等同于Java的List&lt;String&gt; list = new ArrayList();val list: List&lt;String&gt; = arrayListOf()val mutableList: MutableList&lt;String&gt; = mutableListOf()// 也可以这样写val list2 = mutableListOf&lt;String&gt;()val mutableList2 = mutableListOf&lt;String&gt;()// 等同于Java的Map&lt;String, String&gt; map = new HashMap();val map: Map&lt;String, String&gt; = mapOf()val mutableMap: MutableMap&lt;String, String&gt; = mutableMapOf()// 也可以这样写val map2 = mapOf&lt;String, String&gt;()val mutableMap2 = mutableMapOf&lt;String, String&gt;() 其中mapOf()可以简写成mapOf(a to b, c to d)1val map: Map&lt;Int, Int&gt; = mapOf(1 to 1, 2 to 2) 范围(Ranges)范围表达式由rangeTo函数形成，操作符形式为..，由in和!in进行连接，可以用于判断，也可用于循环当中：123if (i in 1..10) &#123; // i in 1..10 等同于1 &lt;= i &amp;&amp; i &lt;= 10 println(i) &#125; 为什么..能够替换rangeTo函数，这就涉及到运算符的重载了。 运算符重载 Kotlin提供了一些运算符，这些运算符有固定的符号表示形式（如+或-），运算符重载要在函数加operator关键字，在使用直接用运算符来替换函数，如..替换rangeTo函数：1234567if (i in 1..10) &#123; println(i) &#125;// 等同与if (i in 1.rangeTo(10)) &#123; println(i) &#125; 常见运算符如+、%、in、==等等，都是运算符重载。 前缀运算符 递增和递减 算术运算符 in和!in运算符 索引访问操作符 调用运算符 赋值(Augmented assignments) 注意：赋值在 Kotlin 中不是表达式。 等式运算符 注意：===和!==没有被重载 比较运算符针对Int类型，是去调用compareTo函数来比较 范围(Ranges)范围表达式由rangeTo函数形成，操作符形式为..，由in和!in进行连接，可以用于判断，也可用于循环当中：123if (i in 1..10) &#123; // i in 1..10 等同于1 &lt;= i &amp;&amp; i &lt;= 10 println(i) &#125; 简写1(1..10).forEach &#123; print(it) &#125; 为什么..能够替换rangeTo函数，这就涉及到运算符的重载了。 运算符重载 运算符重载要在函数加operator关键字， Ranges是如何运行的Ranges包含三种IntRange，LongRange，CharRange，都是实现了通用接口ClosedRange&lt;T&gt; ClosedRange&lt;T&gt;表示在数学意义上的闭区间，定义为可比较类型，具有两个端点start和endInclusive，以及包含的范围，用in和!in来进行操作。 Ranges在实现ClosedRange&lt;T&gt;的同时，也分别继承了相对应的运算进度类，如IntRange继承了IntProgression类，由first元素，last元素和不为零的step来定义，第一个元素是first元素，后面的元素是上一个元素加上step的结果。 Progression进度类是Iterable&lt;T&gt;的子类，T包括Int、Long 和 Char三种类型，这就是Ranges可以用于for循环和map/filter等函数。 在Progression进度类中，有个伴生对象里面的函数fromClosedRange用来构建进度。 总结下，..操作符创建一个实现了ClosedRange &lt;T&gt;和继承了*Progression的对象。例如IntRange实现了ClosedRange &lt;Int&gt;接口，并继承了IntProgression类，因此为IntProgression里面的所有操作都可用在IntRange。 常用函数Ranges的函数基本都是扩展函数。 rangeTo() 默认的rangeTo是正序的，如果将1..10改为10..1的话，上面的循环是不会执行的：123for (i in 10..1) &#123; println(i) // prints nothing&#125; 浮点数（Float和Double）不能使用rangeTo操作，而是使用提供的通用Comparable类型的标准库：1public operator fun &lt;T: Comparable&lt;T&gt;&gt; T.rangeTo(that: T): ClosedRange&lt;T&gt; 该方法不能用于循环迭代(for循环等等)。 downTo() downTo()在是扩展函数的同时，也是中缀函数，使用downTo()函数控制倒序输出：123for (i in 10 downTo 1) &#123; println(i) // 打印10987654321&#125; 简写1(10 downTo 1).forEach &#123; print(it) &#125; // 打印10987654321 step() step()也是中缀函数，默认间隔长度是1，如果要自定义间隔长度的话，就要使用step()函数：123for (i in 1..4 step 2) print(i) // 打印"13"for (i in 4 downTo 1 step 2) print(i) // 打印"42" 简写12(1..4 step 2).forEach &#123; print(it) &#125; // 打印"13"(4 downTo 1 step 2).forEach &#123; print(it) &#125; // 打印"42" until() until()也是中缀函数，要创建不包含其终端元素的范围，可以使用until()函数：123for (i in 1 until 10) &#123; // i in [1, 10), 打印123456789 println(i)&#125; 简写1(1 until 10).forEach &#123; print(it) &#125; // 打印123456789 reversed() reversed()函数，功能同单词，反向，由于reversed()并不是中缀函数，所以写法跟上面的那些不一样：12for (i in (1..4).reversed()) print(i) // print 4321 简写1(1..4).reversed().forEach &#123; print(it) &#125; // print 4321]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_获取变量类型]]></title>
    <url>%2F2017%2F06%2F17%2FKotlin_learn_getFieldType%2F</url>
    <content type="text"><![CDATA[如何在Kotlin文件上面获取变量的类型getJavaClass。 使用::class.java来获取变量类型，也可以用.javaClass来获取类型。1234567fun main(args: Array&lt;String&gt;) &#123; val i = "str" val classJava = i::class.java println(classJava) // 打印class java.lang.String val javaClass = i.javaClass println(javaClass) // 打印class java.lang.String&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>JavaClass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_函数、高级函数和Lambda表达式]]></title>
    <url>%2F2017%2F06%2F13%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[高阶函数，又称算子(运算符)或泛函，包含多于一个箭头的函数，高阶函数是至少满足下列一个条件的函数：1.接受一个或多个函数作为输入，2.输出一个函数。在无类型Lambda 演算，所有函数都是高阶的；在有类型Lambda 演算（大多数函数式编程语言都从中演化而来）中，高阶函数一般是那些函数型别包含多于一个箭头的函数。在函数式编程中，返回另一个函数的高阶函数被称为Curry化的函数。在很多函数式编程语言中能找到的 map 函数是高阶函数的一个例子。它接受一个函数 f 作为参数，并返回接受一个列表并应用 f 到它的每个元素的一个函数。 函数(Functions)Kotlin使用函数用fun表示123fun double(x: Int): Int &#123;&#125; 使用：1234// 一般调用val result = double(2)// 使用.调用Sample().foo() // 创建Sample类的实例,调用foo方法 参数(Parameters)和默认参数(Default Arguments)参数的定义与变量的定义一样，使用name: type，该类型称为Pascal表达式，每个参数必须有显示类型（手动设置类型），默认参数是后面加个=号。123fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size()) &#123; ...&#125; 重写方法的时候是可以把默认参数给替换掉的。 命名参数可以在调用函数时使用命名的函数参数。当一个函数有大量的参数或默认参数时这非常方便。如：123fun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: Char = ' ') &#123; println("str: $str, normalizeCase: Boolean = $normalizeCase, upperCaseFirstLetter: Boolean = $upperCaseFirstLetter, divideByCamelHumps: Boolean = $divideByCamelHumps, wordSeparator: Char = $wordSeparator")&#125; 调用默认参数的时候，是这样写的：1reformat(str) 如果把最后一个参数不设置默认参数，那在调用的时候1reformat(str, true, true, false, '_') 这样子就会很麻烦，每次都要把那些默认参数给写上，在这里就可以使用命名参数了：1reformat(str, wordSeparator = '_') // 与reformat(str, true, true, false, '_')是一样的 注意，在Java中是不能使用命名参数的 中缀符号(Infix notation)中缀表达式是操作符以中缀形式处于操作数的中间（例：3 + 4），先来看一下Kotlin中的中缀函数： 在mapOf()方法中的to就是个中缀函数：1val map: Map&lt;Int, Int&gt; = mapOf(1 to 1, 2 to 2) Range里面的downTo也是个中缀函数：1(10 downTo 1).forEach &#123; print(it) &#125; // 10987654321 使用中缀符号infix可以调用函数，但必须符合一些条件： 必须是成员方法或者扩展函数 函数只有一个参数 使用infix关键字表示 下面来写个中缀函数：123456789// 定义扩展函数infix fun Int.iInfix(x: Int): Int = this + xfun main(args: Array&lt;String&gt;) &#123; // 用中缀符号表示的扩展函数使用 println("2 iInfix 1:$&#123;2 iInfix 1&#125;") // 打印：2 iInfix 1:3 // 与下面是相同的 println("2.iInfix(1):$&#123;2.iInfix(1)&#125;") // 打印：2.iInfix(1):3&#125; 我们来看看编译的代码： 返回Unit的函数(Unit-returning functions)如果一个函数不返回值，即Java中的void，默认的返回类型就是Unit，默认不显示：1234567fun printHello(name: String?): Unit &#123; // Unit可以不显示 if (name != null) println("Hello $&#123;name&#125;") else println("Hi there!") // return Unit和 return是可选的&#125; 单表达式函数(Single-Expression functions)如果一个函数只有一个并且是表达式函数体并且是返回类型自动推断的话，这样的函数叫做当单表达式函数，这个在前面也有说过：12fun double(x: Int): Int = x * 2fun double(x: Int) = x * 2 // 这两个是一样的 可变参数(Variable number of arguments (Varargs))在Java中使用可变参数是这样写的：123private void getStr(String... params) &#123; ...&#125; 而在Kotlin中使用可变参数（通常是最后一个参数）的话，是用vararg关键字修饰的：123456fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // 在这里ts的类型是数组 result.add(t) return result&#125; 使用的时候与Java一样：1val list = asList(1, 2, 3) 当我们调用vararg函数，不仅可以接收可以一个接一个传递参数，例如asList(1, 2, 3)，也可以将一个数组传递进去，在数组变量前面加spread操作符，就是*号：12val a = arrayOf(1, 2, 3)val list = asList(-1, 0, *a, 4) // 表示(-1, 0, 1, 2, 3, 4) 函数使用范围(Function Scope)在前面说过Top-level，函数使用在与类同一级声明的，不需要再重新创建一个类来持有一个函数，称为Top-level函数。Kotlin中的函数除了Top-level函数外，还有局部函数、成员函数和前面说过的扩展函数。 局部函数Kotlin的局部函数是指一个函数在另一个函数中：123456789fun dfs(graph: Graph) &#123; fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) &#123; if (!visited.add(current)) return for (v in current.neighbors) dfs(v, visited) &#125; dfs(graph.vertices[0], HashSet())&#125; 局部函数可以访问外部函数的局部变量（即闭包），所以在上面的例子，visited可以是局部变量：12345678910fun dfs(graph: Graph) &#123; val visited = HashSet&lt;Vertex&gt;() fun dfs(current: Vertex) &#123; if (!visited.add(current)) return for (v in current.neighbors) dfs(v) &#125; dfs(graph.vertices[0])&#125; 成员函数(Member Functions)成员函数是定义在一个类或对象里：123class Sample() &#123; fun foo() &#123; print("Foo") &#125;&#125; 调用：1Sample().foo() 尾递归函数(Tail recursive functions)Kotlin支持称为尾递归的函数式编程风格，允许使用循环写入的一些算法而不是使用递归函数写入，同时没有堆栈溢出的风险。函数用tailrec修饰符标记并满足所需的形式时，编译器优化递归，快速和高效循环。下面用个递归函数来获取余弦的不动点(一个数学常数0.7390851332151607)在Java中使用递归是这样写的：1234567private double findFixPoint(double x = 1.0) &#123; if (x == Math.cos(x)) &#123; return x; &#125; else &#123; findFixPoint(Math.cos(x)); &#125;&#125; 改成Kotlin代码的话是这样的：12345678private fun findFixPoint(): Double &#123; var x = 1.0 while (true) &#123; val y = Math.cos(x) if (x == y) return y x = y &#125;&#125; 改成尾递归的话： 来看看编译后是什么样的： 要符合tailrec的条件的话，函数必须将其自身调用作为它执行的最后一个操作。如果在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前尾部递归只在 JVM 后端中支持。 高级函数与Lambdas表达式高级函数是将函数作为参数或返回一个函数，称为高阶函数。如lock()函数： 123456789fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T &#123; lock.lock() try &#123; return body() &#125; finally &#123; lock.unlock() &#125;&#125; lock函数的参数body是函数类型()-&gt;T，该body函数是一个没有参数，返回类型为T的函数。调用的时候可以使用函数引用(::)：123fun toBeSynchronized() = sharedResource.operation() val result = lock(lock, ::toBeSynchronized) 传递Lambdas调用：1val result = lock(lock, &#123; sharedResource.operation() &#125;) 在Kotlin中，若函数最后一个参数为函数类型，调用时，该参数可以放到函数的外面：123lock (lock) &#123; sharedResource.operation()&#125; 另一个例子是map()：123456fun &lt;T, R&gt; List&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123; val result = arrayListOf&lt;R&gt;() for (item in this) result.add(transform(item)) return result&#125; it：单个参数的隐式名称若函数参数对应的函数只有一个参数，在使用时，可以省略参数定义(连同-&gt;)，直接使用it代替参数：12val doubled = ints.map &#123; it -&gt; it * 2 &#125;ints.filter &#123; it &gt; 0 &#125; // it表示 '(it: Int) -&gt; Boolean' 这种方式可以写成LINQ-style代码：123strings.filter &#123; it.length == 5 &#125;.sortBy &#123; it &#125;.map &#123; it.toUpperCase() &#125; 函数引用(Function References)函数可以作为参数使用，当把一个函数当作一个值传递的时候，可以使用::操作符，将函数引用：1234fun isOdd(x: Int) = x % 2 != 0val numbers = listOf(1, 2, 3)println(numbers.filter(::isOdd)) // 输出 [1, 3] ::isOdd是函数类型(Int) -&gt; Boolean的一个值。 当上下文可以推导出函数的类型时，::用于重载函数：12345fun isOdd(x: Int) = x % 2 != 0fun isOdd(s: String) = s == "brillig" || s == "slithy" || s == "tove"val numbers = listOf(1, 2, 3)println(numbers.filter(::isOdd)) // 引用到 isOdd(x: Int) 也可以直接指定类型：1val predicate: (String) -&gt; Boolean = ::isOdd // 引用到 isOdd(x: String) 如果有一个函数有两个函数参数，返回的类型也是一个函数类型123fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123; return &#123; x -&gt; f(g(x)) &#125;&#125; 那么在引用的时候，会是怎么样的呢？123456789fun isOdd(x: Int) = x % 2 != 0 // (Int) -&gt; Booleanfun length(s: String) = s.length // (String) -&gt; Intfun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123; return &#123; x -&gt; f(g(x)) &#125;&#125;val oddLength = compose(::isOdd, ::length) // oddLength的类型是(String) -&gt; Boolean 下划线表示未使用的变量（1.1版开始）如果Lambda中有参数未使用，可以使用下划线代替参数名：1234567val map = mapOf(1 to 1, 2 to 2, 3 to 3)for ((key, value) in map) &#123; print("$value!") // 打印1!2!3!&#125;for ((_, value2) in map) &#123; print("$value2!") // 打印1!2!3!&#125; 我们来看看编译后的区别 可以看出，加了改成下划线后，不会去获取var2.getKey()).intValue()的值。 Lambda表达式和匿名函数(Lambda Expressions and Anonymous Functions) “Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。——来自百度百科 1max(strings, &#123; a, b -&gt; a.length &lt; b.length &#125;) 可以看出max是一个高阶函数，第二个参数是一个函数类型，等同于下面的函数：1fun compare(a: String, b: String): Boolean = a.length &lt; b.length 函数类型对于函数接受另一个函数作为参数，我们必须为该参数指定函数类型。如上面的max的定义：1234567fun &lt;T&gt; max(collection: Collection&lt;T&gt;, less: (T, T) -&gt; Boolean): T? &#123; var max: T? = null for (it in collection) if (max == null || less(max, it)) max = it return max&#125; 可以看出第二个参数less的类型是(T, T) -&gt; Boolean，即以T和T为参数，返回值为Boolean类型的函数。如果要定义每个参数的变量名，可以这样写：1val compare: (x: T, y: T) -&gt; Int = ... 语法一个Lambda表达式通常使用{ }包围，参数是定义在()内，可以添加类型注解，实体部分跟在“-&gt;”后面；如果Lambda的推断返回类型不是Unit，那么Lambda主体中的最后一个（或单个）表达式将被视为返回值。一个最普通的Lambda表达：1val sum: (Int, Int) -&gt; Int = &#123; x, y -&gt; x + y &#125; 使用return标签时，可以隐式返回最后一个表达式的值：12345678910// 下面两个是等效的ints.filter &#123; val shouldFilter = it &gt; 0 shouldFilter&#125;ints.filter &#123; val shouldFilter = it &gt; 0 return@filter shouldFilter&#125; 如果函数接受另一个函数作为最后一个参数，那么lambda表达式参数可以在()参数列表外部传递。12345// 下面两个是等效的lock(lock, &#123; sharedResource.operation() &#125;)lock (lock) &#123; sharedResource.operation()&#125; 匿名函数(Anonymous Functions)Lambda表示在定义时，可以明确定义返回值类型；但是在大部分情况下，没有必要明确定义的，因为返回值类型都可以自动推断出。如果需要明确定义返回值类型，可以使用匿名函数代替：1fun(x: Int, y: Int): Int = x + y 匿名函数除了省略了函数名称，其他跟一般函数的定义基本类似，函数体可以是一个表达式或一个代码块：123fun(x: Int, y: Int): Int &#123; return x + y&#125; 若参数类型可以通过上下文推断出来，也可以省略：1ints.filter(fun(item) = item &gt; 0) 匿名函数的返回类型跟一般函数一样：对应只有一行执行代码的函数，编译器可以自动推断出来返回类型，可以省略；对应多方代码块的函数，需要显示定义返回值类型（为Unit可以省略）。 Lambdas与匿名函数的区别 匿名函数作为参数，一般定义在()中；而Lambda表达式可以定义到调用函数()外。 另外区别在非局部返回(non-local returns)行为上：非标签注解的return（返回对应的最内层的函数（即fun），在匿名函数中，退出该匿名函数；而在Lambda表达中，退出包含该表达式的函数。 下面举个例子来区分1234567891011121314151617181920212223242526fun lambdaReturn() &#123; val list = asList(1, 2, 3, 4) loge("test", list.toString()) val lambdaList = list.map &#123; it * 2 return &#125; loge("test", lambdaList.toString())&#125;fun anonymousReturn() &#123; val list = asList(1, 2, 3, 4) loge("test", list.toString()) val lambdaList = list.map(fun(it: Int): Int &#123; return it * 2 &#125;) loge("test", lambdaList.toString())&#125;fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // 可变参数ts是数组 result.add(t) return result&#125; 在调用lambdaReturn()函数的时候会打印： 而在调用anonymousReturn()函数的时候会打印： 这里也就证明了，在Lambdas表达式中return会返回到外层的函数中，而在匿名函数中return会返回的匿名函数的外层函数中。 闭包(Closures) 闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。——来自百度百科 Lambda表达式及匿名函数（以及局部函数，对象表达式）可以访问包含它的外部范围定义的变量（Java中只能是常量，在Kotlin中可以是变量）：1234567var sum = 0ints.filter &#123; it &gt; 0&#125;.forEach &#123; sum += it&#125;print(sum) 事实上函数、Lambda、if语句、for循环、when语句等都是闭包，但通常情况下，我们所说的闭包是 Lambda 表达式。闭包可以在定义的时候直接执行闭包操作，这种闭包一般用在初始化操作上：123&#123; x: Int, y: Int, z: String -&gt; println("$&#123;x + y&#125;_ $z")&#125;(4, 5, "test") 像我们写构造函数的时候，主构造函数不包含任何代码，初始化代码必须写在init代码块中，而init的代码块就是闭包： 属性里面的setter也是闭包： 在build.gradle里面都是闭包： 带接收者的函数字面值(Function Literals with Receiver)Kotlin提供了使用指定的接收者对象调用文本函数的功能，这就是文本扩展函数。在文本函数中，可以调用接收者对象上的方法。类似于扩展函数，可以调用方法内的接收者对象的成员1val sum : Int.(other: Int) -&gt; Int = &#123; it + 1 &#125; sum的类型是Int.(one: Int) -&gt; Int，传入一个Int类型的值，返回Int类型，在闭包里面返回值。 调用的时候与扩展函数一样：1val a = 1.sum(2) // a的值为3 如果用个匿名函数的话，可以直接指定函数文本的接收者类型：12345val sums = fun Int.(other: Int): Int &#123; println(this) println(this + other) return this + other&#125; 调用110.sums(10) 打印结果 上面两个的sum和sums的区别： Lambda表达式：123456789101112class HTML &#123; fun body(one: Int) &#123; println("body$one") &#125;&#125;fun html(init: HTML.() -&gt; Unit): HTML &#123; val html = HTML() // 创建接收器对象 html.init() // 将接收器对象传递给lambda // 等同于init(html) return html&#125; 使用的时候，可以先声明一个HTML.() -&gt; Unit类型，然后调用html方法12345val init: HTML.() -&gt; Unit = &#123; body(1)&#125;// 因为html方法返回的是一个HTML类型，所以可以在后面直接使用body方法html(init).body(2) 简化123html &#123; body() &#125;.body()]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战_实现RecyclerView多种Item布局]]></title>
    <url>%2F2017%2F06%2F09%2FKotlin%E5%AE%9E%E6%88%98_%E5%AE%9E%E7%8E%B0RecyclerView%E5%A4%9A%E7%A7%8DItem%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言RecyclerView出来很久了，可以说一出来就将ListView给比下去了，当然，Recyclerview有它的好，ListView的好，并不是说一定要用Recyclerview，最适用自己项目的才是最好的。 在这里我们将用Kotlin来实现RecyclerView的多种item布局，和单个item布局，同时写一个通用的Adapter。 使用先将写完的代码的使用方式展示一下： 一种item布局123456class SingleItemAdapter(mContext: Context, mDatas: List&lt;TestBean&gt;) : DelegateItemAdapter&lt;TestBean&gt;(mContext, mDatas) &#123; init &#123; addItemViewDelegate(SingleItemDelegate()) &#125;&#125; 效果图 多种item布局12345678class MultiItemAdapter(mContext: Context, mDatas: List&lt;TestBean&gt;) : DelegateItemAdapter&lt;TestBean&gt;(mContext, mDatas) &#123; init &#123; addItemViewDelegate(LeftDelegate()) addItemViewDelegate(CenterDelegate()) addItemViewDelegate(RightDelegate()) &#125;&#125; 效果图 梳理总体流程是这样的，首先创建itemView，在里面设置layoutId和数据处理，然后创建一个类继承DelegateItemAdapter，并在主构造方法里面添加不同的itemView，然后Adapter通过DelegateManager类来管理对应的itemView进行操作。 ItemView我们的itemView是实现DelegateType接口，然后在里面设置相对应的layoutId，对数据进行操作处理：123456789101112131415class SingleItemDelegate : DelegateType&lt;TestBean&gt; &#123; override val itemViewLayoutId: Int get() = R.layout.item_left override fun isItemViewType(item: TestBean, position: Int): Boolean = true override fun convert(context: Context, holder: ViewHolder, item: TestBean, position: Int) &#123; with(holder.itemView) &#123; item_left_text.text = item.text setOnClickListener &#123; context.toast("SingleItemDelegate") &#125; &#125; &#125;&#125; ViewHolder在使用Recyclerview的时候，必须有ViewHolder，通常情况下，我们需要写一个通用的ViewHolder，但是在Kotlin中的话，就不需要那样写，因为Kotlin可以直接将布局的id来当成变量使用，所以我们需要写一个ViewHolder类来继承Recyclerview里面的Viewholder类。 使用id当变量的话，要在app下面的build.gradle里面加个plugin: &#39;kotlin-android-extensions&#39; 1234567891011121314151617181920212223242526272829303132class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; companion object &#123; /** * 创建ViewHolder * * @param itemView itemView * @return ViewHolder */ fun createViewHolder(itemView: View): ViewHolder &#123; val holder = ViewHolder(itemView) return holder &#125; /** * 创建ViewHolder * * @param context Context * @param parent ViewGroup * @param layoutId layoutId * @return ViewHolder */ fun createViewHolder(context: Context, parent: ViewGroup, layoutId: Int): ViewHolder &#123; val itemView = LayoutInflater.from(context).inflate(layoutId, parent, false) val holder = ViewHolder(itemView) return holder &#125; &#125;&#125; 这样子ViewHolder就搞定了，不需要在写那些设置text、image、绑定事件相关的代码了。 Adapter那么我们改如何区分多种itemView呢，在这里我们引用了一个接口：12345678910111213141516171819202122232425262728/** * itemView属性 */interface DelegateType&lt;in T&gt; &#123; // 由于T只是作为参数，所以T是contravariant逆变，加in /** * 获取layoutId */ val itemViewLayoutId: Int /** * 判断类型 * * @param item data数据 * @param position 当前position * @return true显示数据 */ fun isItemViewType(item: T, position: Int): Boolean /** * 显示数据 * * @param context Context * @param holder ViewHolder * @param item data数据 * @param position 当前position */ fun convert(context: Context, holder: ViewHolder, item: T, position: Int)&#125; 根据layoutId来创建对应的ViewHolder，并且通过isItemViewType方法来匹配是否是当前itemView类型，然后通过convert来显示数据。 Adapter是继承Recyclerview里面的Adapter，传入ViewHolder，传入泛型数据集，那么我们可以通过传入的数据集里面的类型来判断不同的itemView，在这里需要重写几个方法： getItemViewType方法根据数据来返回不同类型：123456789/** * 获取itemView类型 * * @param position 当前position */override fun getItemViewType(position: Int): Int = if (!useItemViewDelegateManager()) super.getItemViewType(position)else mDelegateManager.getItemViewType(mDatas[position], position) onCreateViewHolder方法根据mDelegateManager.getItemViewDelegate(viewType).itemViewLayoutId返回的layoutId来生成对应的ViewHolder1override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder = ViewHolder.createViewHolder(mContext, parent, mDelegateManager.getItemViewDelegate(viewType).itemViewLayoutId) onBindViewHolder方法用于数据处理和显示：1override fun onBindViewHolder(holder: ViewHolder, position: Int) = convert(holder, mDatas[position]) 上面的mDelegateManager是管理itemView的类，可以添加删除itemView，并且显示数据：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*** 获取itemView的类型** @param item data数据* @param position 当前position* @return Int*/fun getItemViewType(item: T, position: Int): Int &#123; (0.. delegateCount - 1) .filter &#123; mDelegates.valueAt(it).isItemViewType(item, position) &#125; .forEach &#123; return mDelegates.keyAt(it) &#125; throw IllegalArgumentException( "No ItemViewDelegate added that matches position = $position in data = $item source");&#125;/*** 显示数据** @param context Context* @param holder ViewHolder* @param item data数据* @param position 当前position*/fun convert(context: Context, holder: ViewHolder, item: T, position: Int) &#123; for (i in 0..delegateCount - 1) &#123; val delegate = mDelegates.valueAt(i) if (delegate.isItemViewType(item, position)) &#123; delegate.convert(context, holder, item, position); return@convert &#125; &#125; throw IllegalArgumentException( "No ItemViewDelegateManager added that matches position= $position in data = $item source")&#125;/*** 添加itemView** @param delegate itemView* @throws IllegalArgumentException 已存在不能再添加* @return DelegateManager*/fun addDelegate(delegate: DelegateType&lt;T&gt;): DelegateManager&lt;T&gt; &#123; for (i in 0..delegateCount - 1) &#123; if (mDelegates.valueAt(i).itemViewLayoutId == delegate.itemViewLayoutId) &#123; throw IllegalArgumentException("An ItemViewDelegate is already registered for the delegate = $delegate.") &#125; &#125; mDelegates.put(mDelegates.size(), delegate) return this&#125;/*** 添加itemView** @param viewType 代表itemView的下标* @param delegate itemView* @throws IllegalArgumentException 已存在不能再添加* @return DelegateManager*/fun addDelegate(viewType: Int, delegate: DelegateType&lt;T&gt;): DelegateManager&lt;T&gt; &#123; if (mDelegates.get(viewType) != null) &#123; throw IllegalArgumentException("An ItemViewDelegate is already registered for the viewType = $viewType. Already registered ItemViewDelegate is $&#123;mDelegates.get(viewType)&#125;") &#125; mDelegates.put(viewType, delegate) return this&#125;/** * 获取itemView * * @param viewType 代表itemView的下标 * @return DelegateType */fun getItemViewDelegate(viewType: Int): DelegateType&lt;T&gt; = mDelegates.get(viewType)/** * 获取itemView的LayoutId * * @param viewType 代表itemView的下标 * @return Int*/fun getItemViewLayoutId(viewType: Int): Int = getItemViewDelegate(viewType).itemViewLayoutId/*** 获取itemView的类型** @param delegate itemView* @return Int*/fun getItemViewType(delegate: DelegateType&lt;T&gt;): Int = mDelegates.indexOfValue(delegate) 通过使用addDelegate方法添加itemView，然后通过getItemViewType方法来获取itemView的类型，最后通过convert方法来进行数据操作和显示，这样子我们的Adapter就写出来了。 总结每次写Recyclerview的时候都要重复写这些Adapter，ViewHolder的代码，这里将它写成通用的，可以省去很多的时间。 注意：项目是在3.0版本的Android Studio上运行。 源码：Github，欢迎star。 参考：为RecyclerView打造通用Adapter 让RecyclerView更加好用]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_泛型（Generics）]]></title>
    <url>%2F2017%2F05%2F31%2FKotlin%E5%AD%A6%E4%B9%A0_%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型，即“参数化类型”，顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 接下来学习Kotlin中的泛型，Kotlin的泛型为类型安全提供保证，相比与Java更安全。 泛型在Java中经常会用到泛型：12345class Box&lt;T&gt;&#123; private T var ; &#125;// 使用Box&lt;String&gt; box = new Box&lt;String&gt;(); 与Java一样，Kotlin中也用到了泛型：12345class Box&lt;T&gt;(t: T) &#123; var value = t&#125;// 使用val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1) 与Java不一样的是，Kotlin在可以推断出参数的情况下，如在构造函数参数上推测出等等，可是省去类型，如上面创建的实例传入的1是Int类型：1val box = Box(1) 而在Java中是不能这样做。 变异(Variance)在这里我们先来了解下Java泛型中的通配符，在Effective Java中Item 28中写到: Use bounded wildcards to increase API flexibility，意思是使用通配符为了提高API的使用灵活性。Java中使用?来表示通配符：12345678910public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; Object[] array = list.toArray(); Arrays.sort(array); int i = 0; ListIterator&lt;T&gt; it = list.listIterator(); while (it.hasNext()) &#123; it.next(); it.set((T) array[i++]); &#125;&#125; 在Java中，泛型是不可变的，如List&lt;String&gt;不是List&lt;Object&gt;的子类：12List&lt;String&gt; strs = new ArrayList&lt;String&gt;();List&lt;Object&gt; objs = strs; // 这是错误的，类型不匹配 如果上面的操作是正确的，那么会在使用时造成类型不匹配的问题：12objs.add(1); // 添加一个int类型到String的List里面String s = strs.get(0); // 会报ClassCastException: Cannot cast Integer to String的错误 所以Java的泛型会被设计成不可变的类型，就是为了确保运行时类型安全，但是这样同样会带来一些影响。举个例子，定义一个泛型接口Collection，里面有addAll()方法：123interface Collection&lt;E&gt; ... &#123; void addAll(Collection&lt;E&gt; items);&#125; 由于Java的泛型是不可变的，所以下面的代码是做不到的：123void copyAll(Collection&lt;Object&gt; to, Collection&lt;String&gt; from) &#123; to.addAll(from); // 这是错误的，Collection&lt;String&gt;不是Collection&lt;Object&gt;的子类&#125; 为了解决上面的问题，Java中使用了类型通配符方式，如? extends T表示T及T的子类参数都可以使用，所以Collection的addAll()方法是这样写的：123interface Collection&lt;E&gt; ... &#123; void addAll(Collection&lt;? extends E&gt; items);&#125; 同样的原理，在上面的代码可以改成这样：1234List&lt;String&gt; strs = new ArrayList&lt;String&gt;();strs.add("0");objs.add("1"); List&lt;? extends Object&gt; objs = strs; // OK PECSPECS stands for Producer-Extends,Consumer-Super，具体的可以参考PECS。 通配符上界，只能从中读取元素，不能添加元素，称为生产者(Producers)，用&lt;? extends T&gt;表示。 通配符下界，只能添加元素，不能直接读取下界类型的元素，称为消费者(Consumers)，用&lt;? super T&gt;表示。 通配符上界&lt;? extends T&gt;(T表示通配符的上界)，表示可以接收T以及T的子类参数，也就是说可以安全的读取到T的实例，事实上所有的集合元素都是T的子类的实例，但不能向其添加元素，因为没法确定添加的实例类型跟定义的类型是否匹配，举个栗子：123456List&lt;String&gt; strs = new ArrayList&lt;String&gt;();strs.add("0");strs.add("1");List&lt;? extends Object&gt; objs = strs;// 上面说过这样是可以objs.get(0); // 可以获取 12// 但是再添加一个int类型的话objs.add(1); // 报错 12// 再添加一个String类型objs.add("1"); // 同样会报错 上面的例子说明了objs可以读取值，但是再往objs里面添加值的时候，就会出错，没法确定添加的实例类型跟定义的类型是否匹配。 这种wildcard是通过继承一个范围类(extends-bound)，也就是通配符上界(upper bound)来实现类型协变。 通配符下界那么有通配符上界&lt;? extends T&gt;，自然就会有下界，&lt;? super T&gt;，其中T就表示通配符的下界。举个栗子：Collection&lt;? super String&gt;是Collection&lt;String&gt;的父类型，所以可以直接add和set，但是get的时候获取到的类型是Object而不是String类型。1234567List&lt;String&gt; strs = new ArrayList&lt;String&gt;();strs.add("0");strs.add("1");List&lt;? super String&gt; objs = strs;objs.add("1");objs.set(0, "2");Object s = objs.get(0); 在Kotlin中，并没有上面的机制，而是通过Declaration-site variance和Type projections来执行的。 声明位置变异(Declaration-site variance)声明位置变异：通过将参数T注解成只能作为返回值，不能作为传入参数；使用out关键字标识。首先我们来看一下，在Java中，12345678interface Source&lt;T&gt; &#123; public T nextT();&#125;public void demo(Source&lt;String&gt; strs)&#123; Source&lt;Object&gt; objs = strs; // 在Java中是不允许的 // 正确方式为 // Source&lt;? extends Object&gt; objs = strs;&#125; 在Kotlin中，使用声明位置变异来解决这种问题：12345678910abstract class Source&lt;out T&gt; &#123; // 使用out的话，T只能作为返回值 abstract fun nextT(): T // 不能作为传入参数，下面会报错 // abstract fun add(value: T)&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs&#125; 有out就有in，in与out互补，它使类型参数逆变contravariant，只能作为传入参数，不能作为返回值：123456789abstract class Source&lt;in T&gt; &#123; // 使用in的话，只能作为传入参数，不能作为返回值 // abstract fun nextT(): T abstract fun add(value: T)&#125;fun demo(strs: Source&lt;Number&gt;) &#123; val objects: Source&lt;Double&gt; = strs // Double是Number的子类型&#125; 总结一下，当一个泛型类C，包含out关键字的时候，等同于Java的extends，将类C称为T的协变类，T只能作为该类中函数的返回类型，不能作为参数传递进来，也可以称类C为T的生产者(Producer)。 同理，当包含in关键字的时候，等同于Java的super，将类C称为T的逆变类，T只能作为该类中函数的参数传递进来，不能作为返回类型，也可以称类C为T的消费者(Consumer)。 可以将上面两段话总结成： Consumer in, Producer out! 1234567fun copy(from: Array&lt;out String&gt;, to: Array&lt;in String&gt;) &#123; assert(from.size == to.size) for (i in from.indices) to[i] = from[i]&#125;// 等同于public void copy(List&lt;? extends String&gt; from, List&lt;? super String&gt; to) &#123; ... &#125; Star-projections在Kotlin中，定义一个该泛型类型的推测projection类型，使泛型类型的每一个具体实例应该是推测projection类型的子类型，称之为Star-projections，语法为： 对于Foo&lt;out T&gt;：T是一个协变类型参数，可以知道Foo&lt;*&gt;是与之相等的，当T不可知时，可以安全的读取到T，可以通过Foo&lt;*&gt;得到T。 对于Foo&lt;In T&gt;：T是一个逆变类型参数，可以知道Foo&lt;*&gt;等同于Foo&lt;in Nothing&gt;，当T不可知时，不能在Foo&lt;*&gt;里面添加元素。 对于Foo&lt;T&gt;：T是一个不变类型参数，当从中读取数据时Foo&lt;*&gt;同等于Foo&lt;out T&gt;；当向其添加数据时，Foo&lt;*&gt;等同于Foo&lt;in Nothing&gt;。 举个栗子，一个泛型定义interface Function&lt;in T, out U&gt;： Function&lt;*, String&gt;等同于什么？等同于Function&lt;in Nothing, String&gt; Function&lt;Int, *&gt;等同于什么？等同于Function&lt;Int, out Any?&gt; Function&lt;*, *&gt;等同于什么？等同于Function&lt;in Nothing, out Any?&gt; 泛型函数(Generic functions)Kotlin同样支持泛型函数：1234567fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123; // ...&#125;fun &lt;T&gt; T.basicToString() : String &#123; // extension function // ...&#125; 使用的时候，在函数名称后面指定具体的类型参数：1val l = singletonList&lt;Int&gt;(1) 泛型约束(Generic constraints)Upper boundsKotlin的泛型约束和类的继承一样，使用:代替extends对泛型的的类型上界进行约束：1class SwipeRefreshableView&lt;T : View&gt;&#123;&#125; 同时Kotlin支持多个类型的上界约束，使用where关键字：1234class SwipeRefreshableView&lt;T&gt; where T : View, T : Refreshable &#123;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Generics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_可见性修饰符和数据类]]></title>
    <url>%2F2017%2F05%2F30%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java中有可见性修饰符(private…)，而Kotlin中也是有这样的修饰符，但也有一些不一样，下面来学习Kotlin中的可见性修饰符(Visibility Modifiers)和数据类(Data Classes)的相关知识。 可见性修饰符(Visibility Modifiers)Kotlin有四种可见性修饰符，分别是public、internal、protected和private，默认的修饰符是public，除了internal之外，其他三种修饰符与Java的访问权限一样。 Kotlin的可见性除了用于类，对象，接口，构造函数，属性之外，还用于属性的setter方法(getter的可见性是由属性的可见性决定的)。 属性可见性修饰12345678910// 文件名: example.ktpackage fooprivate fun foo() &#123;&#125; // 在example.kt中可见public var bar: Int = 5 // 任何地方都可见// 因为get的可见性是由属性决定的，所有这里的get的可见性为public private set // setter在example.kt中可见internal val baz = 6 // 在模块中可见 注意：protected在Top-level中不可以使用 private修饰的属性是不会自动生成get和set方法的 在Kotlin中可以使用使用属性名来直接获取值和设置值的，原因就是Kotlin会自动生成属性的get和set方法 但是，如果如果设置属性的可见性是private的话，我们知道private修饰的是私有的，也就是当前类可用，那么就不会自动生成get和set方法了，不能给外部访问。 类和接口的可见性修饰123456789101112131415161718192021222324open class Outer &#123; private val a = 1 // 在Outer类中可见 protected open val b = 2 // 在Outer类和子类中可见 internal val c = 3 // 在模块中可见 val d = 4 // 默认为public protected class Nested &#123; public val e: Int = 5 &#125;&#125;class Subclass : Outer() &#123; // a不可见 // b,c和d可见 // Nested类和e可见 override val b = 5 // 重写后的b依然是protected&#125;class Unrelated(o: Outer) &#123; // o.a和o.b不可见 // o.d可见，在相同模块下o.c可见 // Outer.Nested不可见, Nested::e也是不可见&#125; 注意：外部类不可以访问内部类的private成员。 构造函数同样可以设置可见性，前面说过，在设置主构造函数的可见性或者注解的时候，要加上constructor关键字。1class C @Inject private constructor(a: Int) &#123; ... &#125; Kotlin中局部变量，函数和类是不允许使用修饰符的。 模块(Modules)internal权限是是模块级别的访问权限，可以访问本模块的internal变量和方法，当跨模块的时候就无法访问另一个模块的internal变量或方法。 数据类(Data Classes)前面说过（Kotlin学习（五）: 惯用语法和代码风格），Kotlin的惯用语法是有写POJO类，一般写那种类都是用data修饰的类，也就是数据类表示，只保存数据的类。1data class User(val name: String, val age: Int) 编译器自动从主构造函数中声明的所有属性生成以下方法 可以看出有 getter和setter方法，还有componentN()函数，对应按声明顺序出现的所有属性，如name就是component1()，age就是component2()。 当然还有 equals()、hashCode()、和 toString()（输出的格式为User(name=..., age=...)），为什么生成的class文件中没有这三个类，但是又可以直接调用呢？ Any类是Kotlin每个类的超类，所以自然可以调用这几个方法。 为了确保数据类生成的代码的一致性和有意义，必须满足 如果构造函数参数中没有声明是val或者var，这些函数就不会生成 主构造函数需要有至少一个参数 数据类不能有abstract、open、sealed和inner修饰 在1.1版本之前，数据类只能实现接口 在构造函数那里也说过，如果生成的类需要一个无参数的构造函数，则必须指定所有属性的默认值 1data class User(var name: String = "", var age: Int = 0) 复制(copying)数据类在创建的时候，除了会生成上面的几个方法外，还会生成一个copy ()函数，copy()能够复制一个对象改变它的一些属性情况下，又要保持其余的不变，如上面的User类，copy()函数的实现：1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 在使用copy()之后，就可以修改数据类的一些属性了：12val jack = User(name = "jack", age = 1)val olderJack = jack.copy(age = 2) Kotlin提供了Pair和Triple作为标准数据类，命名数据类是更好的设计选择。两个参数的时候使用Pair数据类 三个参数的时候使用Triple数据类]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_扩展（Extensions）和This表达式]]></title>
    <url>%2F2017%2F05%2F27%2FKotlin%E5%AD%A6%E4%B9%A0_%E6%89%A9%E5%B1%95%E5%92%8CThis%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[扩展是Kotlin中特别强大的一个功能，如扩展函数，本文是学习Kotlin中的扩展(Extensions)和This表达式的相关知识。 扩展(Extensions)在Java开发时，会经常将那些共用的方法写到一个Utils类，如FileUtils,StringUtils等等。很有名的java.util.Collections也是其中一员的，在使用的时候1Collections.swap(list, Collections.binarySearch(list, Collections.max(otherList)), Collections.max(list)) Kotlin中提供了一种可以在不继承父类，也不使用类似Decorator这样的设计模式的情况下对指定类进行扩展，在Kotlin中称为扩展的特殊声明，支持函数扩展和属性扩展。如上面的可以写成1list.swap(list.binarySearch(otherList.max()), list.max()) 比如要将Toast写成可以直接调用toast(this, &quot;toast&quot;)123fun Context.toast(context: Context, content: String) &#123; Toast.makeText(context, content, Toast.LENGTH_SHORT).show()&#125; 扩展函数(Extension Functions)要声明一个扩展函数，我们需要在函数的名称前加上一个接收者类型并且加上.符号12345678/*** MutableList&lt;Int&gt; 添加一个 swap() 扩展函数*/fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // this对应list this[index1] = this[index2] this[index2] = tmp&#125; 在扩展函数中的this关键字表示接收者对象，下面会讲到this表达式，在这里的this对应MutableList&lt;Int&gt;类型的对象。12val l = mutableListOf(1, 2, 3)l.swap(0, 2) // 在 `swap()` 函数中 `this` 持有的值是 `l` 如果要改成对任意类型MutableList&lt;T&gt;都适用12345fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] this[index1] = this[index2] this[index2] = tmp&#125; 像在集合Collections里面就可以找到很多的扩展函数： 扩展是静态解析(Extensions are resolved statically)由于Kotlin的扩展是静态解析的，所以在定义了一个扩展函数之后，并不会给这个类添加方法，而是让这个方法能够被这个类的实例对象通过.来调用。举例1234567891011open class Cclass D: C()fun C.foo() = "c"fun D.foo() = "d"fun printFoo(c: C) &#123; println(c.foo())&#125; 在调用printFoo(D())的话会打印c还是d，答案是打印c，因为在定义扩展函数的时候接收对象类型是C类，而且Kotlin的扩展是静态解析的，所以即使调用的时候是传了C类的子类D类进去，还是会执行定义的时候的类型的函数。 那如果类中有个函数foo()，然后在写个扩展函数C.foo()，这时候如果调用的话，是调用哪个函数呢？12345class C &#123; fun foo() &#123; println("member") &#125;&#125;fun C.foo() &#123; println("extension") &#125; 答案是调用类的成员函数，如果有同名同参数的成员函数和扩展函数，调用的时候必然会使用成员函数，所以这里会打印member 扩展函数完全可以重载具有相同名称但不同参数的成员函数12345class C &#123; fun foo() &#123; println("number") &#125;&#125;fun C.foo(i:Int) &#123; println("extention") &#125; 总结一下，如果扩展函数和成员函数同名同参数，则成员函数优先级高于扩展函数。 可空接收者(Nullable Receiver)Kotlin的扩展支持接收者对象为空，举个例子，在调用字符串的toString()函数的时候，如果字符串为null的话会报空指针异常，这里可以改成扩展函数，里面将传进来的字符串进行this == null判断，就可以在 Kotlin 中任意调用toString()函数而不进行空指针检查。12345fun Any?.toString(): String &#123; if (this == null) return "null" // 在空检查之后，`this` 被自动转为非空类型，因此 toString() 可以被解析到任何类的成员函数中 return toString()&#125; 属性扩展(Extension Properties)与函数类似，Kotlin支持扩展属性12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 前面说过，Kotlin是静态解析扩展的，所以扩展属性不会有备用字段，这也是为什么初始化函数不允许有扩展属性，扩展属性只能够通过明确提供getter和setter函数来进行定义。1val Foo.bar = 1 // 错误: 初始化函数不允许有扩展属性 伴生对象扩展(Companion Object Extensions)如果一个类有伴生对象，同样可以为伴随对象定义扩展函数和属性1234567class MyClass &#123; companion object &#123; &#125; &#125;fun MyClass.Companion.foo() &#123; // ...&#125; 调用的时候1MyClass.foo() 扩展的范围在前面说过Top-level是与类同级的，大多数情况下，扩展也可以在Top-level层级定义。12package foo.barfun Baz.goo() &#123; ... &#125; 在使用的时候与一般类使用一样，要import导入包。123456789package com.example,usageimport foo.bar.goo // 导入所有名字叫 "goo" 的扩展// 或者import foo.bar.* // 导入foo.bar包下得所有数据fun usage(baz: Baz) &#123; baz.goo()&#125; This表达式(This Expression)上面说了，在扩展函数中的this关键字对应接收者对象，this表示当前接收者，用到了this表达式。 在类的成员中，this表示当前类的对象 在扩展函数或带接收者的文本函数中，this在.的左边，表示接收者参数 This表达式的限制(Qualified this)为了在范围外部(类、扩展函数、带接收者的文本函数访问this，需要使用到@label，在前面也说过return到标签(@label)，这里用this@label表示12345678910111213141516171819class A &#123; // 默认有@A标签 // this表示A val aThis = this inner class B &#123; // 默认有@B标签 // this表示B val bThis = this fun Int.foo() &#123; // 默认有@foo标签 // 表示A val a = this@A // 表示B val b = this@B // this表示带接收者为Int的文本函数foo() val c = this // 表示带接收者为Int的文本函数foo() val c1 = this@foo &#125; &#125;&#125; 将下面的代码运行，会打印出什么呢？ 运行的结果为：]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_对象表达式和声明（Object Expressions and Declarations）]]></title>
    <url>%2F2017%2F05%2F23%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[2017年的Google I/O大会上谷歌宣布Kotlin正式成为Android的官方语言。 下面我们来继续学习Kotlin中的对象表达式和声明(Object Expressions and Declarations)的相关知识。 对象表达式和声明(Object Expressions and Declarations)在写代码的时候，会创建一个对当前类做轻微修改的对象，而不用重新声明一个子类，Kotlin 中用对象表达式和声明来解决这个问题。 对象表达式(Object expressions)在Android里面，我们对一些点击事件的监听的时候，会使用到匿名内部类123456fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG).setAction("Action", null).show(); &#125;&#125;); 而在Kotlin中，就用对象表达式来替换匿名内部类，是这样子来写的12345678fab.setOnClickListener( object : View.OnClickListener &#123; override fun onClick(v: View?) &#123; &#125; &#125;)// 上面可以使用Lambdas简写成// fab.setOnClickListener( View.OnClickListener &#123; &#125;) 如果父类有构造函数，则必须传递相应的构造函数。多个父类可以用逗号隔开，写在冒号后面123456789open class A(x: Int) &#123; public open val y: Int = x&#125;interface B &#123;...&#125;val ab: A = object : A(1), B &#123; override val y = 15&#125; 当只需要一个对象just an object，没有父类的情况下12345val adHoc = object &#123; var x: Int = 0 var y: Int = 0&#125;print(adHoc.x + adHoc.y) 就像Java的匿名内部类一样，对象表达式中的代码可以访问封闭范围的变量。123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 // 如果是Java的话这里要加上final var enterCount = 0 // 这里也是 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ...&#125; 与Java不同，封闭范围的变量不需要声明为final 对象声明(Object declarations)在写项目的时候，一般会将常量统一写到一个类里面，然后设置静态变量，由于在Kotlin中不存在静态变量，所有就有对象声明的存在，对象声明比较常用的地方就是在这里，对象声明用Objcet关键字表示。12345678910111213141516171819object Constant &#123; /** * baseUrl */ val REQUEST_BASE_URL = "http://gank.io/api/" /** * all | Android | iOS | 休息视频 | 福利 | 拓展资源 | 前端 | 瞎推荐 | App */ val ALL = "all" val ANDROID = "Android" val IOS = "iOS" val WELFARE = "福利" val REST_VIDEO = "休息视频" val EXPAND_RESOURCES = "拓展资源" val WEB = "前端" val RECOMMEND = "瞎推荐" val APP = "App"&#125; Kotlin声明单例模式特别简单，如果在Java中声明1234567891011121314public class Singleton &#123; private static Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 在Kotlin中声明1234567object DataProviderManager &#123; fun registerDataProvider(provider: Dataprovider) &#123; //... &#125; val allDataProviders : Collection&lt;DataProvider&gt; get() = //...&#125; 在名字面前加object关键字，这样子的声明叫做对象声明，对象声明不算是表达式。 由于对象声明不算是表达式，所以不能直接赋值给变量。 如果要引用对象，我们直接使用其名称：1DataProviderManager.registerDataProvider(...) 这样的对象可以有父类12345678object DefaultListener : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // ... &#125; override fun mouseEntered(e: MouseEvent) &#123; // ... &#125;&#125; 对象声明不可以是局部的(比如不可以直接在函数内部声明)，但可以在其它对象的声明或非内部类中使用。 伴生对象(Companion Objects)一个类可以设置对象声明，那么在类的内部可不可以使用对象声明呢，答案是可以的，使用companion关键字声明，这样子的对象称为伴生对象(Companion Objects)。12345class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125; 伴生对象的成员可以通过类名做限定词直接使用1val instance = MyClass.create() 在使用了 companion 关键字时，可以省略伴生对象的名字123456class MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 伴生对象的成员可以看着是静态变量，但是与静态变量还是有区别的，比如在运行时它们任然是真正对象的成员实例，比如可以实现接口等12345678910interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125; 如果在JVM上使用@JvmStatic注解，可以有多个伴生对象作为静态方法和属性。 声明静态方法使用@JvmStatic在对象声明和伴生对象上面声明静态方法1234567891011121314151617// 伴生对象class Foo() &#123; companion object &#123; @JvmStatic fun test() &#123; &#125; &#125;&#125;// 对象声明object Constant &#123; @JvmStatic fun test() &#123; &#125;&#125; 生成的内容 Java调用的时候12345678public class TestClass &#123; public void get() &#123; Constant.test(); Foo.test(); &#125;&#125; 对象表达式和声明的区别对象表达式和对象声明之间的差别： 在使用的时候，对象表达式立即被执行（和初始化） 当第一次访问的时候，对象声明被初始化 当类加载的时候，会初始化伴生对象，与Java的静态初始化是匹配的。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Object</tag>
        <tag>JvmStatic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_类和继承、接口与实现]]></title>
    <url>%2F2017%2F03%2F19%2FKotlin%E5%AD%A6%E4%B9%A0_%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文是学习Kotlin的类和继承相关，嵌套类相关，接口相关。 类Kotlin的类的声明与Java一样，使用class关键字12class Invoice &#123;&#125; 类的声明包含类名，类头(指定类型参数，主构造函数等等)，以及类主体，用大括号包裹。类头和类体是可选的；如果没有类体可以省略大括号。1class Empty 构造函数Kotlin的类有两种构造函数，一种是主构造函数，一种是二级构造函数。主构造函数是写在类名后面(可以有可选的类型参数)，使用constructor关键字声明12class Person constructor(firstName: String) &#123;&#125; 如果一个非抽象类没有声明构造函数(主构造函数或二级构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想类有公共的构造函数，就得声明一个空的主构造函数12class DontCreateMe private constructor () &#123;&#125; 如果主构造函数没有任何注释或可见性修饰符，则可以省略constructor关键字12class Person(firstName: String) &#123;&#125; 主构造函数不包含任何代码，初始化代码应该放在以init做前缀的初始化块中12345class Customer(name: String) &#123; init &#123; logger.info("Customer initialized with value $&#123;name&#125;") &#125;&#125; 主构造函数的参数既可以用在初始化块中，也可以用在类的属性初始化声明处123class Customer(name: String) &#123; val customerKry = name.toUpperCase()&#125; 一般用Java写构造函数的时候，里面是写属性的初始化，如下面12345678910class Person &#123; private String firstName; private String lastName; private int age; Person(String firstName, String lastName, int age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; &#125;&#125; Kotlin有更简洁的写法，可以在主构造函数重声明属性并在主构造函数中初始化，同时可以设置属性为可变（var）或者设置为只读（val）12class Person(val firstName: String, val lastName: String, var age: Int)&#123;&#125; 如果构造函数具有注解(@Inject)或可见性修饰符(public)，则constructor关键字必须写上，并且写在可见性和注解的后面1class Customer public @Inject constructor(name: String) &#123; &#125; 二级构造函数二级构造函数同样是以constructor关键字来声明，与主构造函数不同的是，二级构造函数是写在类里面，同时，二级构造函数可以有多个。123456789class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125; constructor(parent: Person, count: Int) &#123; parent.children.add(this) &#125;&#125; 如果该类有主构造函数，那么声明二级构造函数都要使用this关键字来代理(Delegation)主构造函数12345678class Person(val name: String) &#123; constructor(name: String, paret: Person) : this(name) &#123; parent.children.add(this) &#125; constructor(name: String, parent: Person, count: Int) : this(name) &#123; parent.children.add(this) &#125;&#125; 注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。 1class Customer(val customerName: String = "") 创建类的实例Kotlin创建类的实例不需要像Java一样使用到new关键字，直接调用构造函数即可创建类的实例123val invoice = Invoice()val customer = Customer("Joe Smith") 类成员Kotlin的类里面可以包含 构造函数和初始化块(Constructors and initializer blocks) 函数(Functions) 属性(Properties) 嵌套类和内部类(Nested and Inner Classes) 数据对象(Object Declarations) 继承Kotlin中的所有类都有一个公共的父类Any1class Example // 隐式继承自Any Any不是java.lang.Object，Any只包含equals(),hashCode()以及toString()三个成员 如何继承一个类，声明一个类的父类呢，在类后面加冒号然后再加父类123open class Base(p: Int)class Derived(p: Int) : Base(p) 注意一个类如果要被别的类继承，要加上open关键字，在类名的最前面，默认情况下，Kotlin中的所有类都是final的，Kotlin的接口以及成员默认都是open。 同样，如果父类有主构造函数，则子类必须在主构造函数中初始化1234567891011/*** 父类*/open class BaseKot(name: String) &#123;&#125;/*** 子类*/class Kot(name: String) : BaseKot(name) &#123;&#125; 如果子类没有主构造函数，则可以在二级构造函数中使用super关键字初始化或者在代理(Delegation)另一个构造函数。1234567891011121314/*** 父类*/open class BaseKot(name: String) &#123;&#125;/*** 子类*/class Kot : BaseKot &#123; constructor(name: String) : super(name) &#123; &#125;&#125; 下面这种情形中不同的二级构造函数可以调用父类不同的构造方法123456class MyView : View &#123; constructor(ctx: Context) : super(ctx) &#123; &#125; constructor(ctx: Context, attrs: AttributeSet) : super(ctx,attrs) &#123; &#125;&#125; 重写方法上面说了，如果一个类要被继承需要在父类的类名前面加上open关键字，该类才能被继承，同样，一个父类的方法如果要能被重写，也需要加上open关键字，如果没有加的话，子类是不能重写改方法的。12345678910111213141516171819/*** 父类*/open class BaseKot &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;/*** 子类*/class Kot : BaseKot() &#123; // 加final可以设置不被重写 override fun v() &#123; super.v() &#125; // 重写nv方法会报错，加override也不行，只有父类的nv方法设置为open才行 // fun nv() &#123; &#125;&#125; 同样，如果类不是open的话，里面的成员也不允许设置为open 重写属性重写属性与重写方法类似，并且属性必须具有兼容类型，可以将val属性重写成var，也可以将var属性重写成val123456789101112131415161718/*** 父类*/open class BaseKot &#123; open val age: Int get() = 0 // get() = 0 与 = 0相同 open fun v() &#123;&#125;&#125;/*** 子类*/class Kot : BaseKot() &#123; override var age: Int = 5 // 重写为var类型 override fun v() &#123; super.v() &#125;&#125; 可以在子类的主构造函数中声明override123456class Kot(override var age: Int) : BaseKot() &#123; override fun v() &#123; super.v() &#125;&#125; 使用super实现子类中的代码可以使用super关键字调用其父类的函数与属性访问器的实现：12345678910111213open class Foo &#123; open fun f() &#123; println("Foo.f()") &#125; open val x: Int get() = 1&#125;class Bar : Foo() &#123; override fun f() &#123; super.f() println("Bar.f()") &#125; override val x: Int get() = super.x + 1&#125; 在一个内部类中访问外部类的父类，可以通过由外部类名限定的super关键字来实现：super@Outer：1234567891011class Bar : Foo() &#123; override fun f() &#123; /* …… */ &#125; override val x: Int get() = 0 inner class Baz &#123; fun g() &#123; super@Bar.f() // 调用 Foo 实现的 f() println(super@Bar.x) // 使用 Foo 实现的 x 的 getter &#125; &#125;&#125; 重写规则在Kotlin中，实现继承通常遵循如下规则：如果一个类从它的直接父类继承了同一个成员的多个实现，那么它必须复写这个成员并且提供自己的实现，要使用父类中提供的方法，用super&lt;Base&gt;来表示 1234567891011121314151617open class A &#123; open fun f() &#123; print("A") &#125; fun a() &#123; print("a") &#125; // 不会被重写&#125;interface B &#123; fun f() &#123; print("B") &#125; // 接口成员默认是open的 fun b() &#123; print("b") &#125;&#125;class C() : A(), B &#123; // The compiler requires f() to be overridden: override fun f() &#123; super&lt;A&gt;.f() // call to A.f() super&lt;B&gt;.f() // call to B.f() &#125;&#125; 可以同时从A B中继承方法，而且C继承a()或b()的实现没有任何问题，因为它们都只有一个实现。但是f()有两个实现，所以要在C中必须复写f()并且提供自己的实现。 抽象类与Java类似，Kotlin的类或者成员都可以被声明为abstract，同时不需要添加open关键字。可以用一个抽象成员去复写一个带 open 注解的非抽象方法1234567open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; 枚举类Kotlin也支持枚举，每个枚举常量都是一个对象。123enum class Direction &#123; NORTH, SOUTH, WEST, EAST&#125; 初始化由于每个枚举都是枚举类的实例，因此可以进行初始化12345enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125; 匿名类枚举常量也可以使用对应的方法声明自己的匿名类，以及覆盖基本方法。 注意，与Java一样，如果枚举类定义了任何成员，则需要使用分号将成员定义中的枚举常量定义分隔开。 1234567891011enum class ProtocolState &#123; WAITING &#123; override fun signal() = TALKING &#125;, TALKING &#123; override fun signal() = WAITING &#125;; abstract fun signal(): ProtocolState&#125; 使用枚举常量就像在Java中一样，Kotlin中的枚举类有合成方法，允许列出定义的枚举常量，并通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称是EnumClass）： EnumClass.valueOf(value: String): EnumClass EnumClass.values(): Array&lt;EnumClass&gt; 如果指定的名称与类中定义的任何枚举常量不匹配，该valueOf()方法将抛出IllegalArgumentException。 每个枚举常量都具有在枚举类声明中获取其名称和位置的属性： val name: String val ordinal: Int 密封类密封类是用来表示受限的类层次结构。例如当一个值为有限集中的 类型、而不能有任何其他类型时。在某种意义上,他们是枚举类的扩展:枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例,而密封类的一个子类可以有可包含状态的多个实例。密封类是类名前加sealed关键字来声明12345sealed class Expr &#123; class Const(val number: Double) : Expr() class Sum(val e1: Expr, val e2: Expr) : Expr() object NotANumber : Expr()&#125; 在1.1之后，数据类扩展包括密封类在内的其他类的可能性，这样写1234sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() 密封类子类的扩展可以在任何地方，不必在密封类声明内部进行 使用密封类的最主要的的好处体现在使用when表达式。可以确保声明可以覆盖到所有的情形，不需要再使用 else情形。1234567fun eval(expr: Expr): Double = when(expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN // 前面说过，使用when的时候除非能把所有可能的情况都列举出来，不然一定要加上else // 这里就不需要，因为列举了所有的情况&#125; 嵌套类与Java一样，一个类中可以嵌套其他的类123456class Outer &#123; private val bar: Int = 1 class Nested &#123; fun foo() = 2 &#125;&#125; 如何调用1val demo = Outer.Nested().foo() //==2 内部类内部类是使用inner关键字来声明。123456class Outer &#123; private val bar: Int = 1 inner class Inner &#123; fun foo() = bar &#125;&#125; 如何调用1val demo = Outer().Inner().foo() // == 1 嵌套类与内部类的区别是：嵌套类不能够访问外部成员，因为内部类包含对外部类的对象的引用，所以能够访问外部类的成员；调用的时候，内部类需要使用外部类的实例来调用。 接口Kotlin的接口类似与Java 8，都可以包含抽象方法，以及方法的实现。和抽象类不同的是，接口不能保存状态。可以有属性但必须是抽象的，或者提供访问器(getter)的实现。接口的定义同样是使用interface关键字123456interface MyInterface &#123; fun bar() fun foo() &#123; // 函数体是可选的，自己实现方法 &#125;&#125; 实现接口一个类或对象可以实现一个或多个接口12345class Child : MyInterface, YouInterface &#123; override fun bar() &#123; // body &#125;&#125; 接口中的属性123456789101112131415interface MyInterface &#123; val prop: Int // abstract val propertyWithImplementation: String get() = "foo" // 提供访问器getter，可以直接获取propertyWithImplementation的值foo fun foo() &#123; print(prop) &#125;&#125;class Child : MyInterface &#123; override val prop: Int = 29 override val propertyWithImplementation: String = "123"&#125; 解决重写冲突同类的重写类似，接口也一样，如果父类中声明了许多类型，有可能出现一个方法的多种实现，必须复写这个成员并且提供自己的实现，要使用父类中提供的方法，用super&lt;Base&gt;来表示1234567891011121314151617181920interface A &#123; fun foo() &#123; print("A") &#125; fun bar()&#125;interface B &#123; fun foo() &#123; print("B") &#125; fun bar() &#123; print("bar") &#125;&#125;class C : A &#123; override fun bar() &#123; print("bar") &#125;&#125;class D : A, B &#123; override fun foo() &#123; super&lt;A&gt;.foo() super&lt;B&gt;.foo() &#125;&#125; 上面的代码是A，B接口都有声明了foo()，bar()函数，都实现了foo()方法，但只有B实现了bar()，bar()在A中并没有声明它是抽象的，C实体类需要重写并实现bar()，而D类，不用重写bar()方法，因为继承的B接口已经实现了。由于继承了两个foo()的实现，所以用super&lt;Base&gt;来区分。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战_写一个登录的Demo]]></title>
    <url>%2F2017%2F03%2F10%2FKotlin%E5%AE%9E%E6%88%98_%E5%86%99%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E7%9A%84Demo%2F</url>
    <content type="text"><![CDATA[前言如何安装Kotlin可以参考Kotlin学习（一）: Kotlin插件安装这篇文章。 demo说明该demo是使用Kotlin写的登录demo，使用MVP模式，里面用到了Retrofit+RxJava，然后用了Mob的登录Api接口作为登录和注册的判断，Mob提供了很多免费的接口。 Activity直接将控件的id当成变量来使用 设置点击事件12login.setOnClickListener(this)register.setOnClickListener(this) 用when代替switch1234567891011121314151617181920override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.login -&gt; if (checkContent(true)) &#123; dialog = SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE) .setTitleText("正在登录...") dialog?.setCancelable(false) dialog?.show() loginPresenter?.login(username.text.toString(), password.text.toString()) &#125; R.id.register -&gt; if (checkContent(false)) &#123; dialog = SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE) .setTitleText("正在注册...") dialog?.setCancelable(false) dialog?.show() loginPresenter?.register(username.text.toString(), password.text.toString(), email.text.toString()) &#125; &#125;&#125; 注意：直接使用id作为变量的时候，要在Module的gradle里面加入扩展，才能使用，不然会报错1apply plugin: 'kotlin-android-extensions' Retrofit+RxJavaRetrofit结合RxJava能快捷的使用网络请求。创建Service接口，Kotlin的类型是写在后面12345678910111213141516171819202122232425262728293031interface RetrofitService &#123; /** * 注册 * key 用户申请的appkey * username 用户名（一个key只能存在唯一username） * password 用户密码（建议加密） * email 邮箱 */ @GET("rigister") fun userRegister( @Query("username") username: String, @Query("password") password: String, @Query("email") email: String, @Query("key") key: String = Constant.KEY ): Observable&lt;RegisterResponse&gt; /** * 登录 * key 用户申请的appkey * username 用户名 * password 用户密码 */ @GET("login") fun userLogin( @Query("username") username: String, @Query("password") password: String, @Query("key") key: String = Constant.KEY ): Observable&lt;LoginResponse&gt;&#125; 创建Retrofit，使用伴生对象创建，类型静态变量使用1234567891011121314151617181920212223242526class RetrofitUtils&lt;T&gt; &#123; companion object &#123; /** * 创建Retrofit */ fun create(url: String): Retrofit &#123; ... return Retrofit.Builder() .baseUrl(url) .client(okHttpClientBuilder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build() &#125; val retrofitService: RetrofitService = RetrofitUtils.getService(Constant.REQUEST_BASE_URL, RetrofitService::class.java) /** * 获取ServiceApi */ fun &lt;T&gt; getService(url: String, service: Class&lt;T&gt;): T &#123; return create(url).create(service) &#125; &#125;&#125; Retrofit结合RxJava123456789RetrofitUtils .retrofitService .userLogin(username, password) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe( &#123; ... &#125;) 使用对象声明在写项目的时候，一般会将常量统一写到一个类里面，然后设置静态变量，由于在Kotlin中不存在静态变量，所有就有对象声明的存在，对象声明比较常用的地方就是在这里，对象声明用Objcet关键字表示。12345678object Constant &#123; /** * baseUrl */ val REQUEST_BASE_URL = "http://apicloud.mob.com/user/" val KEY = "1be865c0e67e3"&#125; 使用的时候直接类名加.加变量名，如Constant.REQUEST_BASE_URL 使用数据类前面说过，Kotlin的惯用语法是有写POJO类，一般写那种类都是用data修饰的类，也就是数据类表示，只保存数据的类(JavaBean)。1data class LoginResponse(val msg: String, val result: LoginResultResponse, val retCode: String) 使用扩展函数1234fun loge(tag: String, content: String?) &#123; Log.e(tag, content ?: tag)&#125; 调用的时候直接使用loge(TAG, &quot;content&quot;) 后话Kotlin写起来非常方便，里面的非空(non-null)可以避免空指针异常等等的好处，本demo的代码放到github，欢迎stars和issues。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_包、控制流、返回与跳转]]></title>
    <url>%2F2017%2F03%2F07%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%8C%85%E3%80%81%E6%8E%A7%E5%88%B6%E6%B5%81%E3%80%81%E8%BF%94%E5%9B%9E%E4%B8%8E%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[本文是学习Kotlin的包相关，控制流相关以及返回与跳转相关，与Java比较大的区别是Kotlin用when来替换掉Java的switch，写好简单，可以有各种类型值的判断，另外可以指定返回和跳转到指定标签的位置。 包(Package)与Java一样，Kotlin的源文件同样以包声明开始的。1234567package foo.barfun baz() &#123;&#125;class Goo &#123;&#125;// ... 源文件的所有内容（如类和函数）都包含在声明的包中。所以，在上面的例子中，baz()的全名是foo.bar.baz，Goo的全名是foo.bar.Goo。 如果未指定包，则此类文件的内容属于没有名称的“default”包。 导入(Imports)Kotlin中除了模块中默认导入的包，每个文件都可以被导入。如导入一个包里面的类文件1import foo.Bar // 导入foo包里面的Bar 如导入一个包里面的所有内容（包，类，对象，等等）1import foo.* // foo中的所有都可以使用 如果命名有冲突，可以用as关键字来重命名解决冲突12import foo.Bar // Bar可以使用import bar.Bar as bBar // bar.Bar可以直接用bBar表示 与Java不同，Kotlin没有单独的“import static”语法;所有这些声明都使用常规import关键字导入。 控制流(Control Flow)Kotlin的控制流有if``when``for``while四种。 if表达式在Kotlin中，if表达式表示返回一个值(true或false)，Kotlin中没有三目运算符。1234567891011121314//传统用法var max = aif (a &lt; b) max = b//带 else var max: Intif (a &gt; b) max = aelse max = b//作为表达式val max = if (a &gt; b) a else b if 分支可以作为块，最后一个表达是是该块的值12345678val max = if (a &gt; b)&#123; print("Choose a") a&#125;else&#123; print("Choose b") b&#125; 如果使用if作为一个表达式，表达式需要有一个else分支。12val max = if (a &gt; b) a // 这样写是错误的val max = if (a &gt; b) a else b // 这样才是正确的 when表达式Kotlin中的when就类似与Java的switch，但是与switch不同1234567when (x) &#123; 1 -&gt; print("x == 1") 2 -&gt; print("x == 2") else -&gt; &#123; // 默认 print("x is neither 1 nor 2") &#125;&#125; 在其它分支都不匹配的时候默认匹配 else 分支，如果没有把所有可能和分支条件列出来，那么else是强制的，这与switch的default也有区别。 分支条件可以连在以前判断1234when (x) &#123; 0,1 -&gt; print("x == 0 or x == 1") else -&gt; print("otherwise")&#125; 分支的判断条件可以用任意表达式1234when (x) &#123; parseInt(s) -&gt; print("s encode x") else -&gt; print("s does not encode x")&#125; 也可以用 in 或者 !in 检查值是否值在一个集合中123456when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125; 也可以用 is 或者 !is 来判断值是否是某个类型，由于Kotlin可以自动判断变量的类型，所有在满足条件后的操作可以不用检查就能使用相应的属性或方法。1234val hasPrefix = when (x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125; when甚至可以用来替换if-else if，将when设置无参数提供就是简单的if表达式了12345when &#123; x.isOdd() -&gt; print("x is odd") x.isEven() -&gt; print("x is even") else -&gt; print("x is funny")&#125; 用了when之后，Java的switch简直就是辣鸡。。 for循环for循环的内容可以是一个语句块123for (item: Int in ints) &#123; // ...&#125; for 可以对任何提供的迭代器进行迭代，例如 has a member- or extension-function iterator(), whose return type has a member- or extension-function next(), and has a member- or extension-function hasNext() that returns Boolean. 如果需要使用list或者array的索引进行迭代，需这样写123for (i in array.indices) &#123; print(array[i])&#125; while循环while 和 do...while 与Java的一样，有一个区别是，语句块里面的变量在外面是可见的1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) // y 在这是可见的 返回与跳转(Returns and Jumps)Kotlin支持三种跳转操作符 return，结束最近的闭合循环 break，跳出最近的闭合循环 continue，跳到最近的闭合循环的下一次循环 break和continue标签(Break and Continue Labels)Kotlin中的任何表达式都可以用标签标记，标签是后面加@符号的标识符的形式，例如：abc @，fooBar @。123loop@ for (i in 1..100)&#123; // loop@就是标签 //...&#125; 使用break 跳转到标签处，跳出循环1234567loop@ for (i in 1..10) &#123; for (j in i..10) &#123; if (j == 5) break@loop // 跳出循环 Log.e(Tag, j.toString()) // j 为5的时候跳出了循环，只打印1、2、3、4 &#125;&#125; 使用continue跳转到标签处，进行下一次循环1234567loop@ for (i in 1..10) &#123; for (j in i..10) &#123; if (j == 5) continue@loop // 跳出本次循环，进行下一次循环 Log.e(Tag, j.toString()) // j 为5的时候跳出了循环，所有不会打印5 &#125;&#125; return标签(Return at Labels)在字面函数，局部函数，以及对象表达式中，函数可以在 Kotlin 中被包裹。return允许返回到外层函数。123456fun foo() &#123; ints.forEach &#123; if (it == 0) return // 跳出forEach print(it) &#125;&#125; return表达式返回到最近的闭合函数，比如 foo，如果返回从一个函数返回可以使用return标签1234567fun foo() &#123; ints.forEach lit@ &#123; it (it ==0) return＠lit // 这样就不会return到foo函数，而是return到标签处的forEach函数 print(it) &#125;&#125; 通常这种情况用一种更方便的标签，例如用一个和传入的 Lambda 表达式名字相同的标签。1234567fun foo() &#123; ints.forEach &#123; if (it ==0) return@forEach // 与上面一样，return到标签处的forEach函数 print(it) &#125;&#125; 另外，可以用匿名函数替换lambda表达式，使用 return 语句可以从匿名函数中返回123456fun foo() &#123; ints.forEach(fun(value: Int)&#123; if (value == 0) return print(value) &#125;)&#125; 当返回一个值的时候，如return@a 1，表示在标签@a处返回1，而不是返回带标签的表达式@a 1]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_惯用语法和代码风格（Idioms And Coding Conventions）]]></title>
    <url>%2F2017%2F03%2F04%2FKotlin%E5%AD%A6%E4%B9%A0_%E6%83%AF%E7%94%A8%E8%AF%AD%E6%B3%95%E5%92%8C%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[本文是学习Kotlin的惯用语法和代码风格，与Java的语法和代码风格有一些相同，也有一些不同。 创建DTO’s(POJOs/POCOs)数据类(Creating DTOs (POJOs/POCOs))1data class Customer(val name: String, val email: String) 这里的Customer是数据类，在Kotlin中，会自动为Customer类生成以下方法 给所有属性添加getter方法，如果是var类型的话会添加setter方法 equals() haseCode() toString() copy() 给所有属性添加component1()，component2()，… 函数参数默认值(Default values for function parameters)可以为函数的参数设置默认值1fun foo(a: Int = 0, b: String = "") &#123; ... &#125; 过滤list(Filtering a list)使用扩展函数filter来过滤list1val positives = list.filter &#123; x -&gt; x &gt; 0 &#125; 或者用it来替换x1val positives = list.filter &#123; it &gt; 0 &#125; 判断实例(Instance Checks)通过用is来判断是否属于某个实例12345when (x) &#123; is Foo -&gt; ... is Bar -&gt; ... else -&gt; ...&#125; 遍历map/list(Traversing a map/list of pairs)123for ((k, v) in map) &#123; println("$k -&gt; $v")&#125; 其中k和v可用任意命名 只读list/map(Read-only list/map)只读就是设置为常量12val list = listOf("a", "b", "c") val map = mapOf("a" to 1, "b" to 2, "c" to 3) 访问map(Accessing a map)对map的使用12println(map["key"])map["key"] = value 延时加载(Lazy property)lazy 用于延时加载，即第一次使用时才执行初始化的操作。123val p: String by lazy &#123; // compute the string&#125; 扩展函数(Extension Functions)12fun String.spcaceToCamelCase() &#123; ... &#125;"Convert this to camelcase".spcaceToCamelCase() 前面有提到filter扩展函数，扩展函数就是创建可直接使用的方法，例如我要创建一个可直接使用的toast方法，可以这样写1234fun Context.toast(content: String?) &#123; Toast.makeText(this, content, Toast.LENGTH_SHORT).show()&#125; 调用的时候1234// activity里面toast("扩展函数")// 有context的时候mContext.toast("扩展函数") 创建单例(Creating a singleton)Kotlin创建单例模式就比较简单了123object Resource &#123; val name = "Name"&#125; 如果不为空则…的简写(If not null shorthand)123val files = File("Test").listFiles()// 对files加了不为空的判断(?)println(files?.size) 如果不为空则…否则…的简写(If not null and else shorthand)123val files = File("Test").listFiles()// 对files加了不为空的判断(?)，同时加了为空的判断(?:)println(files?.size ?: "empty") // 如果files为空则打印empty 如果为空，则执行语句(Executing a statement if null)使用?:符号，为空时执行语句12345val data = ...val email = data["email"] ?: throw IllegalStateException("Email is missing!")val name = data["name"] ?:let&#123; ...&#125; 如果不为空，则执行语句(Execute if not null)使用?符号，加非空判断，.let{ }是不为空的时候执行12345val data = ...data?.let &#123; ... // 如果不为空，请执行此块操作&#125; 返回 when 判断(Return on when statement)返回的时候可以直接用when表达式返回值12345678fun transform(color: String): Int &#123; return when (color) &#123; "Red" -&gt; 0 "Green" -&gt; 1 "Blue" -&gt; 2 else -&gt; throw IllegalArgumentException("Invalid color param value") &#125;&#125; 如果一个函数只有一个并且是表达式函数体并且是返回类型自动推断的话，可以直接等于返回值123456fun transform(color: String): Int = when (color) &#123; "Red" -&gt; 0 "Green" -&gt; 1 "Blue" -&gt; 2 else -&gt; throw IllegalArgumentException("Invalid color param value")&#125; try / catch表达式(‘try/catch’ expression)Kotlin的try/catch表达式同Java类似，Kotlin可以直接赋值123456789fun test() &#123; val result = try &#123; count() &#125; catch (e: ArithmeticException) &#123; throw IllegalStateException(e) &#125; // 处理result&#125; 方法使用Builder模式返回Unit(Builder-style usage of methods that return Unit)1234fun arrOfMinusOnes(size: Int): IntArray&#123; // 生成一个大小为size，每个值为-1的数组 return IntArray(size).apply&#123; fill(-1) &#125; // fill(-1)设置为值为-1&#125; 单表达式函数(Single-expression functions)前面说过如果一个函数只有一个并且是表达式函数体并且是返回类型自动推断的话，可以直接等于返回值1fun theAnswer() = 42 等同于123fun theAnswer(): Int &#123; return 42&#125; 使用with调用一个对象实例的多个方法(Calling multiple methods on an object instance (‘with’))1234567891011121314151617181920212223class Turtle &#123; fun penDown() fun penUp() fun turn(degrees: Double) fun forward(pixels: Double)&#125;val myTurtle = Turtle()// 如果正常的写myTurtle.penDOwn()for(i in 1..4) &#123; myTurtle.forward(100.0) myTurtle.turn(90.0) &#125;myTurtle.penUp() // 使用with将对象实例引用，代码减少很多with(myTurtle) &#123; penDown() for(i in 1..4) &#123; forward(100.0) turn(90.0) &#125; penUp() &#125; 同样，在Adapter里面可以直接使用with来替换holder.itemView1234567with(holder.itemView) &#123; // 名称 new_item_text.text = mDatas?.get(position)?.desc // 作者 new_item_user.text = mDatas?.get(position)?.who.let &#123; Constant.NEW_ITEM_USER_NULL &#125;&#125; Java 7的try with resources(Java 7’s try with resources) try-with-resources语句是一个声明一个或多个资源的 try语句。一个资源作为一个对象，必须在程序结束之后随之关闭。在Java 7 之前, 可以使用finally块来确保资源被关闭，不管try语句正常地完成或是发生意外。而try-with-resources语句确保在语句的最后每个资源都被关闭 。1234val stream = Files.newInputStream(Paths.get("/some/file.txt"))stream.buffered().reader().use &#123; reader -&gt; println(reader.readText())&#125; 泛型转换(Convenient form for a generic function that requires the generic type information)123456// public final class Gson &#123;// ...// public &lt;T&gt; T fromJson(JsonElement json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123;// ...inline fun &lt;reified T: Any&gt; Gson.fromJson(json): T = this.fromJson(json, T::class.java) 使用可空的Boolean(Consuming a nullable Boolean)添加?符号可以让变量可为空123456val b: Boolean? = ...if (b == true) &#123; ...&#125; else &#123; // `b` 是false或者为null&#125; 命名风格(Naming Style)Kotlin的命名风格与Java的类似 使用骆驼命名法(在命名中避免下划线) 类型名称首字母大写 方法和属性首字母小写 缩进用四个空格 …… 冒号(Colon)在冒号之前有一个空格，冒号分隔类型和超类型(fun foo(a: Int): T)，没有空格，冒号分隔实例和类型(var bar: String)：123interface Foo&lt;out T : Any&gt; : Bar &#123; fun foo(a: Int): T&#125; LambdasKotlin支持Lambdas表达式，在 Lambdas 表达式中，大括号与表达式间要有空格，箭头与参数和函数体间要有空格。尽可能的把 Lambda 放在括号外面传入1list.filter &#123; it &gt; 10 &#125;.map &#123; element -&gt; element * 2 &#125; 在短的且不嵌套的Lambdas中，建议使用it替换参数，有嵌套而已有多个参数的Lambdas中，就不能用it来替换参数，必须明确声明参数。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_基本类型（Basic Types）]]></title>
    <url>%2F2017%2F03%2F01%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本文是学习Kotlin的基本类型，Kotlin的基本类型与Java有一些不同，例如整数类型，Java是int表示，而Kotlin是Int表示；例如布尔类型，Java是boolean表示，而Kotlin是用Boolean表示。在 Kotlin 中，所有变量的成员方法和属性都是一个对象，我们可以在任何变量上调用成员函数和属性。在本文中，将会讲解经常被使用的类型：Numbers，Characters，Booleans，Arrays，Strings。 Numbers(数值)Kotlin处理数值的方式与Java类似，单又不完全相同，例如，数值没有隐式扩展转换，在默写情况下文字也略有不同。Kotlin 提供了如下内建数值类型(与Java类似) Type Bit width(字宽) Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 注意：字符不是kotlin中的数值类型 字面常量(Literal Constants)对于整数值，有以下几种常量 整型: 123 长整型要加 L: 123L 16进制: 0x0F 二进制: 0b00001011 对于浮点数值 Doubles类型: 123.5, 123.5e10 Floats类型要加 f or F: 123.5f 注意：不支持8进制 数值中的下划线（1.1版开始）Java8支持数值使用下划线类分割数字分组，可以使用下划线使数字常量更易读：123val oneMillion = 1_000_000val hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 等同于1231000000ffecde5e11010010011010011001010010010010 表示法(Representation)在Java平台上，数值被 JVM 虚拟机以字节码的方式物理存储的，除非我们需要做可空标识(比如说 Int?) 或者涉及泛型。12345val a: Int = 10000print(a === a) // 打印'true' ，与Java的‘===’一样val boxedA: Int? = aval anotherBoxedA: Int? = aprint(boxedA === anotherBoxedA) // 打印`false` 另一方面，值是相等的12345val a: Int = 10000print(a == a) // 打印 'true'val boxedA: Int? = aval anotherBoxedA: Int? = aprint(boxedA == anotherBoxedA) // 打印 'true' 显式转换(Explicit Conversions)由于不同的表示，短类型不是长类型的子类型1234//这是些伪代码，不能编译的val a: Int? =1 // Int (java.lang.Integer)val b: Long? = a // Long (java.lang.Long)print( a == b ) // 打印 'false' ，由于 Long 类型的 equals() 只有和 Long 比较才会相同 短类型是不会隐式(自动)转换为长类型的，需要显示(手动)转换才行12val b: Byte = 1 // val i: Int = b // 错误，不能自动转换 改为显示(手动)转换1val i: Int = b.toInt() // 成功 数值类型支持的转换有下面几种 toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char Kotlin会自动转换类型的，比如1val l = 1.toLong + 1 // Long + Int =&gt; Long，自动转换成Long类型 运算符(Operations)Kotlin支持标准的算术运算表达式，这些运算符被声明为相应类的成员。对于位操作，没有特殊的字符，只是命名的函数可以以中缀形式调用，例如1val x = (1 shl 2) and 0x000FF000 支持的位运算操作符有(仅适用于Int和Long类型) shl(bits) – 带符号左移 (相当于 Java的 &lt;&lt;) shr(bits) – 带符号右移 (相当于 Java的 &gt;&gt;) ushr(bits) – 无符号右移 (相当于 Java的 &gt;&gt;&gt;) and(bits) – 按位与 or(bits) – 按位或 xor(bits) – 按位异或 inv() – 按位翻转 Characters(字符)字符类型用 Char 表示，不能直接当做数值来使用12345fun check(c: Char) &#123; if (c == 1) &#123; // 错误：类型不匹配 // ... &#125;&#125; 字符文字用单引号括起来：’1’，可以使用反斜杠转义特殊字符，支持以下转义序列：\t，\b，\n，\r，\’，\“，\和\$ ‘，要编码任何其他字符，使用Unicode转义序列语法：’\uFF00’。 下面是将字符类型显示(手动)转换成Int类型12345fun decimalDigitValue(c: Char): Int &#123; if (c !in '0'..'9') throw IllegalArgumentException("Out of range") return c.toInt() - '0'.toInt() // 显示转换为数值类型&#125; Boleans(布尔值)Kotlin的Boolean同Java的boolean类型一样，只有true和false Boolean的操作同Java一样 || – 或者 &amp;&amp; – 并且 ! - 非 Arrays(数组)Kotlin中的数组由Array表示，通过[]调用get和set方法，支持size属性，以及其他，下面是Array代码12345678class Array&lt;T&gt; private constructor() &#123; val size: Int fun get(index: Int): T fun set(index: Int, value: T): Unit fun iterator(): Iterator&lt;T&gt; // ...&#125; 可以使用 arrayOf() 创建Array，arrayOf(1, 2, 3) 创建了一个[1, 2, 3] 的数组。可以使用 arrayOfNulls() 创建一个指定大小的空Array。 另外也可以使用工厂函数，该函数采用数组大小​​和函数，该函数可以返回每个数组元素的索引的初始值12// 创建 Array&lt;String&gt; 内容为 ["0", "1", "4", "9", "16"]val asc = Array(5, &#123; i -&gt; (i * i).toString() &#125;) 注意：和 java 不一样，arrays 在 kotlin 中是不可变的。这意味这 kotlin 不允许我们把 Array转为 Array,这样就阻止了可能的运行时错误(但可以用 Array) Kotlin 有专门的类来表示原始类型： ByteArray, ShortArray, IntArray 等等。这些类与Array类没有继承关系，但它们具有相同的方法和属性集。也有相应的工厂功能12val x: IntArray = intArrayOf(1, 2, 3) // 创建一个Int类型的Arrayx[0] = x[1] + x[2] Strings(字符串)字符串由类型String表示，字符串是不可变的。字符串的元素是可以通过索引操作访问的字符：s [i]。一个字符串可以用一个for循环迭代123for (c in str) &#123; println(c)&#125; 字符串字面量(String Literals)Kotlin 有两种类型的 String ：一种是可以带分割符的，一种是可以包含新行以及任意文本的。带分割符的 String 与Java 的 String类似1val s = "Hello World!\n" 如果String 是由三个引号包裹的(“””),不可以包含分割符但可以包含其它字符：1234val text = """ for (c in "foo") print(c)""" 可以使用trimMargin()来删除空格123456val text = """ |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) """.trimMargin() 默认为|用作边距前缀，可以选择另一个字符并将其作为参数传递，如trimMargin(“&gt;”)。 字符串模版(String Templates)字符串可以包含模板表达式，前面介绍了可以使用${}模版表达式12val s = "abc"val str = "$s.length is $&#123;s.length&#125;" //识别为 "abc.length is 3" 还有一种是可以使用$模版表达式12val i = 10val s = "i = $i" // 识别为 "i = 10" 模版表达式同样可以用于由三个引号包裹的String，如下面的，${&quot;$&quot;}表示$符号123val price = """$&#123;'$'&#125;9.99"""]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_属性和字段]]></title>
    <url>%2F2017%2F02%2F28%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[本文是关于Kotlin的属性和字段相关，涉及到有变量、常量还有延迟加载属性。 声明属性(Declaring Properties)Kotlin中可以使用var关键字声明可变属性，或者用val关键字声明只读属性，属性的类型在后面，变量名在签名，中间加冒号和空格。1234567public class Address &#123; public var name: String = ... public var street: String = ... public var city: String = ... public var state: String? = ... public var zip: String = ...&#125; 调用的时候与Java一样，通过变量名直接使用一个属性1234567fun copyAddress(address: Address): Address &#123; val result = Address() // Kotlin不需要使用new关键字 result.name = address.name result.street = address.street // ... return result&#125; Getter和Setter(Getters and Setters)声明属性的完整语法如下，语法中的初始化语句，getter和setter都是可选的123var &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，以为它是只读的。1234var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1 // 类型为 Int, 默认实现了 getter 和 setterval simple: Int? // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1 // 类型为 Int 类型,默认实现 getter 可以自定义访问器(getter)和自定义setter，setter的参数名默认是value，也可以自定义12345678val isEmpty: Boolean get() = this.size == 0var stringRepresentation: String get() = this.toString() set (value) &#123; setDataFormString(value) // 格式化字符串,并且将值重新赋值给其他元素 &#125; 如果需要设置访问器的可见性或者设置注解，又不改变原来的实现，则可以设置一个不带函数的访问器12345var setterVisibility: String = "abc" // 非空类型必须初始化 private set // setter是私有的并且有默认的实现var setterWithAnnotation: Any? = null // 设置为可空 @Inject set // 用 Inject 注解 setter 备用字段(Backing Fields)Kotlin中的类并不允许使用字段，在自定义getter和setter的时候，可以使用field来起到局部变量的作用。123456var counter = 0 //初始化值会直接写入备用字段 get() = field set(value) &#123; if (value &gt;= 0) field = value &#125; 编译器会检查访问器的代码,如果使用了备用字段(或者访问器是默认的实现逻辑)，就会自动生成备用字段，否则就不会。123// 这种情况并不需要备用字段，所有不会生成备用字段val isEmpty: Boolean get() = this.size == 0 注意：field标识符只允许在属性的访问器函数内使用. 备用属性(Backing Properties)备用属性，可以看作是备用变量(Backing Fields)的变种，其实际上也是隐含试的对属性值的初始化声明，避免了空指针。12345678private var _table: Map&lt;String, Int&gt;? = nullpublic val table: Map&lt;String, Int&gt; get() &#123; if (_table == null) &#123; _table = HashMap() // 参数类型是自动推导 &#125; return _table ?: throw AssertionError("Set to null by another thread") &#125; 不管是备用变量或者备用属性，都是Kotlin对于空指针的一种解决方案，可以避免函数访问私有属性而破坏它的结构。 编译时常量(Compile-Time Constants)那些在编译时就能知道具体值的属性可以使用const修饰符标记为编译时常量. 这种属性需要同时满足以下条件: 顶层或对象的成员(Top-level or member of an object) 以String或基本类型进行初始化 没有自定义getter 这种属性可以当作注解使用12const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"@Deprected(SUBSYSTEM_DEPRECATED) fun foo() &#123; ... &#125; Top-level(顶级)Top-level属性或者方法，与class同级，如下面所示，类名是Kot12345678910111213package foo.barval prop: String = "top-level-prop"fun demo() &#123; loge("top-level", "top-level-demo()")&#125;class Kot &#123; fun v() &#123; loge("top-level", prop) demo() &#125;&#125; 在编译成class的时候，会把Top-level的属性和函数创建到以类名+Kt为名的class文件中 Top-level调用的时候类似于调用扩展函数那样，直接调用属性或者函数。12loge("top-level", prop)demo() 延迟初始化属性(Late-Initialized Properties)在Kotlin中，声明为具有非空类型的属性必须在构造函数中初始化，但是往往不希望在构造函数中初始化，例如在通过依赖注入或单元测试的设置方法来初始化属性的时候，不能在构造器中提供一个非空的初始化语句，为了处理这种情况，就要在属性上加lateinit关键字来延迟初始化1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() &#125;&#125; lateinit只能够在var类型的属性中，不能用于构造函数，而且属性不能有自定义的getter和setting，这些属性必须是非空类型，并且不能是基本类型。 如果在一个延迟初始化的属性初始化前调用,会导致一个特定异常,调用的时候值还没有初始化.]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_基本语法]]></title>
    <url>%2F2017%2F02%2F26%2FKotlin%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[定义包名(Basic Syntax)与Java定义包名一样，在源文件的开头定义包名：12345package my.demoimport java.util.*// ... 包名和文件夹路径可以不一致：源文件可以放在项目的任意位置。 定义函数(Defining functions)与Java定义函数的区别在于：Kotlin在定义函数的时候要加个fun关键词，函数的返回值前后不同，Java的在前面，如123private int getResult(int a, int b) &#123; return a + b;&#125; 而Kotlin的话，要在后面写返回值，如123fun getResult(a: Int, b: Int): Int &#123; return a + b&#125; 如果一个函数只有一个并且是表达式函数体并且是返回类型自动推断的话，可以直接这样写123fun getResult(a: Int, b: Int) = a + b // 这里的函数没有写返回值，以为Kotlin会自动判断返回值类型 如果函数返回一个无意义的值，相当于Java的void，则可以这样写1234fun getResult(a: Int, b: Int): Unit &#123; print(a + b)&#125; Uint 的返回类型可以省略1234fun getResult(a: Int, b: Int) &#123; print(a + b)&#125; 定义局部变量(Defining local variables) Kotlin声明变量与Java声明变量有些不一样，Java变量类型在前，变量名在后，而Kotlin则相反，变量名在前，变量类型在后，中间加:(冒号)，并且Kotlin可以自动判断变量的类型。 声明局部常量（常量使用val关键字）1234val a: Int = 1val b = 1 // 自动判断出Int类型val c: Int // 当没有初始化值的时候要声明类型，全局变量不能这样写c = 1 // 赋值 声明变量（变量使用var关键字）12var x = 5 // 自动推断出Int类型x += 1 注释(Comments)Kotlin的注释与Java一样， 支持单行注释和块注释。1234// 单行注释/* 这是一个 块注释 */ 使用字符串模版(Using string templates)使用${变量}，如变量为args: Array&lt;String&gt;，使用的时候可以这样写12345fun main(args: Array&lt;String&gt;) &#123; if (args.size == 0) return print("First argument: $&#123;args[0]&#125;")&#125; 而不用再去用加号加起来，gradle里面也是支持的12345fun main(args: Array&lt;String&gt;) &#123; if (args.size == 0) return print("First argument: " + args[0])&#125; 使用条件表达式(Using conditional expressions)使用if表达式的时候这样写1234567fun max(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 前面说过，如果一个函数只有一个并且是表达式函数体并且是返回类型自动推断的话，可以直接这样写12fun getResult(a: Int, b: Int) = a + b 那么加上if表达式的话，可以这样写1fun max(a: Int, b: Int) = if (a &gt; b) a else b 使用可空变量和空置检查(Using nullable values and checking for null)当一个变量、函数可能出现空值的时候，应该指出该引用可空，如12345fun getResult(a: Int, b: Int): Int? &#123; // 设置函数返回类型可空 print(a + b) return null&#125; 使用类型检查和自动转换(Using type checks and automatic casts)is运算符是检查一个表达式是否是某个类型的实例，如果为不可变局部变量或属性进行类型检查，则无需显式转换123456789fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // `obj`在这个分支中自动转换为`String`类型 return obj.length &#125; // `obj`仍然是`Any`类型 return null&#125; 或者123456fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // `obj`在这个分支中自动转换为`String`类型 return obj.length&#125; 也可以这样12345678fun getStringLength(obj: Any): Int? &#123; // `obj` 自动转换成`String`类型，并且在&amp;&amp;后面生效 if (obj is String &amp;&amp; obj.length &gt; 0) &#123; return obj.length &#125; return null&#125; 使用for循环(Using a for loop)与Java相比，Kotlin使用for循环要更加的简洁12345fun main(args: Array&lt;String&gt;) &#123; for (arg in args) &#123; // in操作符可以判断是否arg是否在args里面 print(arg) &#125; &#125; 或者这样写123for (i in args.indices) &#123; print(args[i])&#125; 使用while循环(Using a while loop)while循环与Java一样123456fun main(args: Array&lt;String&gt;) &#123; var i = 0 while (i &lt; args.size) &#123; print(args[i++]) &#125; &#125; 使用when表达式(Using when expression)when表达式就相当于Java的switch表达式，省去了case和break，并且支持各种类型。123456789fun cases(obj: Any) &#123; when (obj) &#123; 1 -&gt; print("One") //如果obj的值为1 "Hello" -&gt; print("Greeting") // 如果obj的值为hello is Long -&gt; print("Long") // 如果obj的类型是Long类型 !is String -&gt; print("Not a string") // 如果obj的类型不属于String类型 else -&gt; print("Unknown") // 默认，相当于switch的default &#125;&#125; 使用ranges(Using ranges)使用in运算符检查数字是否在范围内12345678if (x in 1..y-1) &#123; //1..y-1表示1到y-1的范围 print("OK")&#125;for (i in 1..100) &#123; ... &#125; // 1到100范围for (i in 1 until 100) &#123; ... &#125; // 半开范围，不包括100，相当于[1,100)for (x in 2..10 step 2) &#123; ... &#125; // 每次夸2，内容为2,4,6,8,10for (x in 10 downTo 1) &#123; ... &#125; // 返序if (x in 1..10) &#123; ... &#125; 使用!in运算符检查数值是否在范围外123if (x !in 0..array.lastIndex) &#123; print("Out")&#125; 使用集合(Using collections)循环输出一个集合里面的值或者判断集合里面是否包含某个变量123for (name in names) &#123; // 将会调用nemes.contains(name)方法 println(name)&#125; 使用lambda表达式过滤和映射集合123456// it表示namenames .filter &#123; it.startsWith("A") &#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; print(it) &#125; 后话基本语法就学到这里。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习_Kotlin插件安装]]></title>
    <url>%2F2017%2F02%2F25%2FKotlin%E5%AD%A6%E4%B9%A0_Kotlin%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[什么是Kotlin？ Kotlin是针对JVM、Android 和浏览器的静态编程语言！100% 与 Java™ 可互操作！ Kotlin在Android上的使用Kotlin可以直接将布局的id来当成变量使用：1234567891011121314151617181920212223override fun onBindViewHolder(holder: RecyclerView.ViewHolder?, position: Int) &#123; if (holder is TitleHolder) &#123; // 分类 holder.itemView.new_item_title.text = mDatas?.get(position)?.type &#125; else if (holder is ContentViewHolder) &#123; with(holder.itemView) &#123; // 名称 new_item_text.text = mDatas?.get(position)?.desc // 作者 new_item_user.text = mDatas?.get(position)?.who.let &#123; Constant.NEW_ITEM_USER_NULL &#125; &#125; // 点击 holder.itemView?.setOnClickListener &#123; onClick -&gt; val intent = Intent(mContext, DetailActivity::class.java) val data = Bundle() data.putString(Constant.URL, mDatas?.get(position)?.url) intent.putExtras(data) mContext?.startActivity(intent) &#125; &#125;&#125; Java在写Bean类的时候是这样写的123456789101112131415161718192021222324public class DataTypeBean &#123; private boolean error; private List&lt;ResultsBean&gt; results; public boolean isError() &#123; return error; &#125; public void setError(boolean error) &#123; this.error = error; &#125; public List&lt;ResultsBean&gt; getResults() &#123; return results; &#125; public void setResults(List&lt;ResultsBean&gt; results) &#123; this.results = results; &#125; public static class ResultsBean &#123; ... &#125;&#125; 而在Kotlin中直接用数据类(Data Classes)写123456789// DataTypeBean类data class DataTypeBean(var error: Boolean = false, var results: MutableList&lt;ResultsBean&gt;? = null)// ResultsBean类data class ResultsBean(var _id: String? = null, var createdAt: String? = null, var desc: String? = null, var publishedAt: String? = null, var source: String? = null, var type: String? = null, var url: String? = null, var used: Boolean = false, var who: String? = null, var images: MutableList&lt;String&gt;? = null) 是不是很方便，很简洁，下面就介绍如何安装Kotlin插件 Kotlin的插件安装 Settings-&gt;Plugins-&gt;Browse Repositories-&gt;搜索Kotlin 项目添加Kotlin（Android Studio）已存在的项目直接转换为Kotlin Code-&gt;Convert Java file to Kotlin file 转换完成后，会要求配置Kotlin 选择Modules和Kotlin的版本 Sync Gradle 转换后的文件，会有些语法之类的错误，这个后面再说 新建项目 Project的gradle 在buildscript里面添加kotlin的版本，当前是1.0.4 1ext.kotlin_version = '1.0.4' 在dependencies里面添加Kotlin依赖 1classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" Module的gradle 添加apply plugin 12apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions' 在dependencies添加依赖 12compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"compile "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version" 运行app]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
</search>
